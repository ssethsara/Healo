{"version":3,"sources":["webpack:///./~/fullcalendar/dist/fullcalendar.js","webpack:///./~/jquery/dist/jquery.min.js","webpack:///./~/moment/min/moment.min.js","webpack:///./src/app/charts/height/js/Chart.bundle.js","webpack:///./src/app/charts/height/js/utils.js","webpack:///./~/script-loader/addScript.js","webpack:///./~/fullcalendar/dist/fullcalendar.js?1024","webpack:///./~/jquery/dist/jquery.min.js?48d1","webpack:///./~/moment/min/moment.min.js?5a95","webpack:///./src/app/charts/height/js/Chart.bundle.js?c717","webpack:///./src/app/charts/height/js/utils.js?1050"],"names":[],"mappings":"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","file":"scripts.bundle.js","sourcesContent":["module.exports = \"/*!\\n * FullCalendar v3.4.0\\n * Docs & License: https://fullcalendar.io/\\n * (c) 2017 Adam Shaw\\n */\\n\\n(function(factory) {\\n\\tif (typeof define === 'function' && define.amd) {\\n\\t\\tdefine([ 'jquery', 'moment' ], factory);\\n\\t}\\n\\telse if (typeof exports === 'object') { // Node/CommonJS\\n\\t\\tmodule.exports = factory(require('jquery'), require('moment'));\\n\\t}\\n\\telse {\\n\\t\\tfactory(jQuery, moment);\\n\\t}\\n})(function($, moment) {\\n\\n;;\\n\\nvar FC = $.fullCalendar = {\\n\\tversion: \\\"3.4.0\\\",\\n\\t// When introducing internal API incompatibilities (where fullcalendar plugins would break),\\n\\t// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)\\n\\t// and the below integer should be incremented.\\n\\tinternalApiVersion: 9\\n};\\nvar fcViews = FC.views = {};\\n\\n\\n$.fn.fullCalendar = function(options) {\\n\\tvar args = Array.prototype.slice.call(arguments, 1); // for a possible method call\\n\\tvar res = this; // what this function will return (this jQuery object by default)\\n\\n\\tthis.each(function(i, _element) { // loop each DOM element involved\\n\\t\\tvar element = $(_element);\\n\\t\\tvar calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\\n\\t\\tvar singleRes; // the returned value of this single method call\\n\\n\\t\\t// a method call\\n\\t\\tif (typeof options === 'string') {\\n\\t\\t\\tif (calendar && $.isFunction(calendar[options])) {\\n\\t\\t\\t\\tsingleRes = calendar[options].apply(calendar, args);\\n\\t\\t\\t\\tif (!i) {\\n\\t\\t\\t\\t\\tres = singleRes; // record the first method call result\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (options === 'destroy') { // for the destroy method, must remove Calendar object data\\n\\t\\t\\t\\t\\telement.removeData('fullCalendar');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// a new calendar initialization\\n\\t\\telse if (!calendar) { // don't initialize twice\\n\\t\\t\\tcalendar = new Calendar(element, options);\\n\\t\\t\\telement.data('fullCalendar', calendar);\\n\\t\\t\\tcalendar.render();\\n\\t\\t}\\n\\t});\\n\\n\\treturn res;\\n};\\n\\n\\nvar complexOptions = [ // names of options that are objects whose properties should be combined\\n\\t'header',\\n\\t'footer',\\n\\t'buttonText',\\n\\t'buttonIcons',\\n\\t'themeButtonIcons'\\n];\\n\\n\\n// Merges an array of option objects into a single object\\nfunction mergeOptions(optionObjs) {\\n\\treturn mergeProps(optionObjs, complexOptions);\\n}\\n\\n;;\\n\\n// exports\\nFC.intersectRanges = intersectRanges;\\nFC.applyAll = applyAll;\\nFC.debounce = debounce;\\nFC.isInt = isInt;\\nFC.htmlEscape = htmlEscape;\\nFC.cssToStr = cssToStr;\\nFC.proxy = proxy;\\nFC.capitaliseFirstLetter = capitaliseFirstLetter;\\n\\n\\n/* FullCalendar-specific DOM Utilities\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\\n// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\\nfunction compensateScroll(rowEls, scrollbarWidths) {\\n\\tif (scrollbarWidths.left) {\\n\\t\\trowEls.css({\\n\\t\\t\\t'border-left-width': 1,\\n\\t\\t\\t'margin-left': scrollbarWidths.left - 1\\n\\t\\t});\\n\\t}\\n\\tif (scrollbarWidths.right) {\\n\\t\\trowEls.css({\\n\\t\\t\\t'border-right-width': 1,\\n\\t\\t\\t'margin-right': scrollbarWidths.right - 1\\n\\t\\t});\\n\\t}\\n}\\n\\n\\n// Undoes compensateScroll and restores all borders/margins\\nfunction uncompensateScroll(rowEls) {\\n\\trowEls.css({\\n\\t\\t'margin-left': '',\\n\\t\\t'margin-right': '',\\n\\t\\t'border-left-width': '',\\n\\t\\t'border-right-width': ''\\n\\t});\\n}\\n\\n\\n// Make the mouse cursor express that an event is not allowed in the current area\\nfunction disableCursor() {\\n\\t$('body').addClass('fc-not-allowed');\\n}\\n\\n\\n// Returns the mouse cursor to its original look\\nfunction enableCursor() {\\n\\t$('body').removeClass('fc-not-allowed');\\n}\\n\\n\\n// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\\n// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\\n// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and \\n// reduces the available height.\\nfunction distributeHeight(els, availableHeight, shouldRedistribute) {\\n\\n\\t// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\\n\\t// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\\n\\n\\tvar minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\\n\\tvar minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\\n\\tvar flexEls = []; // elements that are allowed to expand. array of DOM nodes\\n\\tvar flexOffsets = []; // amount of vertical space it takes up\\n\\tvar flexHeights = []; // actual css height\\n\\tvar usedHeight = 0;\\n\\n\\tundistributeHeight(els); // give all elements their natural height\\n\\n\\t// find elements that are below the recommended height (expandable).\\n\\t// important to query for heights in a single first pass (to avoid reflow oscillation).\\n\\tels.each(function(i, el) {\\n\\t\\tvar minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\\n\\t\\tvar naturalOffset = $(el).outerHeight(true);\\n\\n\\t\\tif (naturalOffset < minOffset) {\\n\\t\\t\\tflexEls.push(el);\\n\\t\\t\\tflexOffsets.push(naturalOffset);\\n\\t\\t\\tflexHeights.push($(el).height());\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// this element stretches past recommended height (non-expandable). mark the space as occupied.\\n\\t\\t\\tusedHeight += naturalOffset;\\n\\t\\t}\\n\\t});\\n\\n\\t// readjust the recommended height to only consider the height available to non-maxed-out rows.\\n\\tif (shouldRedistribute) {\\n\\t\\tavailableHeight -= usedHeight;\\n\\t\\tminOffset1 = Math.floor(availableHeight / flexEls.length);\\n\\t\\tminOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\\n\\t}\\n\\n\\t// assign heights to all expandable elements\\n\\t$(flexEls).each(function(i, el) {\\n\\t\\tvar minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\\n\\t\\tvar naturalOffset = flexOffsets[i];\\n\\t\\tvar naturalHeight = flexHeights[i];\\n\\t\\tvar newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\\n\\n\\t\\tif (naturalOffset < minOffset) { // we check this again because redistribution might have changed things\\n\\t\\t\\t$(el).height(newHeight);\\n\\t\\t}\\n\\t});\\n}\\n\\n\\n// Undoes distrubuteHeight, restoring all els to their natural height\\nfunction undistributeHeight(els) {\\n\\tels.height('');\\n}\\n\\n\\n// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\\n// cells to be that width.\\n// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\\nfunction matchCellWidths(els) {\\n\\tvar maxInnerWidth = 0;\\n\\n\\tels.find('> *').each(function(i, innerEl) {\\n\\t\\tvar innerWidth = $(innerEl).outerWidth();\\n\\t\\tif (innerWidth > maxInnerWidth) {\\n\\t\\t\\tmaxInnerWidth = innerWidth;\\n\\t\\t}\\n\\t});\\n\\n\\tmaxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\\n\\n\\tels.width(maxInnerWidth);\\n\\n\\treturn maxInnerWidth;\\n}\\n\\n\\n// Given one element that resides inside another,\\n// Subtracts the height of the inner element from the outer element.\\nfunction subtractInnerElHeight(outerEl, innerEl) {\\n\\tvar both = outerEl.add(innerEl);\\n\\tvar diff;\\n\\n\\t// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\\n\\tboth.css({\\n\\t\\tposition: 'relative', // cause a reflow, which will force fresh dimension recalculation\\n\\t\\tleft: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\\n\\t});\\n\\tdiff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\\n\\tboth.css({ position: '', left: '' }); // undo hack\\n\\n\\treturn diff;\\n}\\n\\n\\n/* Element Geom Utilities\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nFC.getOuterRect = getOuterRect;\\nFC.getClientRect = getClientRect;\\nFC.getContentRect = getContentRect;\\nFC.getScrollbarWidths = getScrollbarWidths;\\n\\n\\n// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\\nfunction getScrollParent(el) {\\n\\tvar position = el.css('position'),\\n\\t\\tscrollParent = el.parents().filter(function() {\\n\\t\\t\\tvar parent = $(this);\\n\\t\\t\\treturn (/(auto|scroll)/).test(\\n\\t\\t\\t\\tparent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')\\n\\t\\t\\t);\\n\\t\\t}).eq(0);\\n\\n\\treturn position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\\n}\\n\\n\\n// Queries the outer bounding area of a jQuery element.\\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\\n// Origin is optional.\\nfunction getOuterRect(el, origin) {\\n\\tvar offset = el.offset();\\n\\tvar left = offset.left - (origin ? origin.left : 0);\\n\\tvar top = offset.top - (origin ? origin.top : 0);\\n\\n\\treturn {\\n\\t\\tleft: left,\\n\\t\\tright: left + el.outerWidth(),\\n\\t\\ttop: top,\\n\\t\\tbottom: top + el.outerHeight()\\n\\t};\\n}\\n\\n\\n// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\\n// Origin is optional.\\n// WARNING: given element can't have borders\\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\\nfunction getClientRect(el, origin) {\\n\\tvar offset = el.offset();\\n\\tvar scrollbarWidths = getScrollbarWidths(el);\\n\\tvar left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\\n\\tvar top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\\n\\n\\treturn {\\n\\t\\tleft: left,\\n\\t\\tright: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars\\n\\t\\ttop: top,\\n\\t\\tbottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\\n\\t};\\n}\\n\\n\\n// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\\n// Origin is optional.\\nfunction getContentRect(el, origin) {\\n\\tvar offset = el.offset(); // just outside of border, margin not included\\n\\tvar left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -\\n\\t\\t(origin ? origin.left : 0);\\n\\tvar top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -\\n\\t\\t(origin ? origin.top : 0);\\n\\n\\treturn {\\n\\t\\tleft: left,\\n\\t\\tright: left + el.width(),\\n\\t\\ttop: top,\\n\\t\\tbottom: top + el.height()\\n\\t};\\n}\\n\\n\\n// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\\n// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).\\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\\nfunction getScrollbarWidths(el) {\\n\\tvar leftRightWidth = el[0].offsetWidth - el[0].clientWidth;\\n\\tvar bottomWidth = el[0].offsetHeight - el[0].clientHeight;\\n\\tvar widths;\\n\\n\\tleftRightWidth = sanitizeScrollbarWidth(leftRightWidth);\\n\\tbottomWidth = sanitizeScrollbarWidth(bottomWidth);\\n\\n\\twidths = { left: 0, right: 0, top: 0, bottom: bottomWidth };\\n\\n\\tif (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?\\n\\t\\twidths.left = leftRightWidth;\\n\\t}\\n\\telse {\\n\\t\\twidths.right = leftRightWidth;\\n\\t}\\n\\n\\treturn widths;\\n}\\n\\n\\n// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to\\n// retina displays, rounding, and IE11. Massage them into a usable value.\\nfunction sanitizeScrollbarWidth(width) {\\n\\twidth = Math.max(0, width); // no negatives\\n\\twidth = Math.round(width);\\n\\treturn width;\\n}\\n\\n\\n// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\\n\\nvar _isLeftRtlScrollbars = null;\\n\\nfunction getIsLeftRtlScrollbars() { // responsible for caching the computation\\n\\tif (_isLeftRtlScrollbars === null) {\\n\\t\\t_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\\n\\t}\\n\\treturn _isLeftRtlScrollbars;\\n}\\n\\nfunction computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it\\n\\tvar el = $('<div><div/></div>')\\n\\t\\t.css({\\n\\t\\t\\tposition: 'absolute',\\n\\t\\t\\ttop: -1000,\\n\\t\\t\\tleft: 0,\\n\\t\\t\\tborder: 0,\\n\\t\\t\\tpadding: 0,\\n\\t\\t\\toverflow: 'scroll',\\n\\t\\t\\tdirection: 'rtl'\\n\\t\\t})\\n\\t\\t.appendTo('body');\\n\\tvar innerEl = el.children();\\n\\tvar res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\\n\\tel.remove();\\n\\treturn res;\\n}\\n\\n\\n// Retrieves a jQuery element's computed CSS value as a floating-point number.\\n// If the queried value is non-numeric (ex: IE can return \\\"medium\\\" for border width), will just return zero.\\nfunction getCssFloat(el, prop) {\\n\\treturn parseFloat(el.css(prop)) || 0;\\n}\\n\\n\\n/* Mouse / Touch Utilities\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nFC.preventDefault = preventDefault;\\n\\n\\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\\nfunction isPrimaryMouseButton(ev) {\\n\\treturn ev.which == 1 && !ev.ctrlKey;\\n}\\n\\n\\nfunction getEvX(ev) {\\n\\tvar touches = ev.originalEvent.touches;\\n\\n\\t// on mobile FF, pageX for touch events is present, but incorrect,\\n\\t// so, look at touch coordinates first.\\n\\tif (touches && touches.length) {\\n\\t\\treturn touches[0].pageX;\\n\\t}\\n\\n\\treturn ev.pageX;\\n}\\n\\n\\nfunction getEvY(ev) {\\n\\tvar touches = ev.originalEvent.touches;\\n\\n\\t// on mobile FF, pageX for touch events is present, but incorrect,\\n\\t// so, look at touch coordinates first.\\n\\tif (touches && touches.length) {\\n\\t\\treturn touches[0].pageY;\\n\\t}\\n\\n\\treturn ev.pageY;\\n}\\n\\n\\nfunction getEvIsTouch(ev) {\\n\\treturn /^touch/.test(ev.type);\\n}\\n\\n\\nfunction preventSelection(el) {\\n\\tel.addClass('fc-unselectable')\\n\\t\\t.on('selectstart', preventDefault);\\n}\\n\\n\\nfunction allowSelection(el) {\\n\\tel.removeClass('fc-unselectable')\\n\\t\\t.off('selectstart', preventDefault);\\n}\\n\\n\\n// Stops a mouse/touch event from doing it's native browser action\\nfunction preventDefault(ev) {\\n\\tev.preventDefault();\\n}\\n\\n\\n/* General Geometry Utils\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nFC.intersectRects = intersectRects;\\n\\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\\nfunction intersectRects(rect1, rect2) {\\n\\tvar res = {\\n\\t\\tleft: Math.max(rect1.left, rect2.left),\\n\\t\\tright: Math.min(rect1.right, rect2.right),\\n\\t\\ttop: Math.max(rect1.top, rect2.top),\\n\\t\\tbottom: Math.min(rect1.bottom, rect2.bottom)\\n\\t};\\n\\n\\tif (res.left < res.right && res.top < res.bottom) {\\n\\t\\treturn res;\\n\\t}\\n\\treturn false;\\n}\\n\\n\\n// Returns a new point that will have been moved to reside within the given rectangle\\nfunction constrainPoint(point, rect) {\\n\\treturn {\\n\\t\\tleft: Math.min(Math.max(point.left, rect.left), rect.right),\\n\\t\\ttop: Math.min(Math.max(point.top, rect.top), rect.bottom)\\n\\t};\\n}\\n\\n\\n// Returns a point that is the center of the given rectangle\\nfunction getRectCenter(rect) {\\n\\treturn {\\n\\t\\tleft: (rect.left + rect.right) / 2,\\n\\t\\ttop: (rect.top + rect.bottom) / 2\\n\\t};\\n}\\n\\n\\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\\nfunction diffPoints(point1, point2) {\\n\\treturn {\\n\\t\\tleft: point1.left - point2.left,\\n\\t\\ttop: point1.top - point2.top\\n\\t};\\n}\\n\\n\\n/* Object Ordering by Field\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nFC.parseFieldSpecs = parseFieldSpecs;\\nFC.compareByFieldSpecs = compareByFieldSpecs;\\nFC.compareByFieldSpec = compareByFieldSpec;\\nFC.flexibleCompare = flexibleCompare;\\n\\n\\nfunction parseFieldSpecs(input) {\\n\\tvar specs = [];\\n\\tvar tokens = [];\\n\\tvar i, token;\\n\\n\\tif (typeof input === 'string') {\\n\\t\\ttokens = input.split(/\\\\s*,\\\\s*/);\\n\\t}\\n\\telse if (typeof input === 'function') {\\n\\t\\ttokens = [ input ];\\n\\t}\\n\\telse if ($.isArray(input)) {\\n\\t\\ttokens = input;\\n\\t}\\n\\n\\tfor (i = 0; i < tokens.length; i++) {\\n\\t\\ttoken = tokens[i];\\n\\n\\t\\tif (typeof token === 'string') {\\n\\t\\t\\tspecs.push(\\n\\t\\t\\t\\ttoken.charAt(0) == '-' ?\\n\\t\\t\\t\\t\\t{ field: token.substring(1), order: -1 } :\\n\\t\\t\\t\\t\\t{ field: token, order: 1 }\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\telse if (typeof token === 'function') {\\n\\t\\t\\tspecs.push({ func: token });\\n\\t\\t}\\n\\t}\\n\\n\\treturn specs;\\n}\\n\\n\\nfunction compareByFieldSpecs(obj1, obj2, fieldSpecs) {\\n\\tvar i;\\n\\tvar cmp;\\n\\n\\tfor (i = 0; i < fieldSpecs.length; i++) {\\n\\t\\tcmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);\\n\\t\\tif (cmp) {\\n\\t\\t\\treturn cmp;\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n\\nfunction compareByFieldSpec(obj1, obj2, fieldSpec) {\\n\\tif (fieldSpec.func) {\\n\\t\\treturn fieldSpec.func(obj1, obj2);\\n\\t}\\n\\treturn flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *\\n\\t\\t(fieldSpec.order || 1);\\n}\\n\\n\\nfunction flexibleCompare(a, b) {\\n\\tif (!a && !b) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (b == null) {\\n\\t\\treturn -1;\\n\\t}\\n\\tif (a == null) {\\n\\t\\treturn 1;\\n\\t}\\n\\tif ($.type(a) === 'string' || $.type(b) === 'string') {\\n\\t\\treturn String(a).localeCompare(String(b));\\n\\t}\\n\\treturn a - b;\\n}\\n\\n\\n/* FullCalendar-specific Misc Utilities\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n// Computes the intersection of the two ranges. Will return fresh date clones in a range.\\n// Returns undefined if no intersection.\\n// Expects all dates to be normalized to the same timezone beforehand.\\n// TODO: move to date section?\\nfunction intersectRanges(subjectRange, constraintRange) {\\n\\tvar subjectStart = subjectRange.start;\\n\\tvar subjectEnd = subjectRange.end;\\n\\tvar constraintStart = constraintRange.start;\\n\\tvar constraintEnd = constraintRange.end;\\n\\tvar segStart, segEnd;\\n\\tvar isStart, isEnd;\\n\\n\\tif (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?\\n\\n\\t\\tif (subjectStart >= constraintStart) {\\n\\t\\t\\tsegStart = subjectStart.clone();\\n\\t\\t\\tisStart = true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tsegStart = constraintStart.clone();\\n\\t\\t\\tisStart =  false;\\n\\t\\t}\\n\\n\\t\\tif (subjectEnd <= constraintEnd) {\\n\\t\\t\\tsegEnd = subjectEnd.clone();\\n\\t\\t\\tisEnd = true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tsegEnd = constraintEnd.clone();\\n\\t\\t\\tisEnd = false;\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tstart: segStart,\\n\\t\\t\\tend: segEnd,\\n\\t\\t\\tisStart: isStart,\\n\\t\\t\\tisEnd: isEnd\\n\\t\\t};\\n\\t}\\n}\\n\\n\\n/* Date Utilities\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nFC.computeGreatestUnit = computeGreatestUnit;\\nFC.divideRangeByDuration = divideRangeByDuration;\\nFC.divideDurationByDuration = divideDurationByDuration;\\nFC.multiplyDuration = multiplyDuration;\\nFC.durationHasTime = durationHasTime;\\n\\nvar dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];\\nvar unitsDesc = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ]; // descending\\n\\n\\n// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\\n// Moments will have their timezones normalized.\\nfunction diffDayTime(a, b) {\\n\\treturn moment.duration({\\n\\t\\tdays: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\\n\\t\\tms: a.time() - b.time() // time-of-day from day start. disregards timezone\\n\\t});\\n}\\n\\n\\n// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\\nfunction diffDay(a, b) {\\n\\treturn moment.duration({\\n\\t\\tdays: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\\n\\t});\\n}\\n\\n\\n// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\\nfunction diffByUnit(a, b, unit) {\\n\\treturn moment.duration(\\n\\t\\tMath.round(a.diff(b, unit, true)), // returnFloat=true\\n\\t\\tunit\\n\\t);\\n}\\n\\n\\n// Computes the unit name of the largest whole-unit period of time.\\n// For example, 48 hours will be \\\"days\\\" whereas 49 hours will be \\\"hours\\\".\\n// Accepts start/end, a range object, or an original duration object.\\nfunction computeGreatestUnit(start, end) {\\n\\tvar i, unit;\\n\\tvar val;\\n\\n\\tfor (i = 0; i < unitsDesc.length; i++) {\\n\\t\\tunit = unitsDesc[i];\\n\\t\\tval = computeRangeAs(unit, start, end);\\n\\n\\t\\tif (val >= 1 && isInt(val)) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\treturn unit; // will be \\\"milliseconds\\\" if nothing else matches\\n}\\n\\n\\n// like computeGreatestUnit, but has special abilities to interpret the source input for clues\\nfunction computeDurationGreatestUnit(duration, durationInput) {\\n\\tvar unit = computeGreatestUnit(duration);\\n\\n\\t// prevent days:7 from being interpreted as a week\\n\\tif (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {\\n\\t\\tunit = 'day';\\n\\t}\\n\\n\\treturn unit;\\n}\\n\\n\\n// Computes the number of units (like \\\"hours\\\") in the given range.\\n// Range can be a {start,end} object, separate start/end args, or a Duration.\\n// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\\n// of month-diffing logic (which tends to vary from version to version).\\nfunction computeRangeAs(unit, start, end) {\\n\\n\\tif (end != null) { // given start, end\\n\\t\\treturn end.diff(start, unit, true);\\n\\t}\\n\\telse if (moment.isDuration(start)) { // given duration\\n\\t\\treturn start.as(unit);\\n\\t}\\n\\telse { // given { start, end } range object\\n\\t\\treturn start.end.diff(start.start, unit, true);\\n\\t}\\n}\\n\\n\\n// Intelligently divides a range (specified by a start/end params) by a duration\\nfunction divideRangeByDuration(start, end, dur) {\\n\\tvar months;\\n\\n\\tif (durationHasTime(dur)) {\\n\\t\\treturn (end - start) / dur;\\n\\t}\\n\\tmonths = dur.asMonths();\\n\\tif (Math.abs(months) >= 1 && isInt(months)) {\\n\\t\\treturn end.diff(start, 'months', true) / months;\\n\\t}\\n\\treturn end.diff(start, 'days', true) / dur.asDays();\\n}\\n\\n\\n// Intelligently divides one duration by another\\nfunction divideDurationByDuration(dur1, dur2) {\\n\\tvar months1, months2;\\n\\n\\tif (durationHasTime(dur1) || durationHasTime(dur2)) {\\n\\t\\treturn dur1 / dur2;\\n\\t}\\n\\tmonths1 = dur1.asMonths();\\n\\tmonths2 = dur2.asMonths();\\n\\tif (\\n\\t\\tMath.abs(months1) >= 1 && isInt(months1) &&\\n\\t\\tMath.abs(months2) >= 1 && isInt(months2)\\n\\t) {\\n\\t\\treturn months1 / months2;\\n\\t}\\n\\treturn dur1.asDays() / dur2.asDays();\\n}\\n\\n\\n// Intelligently multiplies a duration by a number\\nfunction multiplyDuration(dur, n) {\\n\\tvar months;\\n\\n\\tif (durationHasTime(dur)) {\\n\\t\\treturn moment.duration(dur * n);\\n\\t}\\n\\tmonths = dur.asMonths();\\n\\tif (Math.abs(months) >= 1 && isInt(months)) {\\n\\t\\treturn moment.duration({ months: months * n });\\n\\t}\\n\\treturn moment.duration({ days: dur.asDays() * n });\\n}\\n\\n\\nfunction cloneRange(range) {\\n\\treturn {\\n\\t\\tstart: range.start.clone(),\\n\\t\\tend: range.end.clone()\\n\\t};\\n}\\n\\n\\n// Trims the beginning and end of inner range to be completely within outerRange.\\n// Returns a new range object.\\nfunction constrainRange(innerRange, outerRange) {\\n\\tinnerRange = cloneRange(innerRange);\\n\\n\\tif (outerRange.start) {\\n\\t\\t// needs to be inclusively before outerRange's end\\n\\t\\tinnerRange.start = constrainDate(innerRange.start, outerRange);\\n\\t}\\n\\n\\tif (outerRange.end) {\\n\\t\\tinnerRange.end = minMoment(innerRange.end, outerRange.end);\\n\\t}\\n\\n\\treturn innerRange;\\n}\\n\\n\\n// If the given date is not within the given range, move it inside.\\n// (If it's past the end, make it one millisecond before the end).\\n// Always returns a new moment.\\nfunction constrainDate(date, range) {\\n\\tdate = date.clone();\\n\\n\\tif (range.start) {\\n\\t\\tdate = maxMoment(date, range.start);\\n\\t}\\n\\n\\tif (range.end && date >= range.end) {\\n\\t\\tdate = range.end.clone().subtract(1);\\n\\t}\\n\\n\\treturn date;\\n}\\n\\n\\nfunction isDateWithinRange(date, range) {\\n\\treturn (!range.start || date >= range.start) &&\\n\\t\\t(!range.end || date < range.end);\\n}\\n\\n\\n// TODO: deal with repeat code in intersectRanges\\n// constraintRange can have unspecified start/end, an open-ended range.\\nfunction doRangesIntersect(subjectRange, constraintRange) {\\n\\treturn (!constraintRange.start || subjectRange.end >= constraintRange.start) &&\\n\\t\\t(!constraintRange.end || subjectRange.start < constraintRange.end);\\n}\\n\\n\\nfunction isRangeWithinRange(innerRange, outerRange) {\\n\\treturn (!outerRange.start || innerRange.start >= outerRange.start) &&\\n\\t\\t(!outerRange.end || innerRange.end <= outerRange.end);\\n}\\n\\n\\nfunction isRangesEqual(range0, range1) {\\n\\treturn ((range0.start && range1.start && range0.start.isSame(range1.start)) || (!range0.start && !range1.start)) &&\\n\\t\\t((range0.end && range1.end && range0.end.isSame(range1.end)) || (!range0.end && !range1.end));\\n}\\n\\n\\n// Returns the moment that's earlier in time. Always a copy.\\nfunction minMoment(mom1, mom2) {\\n\\treturn (mom1.isBefore(mom2) ? mom1 : mom2).clone();\\n}\\n\\n\\n// Returns the moment that's later in time. Always a copy.\\nfunction maxMoment(mom1, mom2) {\\n\\treturn (mom1.isAfter(mom2) ? mom1 : mom2).clone();\\n}\\n\\n\\n// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\\nfunction durationHasTime(dur) {\\n\\treturn Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\\n}\\n\\n\\nfunction isNativeDate(input) {\\n\\treturn  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\\n}\\n\\n\\n// Returns a boolean about whether the given input is a time string, like \\\"06:40:00\\\" or \\\"06:00\\\"\\nfunction isTimeString(str) {\\n\\treturn /^\\\\d+\\\\:\\\\d+(?:\\\\:\\\\d+\\\\.?(?:\\\\d{3})?)?$/.test(str);\\n}\\n\\n\\n/* Logging and Debug\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nFC.log = function() {\\n\\tvar console = window.console;\\n\\n\\tif (console && console.log) {\\n\\t\\treturn console.log.apply(console, arguments);\\n\\t}\\n};\\n\\nFC.warn = function() {\\n\\tvar console = window.console;\\n\\n\\tif (console && console.warn) {\\n\\t\\treturn console.warn.apply(console, arguments);\\n\\t}\\n\\telse {\\n\\t\\treturn FC.log.apply(FC, arguments);\\n\\t}\\n};\\n\\n\\n/* General Utilities\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nvar hasOwnPropMethod = {}.hasOwnProperty;\\n\\n\\n// Merges an array of objects into a single object.\\n// The second argument allows for an array of property names who's object values will be merged together.\\nfunction mergeProps(propObjs, complexProps) {\\n\\tvar dest = {};\\n\\tvar i, name;\\n\\tvar complexObjs;\\n\\tvar j, val;\\n\\tvar props;\\n\\n\\tif (complexProps) {\\n\\t\\tfor (i = 0; i < complexProps.length; i++) {\\n\\t\\t\\tname = complexProps[i];\\n\\t\\t\\tcomplexObjs = [];\\n\\n\\t\\t\\t// collect the trailing object values, stopping when a non-object is discovered\\n\\t\\t\\tfor (j = propObjs.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\tval = propObjs[j][name];\\n\\n\\t\\t\\t\\tif (typeof val === 'object') {\\n\\t\\t\\t\\t\\tcomplexObjs.unshift(val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (val !== undefined) {\\n\\t\\t\\t\\t\\tdest[name] = val; // if there were no objects, this value will be used\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the trailing values were objects, use the merged value\\n\\t\\t\\tif (complexObjs.length) {\\n\\t\\t\\t\\tdest[name] = mergeProps(complexObjs);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// copy values into the destination, going from last to first\\n\\tfor (i = propObjs.length - 1; i >= 0; i--) {\\n\\t\\tprops = propObjs[i];\\n\\n\\t\\tfor (name in props) {\\n\\t\\t\\tif (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign\\n\\t\\t\\t\\tdest[name] = props[name];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dest;\\n}\\n\\n\\n// Create an object that has the given prototype. Just like Object.create\\nfunction createObject(proto) {\\n\\tvar f = function() {};\\n\\tf.prototype = proto;\\n\\treturn new f();\\n}\\nFC.createObject = createObject;\\n\\n\\nfunction copyOwnProps(src, dest) {\\n\\tfor (var name in src) {\\n\\t\\tif (hasOwnProp(src, name)) {\\n\\t\\t\\tdest[name] = src[name];\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nfunction hasOwnProp(obj, name) {\\n\\treturn hasOwnPropMethod.call(obj, name);\\n}\\n\\n\\n// Is the given value a non-object non-function value?\\nfunction isAtomic(val) {\\n\\treturn /undefined|null|boolean|number|string/.test($.type(val));\\n}\\n\\n\\nfunction applyAll(functions, thisObj, args) {\\n\\tif ($.isFunction(functions)) {\\n\\t\\tfunctions = [ functions ];\\n\\t}\\n\\tif (functions) {\\n\\t\\tvar i;\\n\\t\\tvar ret;\\n\\t\\tfor (i=0; i<functions.length; i++) {\\n\\t\\t\\tret = functions[i].apply(thisObj, args) || ret;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n}\\n\\n\\nfunction firstDefined() {\\n\\tfor (var i=0; i<arguments.length; i++) {\\n\\t\\tif (arguments[i] !== undefined) {\\n\\t\\t\\treturn arguments[i];\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nfunction htmlEscape(s) {\\n\\treturn (s + '').replace(/&/g, '&amp;')\\n\\t\\t.replace(/</g, '&lt;')\\n\\t\\t.replace(/>/g, '&gt;')\\n\\t\\t.replace(/'/g, '&#039;')\\n\\t\\t.replace(/\\\"/g, '&quot;')\\n\\t\\t.replace(/\\\\n/g, '<br />');\\n}\\n\\n\\nfunction stripHtmlEntities(text) {\\n\\treturn text.replace(/&.*?;/g, '');\\n}\\n\\n\\n// Given a hash of CSS properties, returns a string of CSS.\\n// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\\nfunction cssToStr(cssProps) {\\n\\tvar statements = [];\\n\\n\\t$.each(cssProps, function(name, val) {\\n\\t\\tif (val != null) {\\n\\t\\t\\tstatements.push(name + ':' + val);\\n\\t\\t}\\n\\t});\\n\\n\\treturn statements.join(';');\\n}\\n\\n\\n// Given an object hash of HTML attribute names to values,\\n// generates a string that can be injected between < > in HTML\\nfunction attrsToStr(attrs) {\\n\\tvar parts = [];\\n\\n\\t$.each(attrs, function(name, val) {\\n\\t\\tif (val != null) {\\n\\t\\t\\tparts.push(name + '=\\\"' + htmlEscape(val) + '\\\"');\\n\\t\\t}\\n\\t});\\n\\n\\treturn parts.join(' ');\\n}\\n\\n\\nfunction capitaliseFirstLetter(str) {\\n\\treturn str.charAt(0).toUpperCase() + str.slice(1);\\n}\\n\\n\\nfunction compareNumbers(a, b) { // for .sort()\\n\\treturn a - b;\\n}\\n\\n\\nfunction isInt(n) {\\n\\treturn n % 1 === 0;\\n}\\n\\n\\n// Returns a method bound to the given object context.\\n// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\\n// different contexts as identical when binding/unbinding events.\\nfunction proxy(obj, methodName) {\\n\\tvar method = obj[methodName];\\n\\n\\treturn function() {\\n\\t\\treturn method.apply(obj, arguments);\\n\\t};\\n}\\n\\n\\n// Returns a function, that, as long as it continues to be invoked, will not\\n// be triggered. The function will be called after it stops being called for\\n// N milliseconds. If `immediate` is passed, trigger the function on the\\n// leading edge, instead of the trailing.\\n// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\\nfunction debounce(func, wait, immediate) {\\n\\tvar timeout, args, context, timestamp, result;\\n\\n\\tvar later = function() {\\n\\t\\tvar last = +new Date() - timestamp;\\n\\t\\tif (last < wait) {\\n\\t\\t\\ttimeout = setTimeout(later, wait - last);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ttimeout = null;\\n\\t\\t\\tif (!immediate) {\\n\\t\\t\\t\\tresult = func.apply(context, args);\\n\\t\\t\\t\\tcontext = args = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\treturn function() {\\n\\t\\tcontext = this;\\n\\t\\targs = arguments;\\n\\t\\ttimestamp = +new Date();\\n\\t\\tvar callNow = immediate && !timeout;\\n\\t\\tif (!timeout) {\\n\\t\\t\\ttimeout = setTimeout(later, wait);\\n\\t\\t}\\n\\t\\tif (callNow) {\\n\\t\\t\\tresult = func.apply(context, args);\\n\\t\\t\\tcontext = args = null;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t};\\n}\\n\\n;;\\n\\n/*\\nGENERAL NOTE on moments throughout the *entire rest* of the codebase:\\nAll moments are assumed to be ambiguously-zoned unless otherwise noted,\\nwith the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.\\nAmbiguously-TIMED moments are assumed to be ambiguously-zoned by nature.\\n*/\\n\\nvar ambigDateOfMonthRegex = /^\\\\s*\\\\d{4}-\\\\d\\\\d$/;\\nvar ambigTimeOrZoneRegex =\\n\\t/^\\\\s*\\\\d{4}-(?:(\\\\d\\\\d-\\\\d\\\\d)|(W\\\\d\\\\d$)|(W\\\\d\\\\d-\\\\d)|(\\\\d\\\\d\\\\d))((T| )(\\\\d\\\\d(:\\\\d\\\\d(:\\\\d\\\\d(\\\\.\\\\d+)?)?)?)?)?$/;\\nvar newMomentProto = moment.fn; // where we will attach our new methods\\nvar oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\\n\\n// tell momentjs to transfer these properties upon clone\\nvar momentProperties = moment.momentProperties;\\nmomentProperties.push('_fullCalendar');\\nmomentProperties.push('_ambigTime');\\nmomentProperties.push('_ambigZone');\\n\\n\\n// Creating\\n// -------------------------------------------------------------------------------------------------\\n\\n// Creates a new moment, similar to the vanilla moment(...) constructor, but with\\n// extra features (ambiguous time, enhanced formatting). When given an existing moment,\\n// it will function as a clone (and retain the zone of the moment). Anything else will\\n// result in a moment in the local zone.\\nFC.moment = function() {\\n\\treturn makeMoment(arguments);\\n};\\n\\n// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.\\nFC.moment.utc = function() {\\n\\tvar mom = makeMoment(arguments, true);\\n\\n\\t// Force it into UTC because makeMoment doesn't guarantee it\\n\\t// (if given a pre-existing moment for example)\\n\\tif (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone\\n\\t\\tmom.utc();\\n\\t}\\n\\n\\treturn mom;\\n};\\n\\n// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.\\n// ISO8601 strings with no timezone offset will become ambiguously zoned.\\nFC.moment.parseZone = function() {\\n\\treturn makeMoment(arguments, true, true);\\n};\\n\\n// Builds an enhanced moment from args. When given an existing moment, it clones. When given a\\n// native Date, or called with no arguments (the current time), the resulting moment will be local.\\n// Anything else needs to be \\\"parsed\\\" (a string or an array), and will be affected by:\\n//    parseAsUTC - if there is no zone information, should we parse the input in UTC?\\n//    parseZone - if there is zone information, should we force the zone of the moment?\\nfunction makeMoment(args, parseAsUTC, parseZone) {\\n\\tvar input = args[0];\\n\\tvar isSingleString = args.length == 1 && typeof input === 'string';\\n\\tvar isAmbigTime;\\n\\tvar isAmbigZone;\\n\\tvar ambigMatch;\\n\\tvar mom;\\n\\n\\tif (moment.isMoment(input) || isNativeDate(input) || input === undefined) {\\n\\t\\tmom = moment.apply(null, args);\\n\\t}\\n\\telse { // \\\"parsing\\\" is required\\n\\t\\tisAmbigTime = false;\\n\\t\\tisAmbigZone = false;\\n\\n\\t\\tif (isSingleString) {\\n\\t\\t\\tif (ambigDateOfMonthRegex.test(input)) {\\n\\t\\t\\t\\t// accept strings like '2014-05', but convert to the first of the month\\n\\t\\t\\t\\tinput += '-01';\\n\\t\\t\\t\\targs = [ input ]; // for when we pass it on to moment's constructor\\n\\t\\t\\t\\tisAmbigTime = true;\\n\\t\\t\\t\\tisAmbigZone = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {\\n\\t\\t\\t\\tisAmbigTime = !ambigMatch[5]; // no time part?\\n\\t\\t\\t\\tisAmbigZone = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if ($.isArray(input)) {\\n\\t\\t\\t// arrays have no timezone information, so assume ambiguous zone\\n\\t\\t\\tisAmbigZone = true;\\n\\t\\t}\\n\\t\\t// otherwise, probably a string with a format\\n\\n\\t\\tif (parseAsUTC || isAmbigTime) {\\n\\t\\t\\tmom = moment.utc.apply(moment, args);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmom = moment.apply(null, args);\\n\\t\\t}\\n\\n\\t\\tif (isAmbigTime) {\\n\\t\\t\\tmom._ambigTime = true;\\n\\t\\t\\tmom._ambigZone = true; // ambiguous time always means ambiguous zone\\n\\t\\t}\\n\\t\\telse if (parseZone) { // let's record the inputted zone somehow\\n\\t\\t\\tif (isAmbigZone) {\\n\\t\\t\\t\\tmom._ambigZone = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if (isSingleString) {\\n\\t\\t\\t\\tmom.utcOffset(input); // if not a valid zone, will assign UTC\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tmom._fullCalendar = true; // flag for extended functionality\\n\\n\\treturn mom;\\n}\\n\\n\\n// Week Number\\n// -------------------------------------------------------------------------------------------------\\n\\n\\n// Returns the week number, considering the locale's custom week number calcuation\\n// `weeks` is an alias for `week`\\nnewMomentProto.week = newMomentProto.weeks = function(input) {\\n\\tvar weekCalc = this._locale._fullCalendar_weekCalc;\\n\\n\\tif (input == null && typeof weekCalc === 'function') { // custom function only works for getter\\n\\t\\treturn weekCalc(this);\\n\\t}\\n\\telse if (weekCalc === 'ISO') {\\n\\t\\treturn oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\\n\\t}\\n\\n\\treturn oldMomentProto.week.apply(this, arguments); // local getter/setter\\n};\\n\\n\\n// Time-of-day\\n// -------------------------------------------------------------------------------------------------\\n\\n// GETTER\\n// Returns a Duration with the hours/minutes/seconds/ms values of the moment.\\n// If the moment has an ambiguous time, a duration of 00:00 will be returned.\\n//\\n// SETTER\\n// You can supply a Duration, a Moment, or a Duration-like argument.\\n// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\\nnewMomentProto.time = function(time) {\\n\\n\\t// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\\n\\t// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\\n\\tif (!this._fullCalendar) {\\n\\t\\treturn oldMomentProto.time.apply(this, arguments);\\n\\t}\\n\\n\\tif (time == null) { // getter\\n\\t\\treturn moment.duration({\\n\\t\\t\\thours: this.hours(),\\n\\t\\t\\tminutes: this.minutes(),\\n\\t\\t\\tseconds: this.seconds(),\\n\\t\\t\\tmilliseconds: this.milliseconds()\\n\\t\\t});\\n\\t}\\n\\telse { // setter\\n\\n\\t\\tthis._ambigTime = false; // mark that the moment now has a time\\n\\n\\t\\tif (!moment.isDuration(time) && !moment.isMoment(time)) {\\n\\t\\t\\ttime = moment.duration(time);\\n\\t\\t}\\n\\n\\t\\t// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\\n\\t\\t// Only for Duration times, not Moment times.\\n\\t\\tvar dayHours = 0;\\n\\t\\tif (moment.isDuration(time)) {\\n\\t\\t\\tdayHours = Math.floor(time.asDays()) * 24;\\n\\t\\t}\\n\\n\\t\\t// We need to set the individual fields.\\n\\t\\t// Can't use startOf('day') then add duration. In case of DST at start of day.\\n\\t\\treturn this.hours(dayHours + time.hours())\\n\\t\\t\\t.minutes(time.minutes())\\n\\t\\t\\t.seconds(time.seconds())\\n\\t\\t\\t.milliseconds(time.milliseconds());\\n\\t}\\n};\\n\\n// Converts the moment to UTC, stripping out its time-of-day and timezone offset,\\n// but preserving its YMD. A moment with a stripped time will display no time\\n// nor timezone offset when .format() is called.\\nnewMomentProto.stripTime = function() {\\n\\n\\tif (!this._ambigTime) {\\n\\n\\t\\tthis.utc(true); // keepLocalTime=true (for keeping *date* value)\\n\\n\\t\\t// set time to zero\\n\\t\\tthis.set({\\n\\t\\t\\thours: 0,\\n\\t\\t\\tminutes: 0,\\n\\t\\t\\tseconds: 0,\\n\\t\\t\\tms: 0\\n\\t\\t});\\n\\n\\t\\t// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\\n\\t\\t// which clears all ambig flags.\\n\\t\\tthis._ambigTime = true;\\n\\t\\tthis._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\\n\\t}\\n\\n\\treturn this; // for chaining\\n};\\n\\n// Returns if the moment has a non-ambiguous time (boolean)\\nnewMomentProto.hasTime = function() {\\n\\treturn !this._ambigTime;\\n};\\n\\n\\n// Timezone\\n// -------------------------------------------------------------------------------------------------\\n\\n// Converts the moment to UTC, stripping out its timezone offset, but preserving its\\n// YMD and time-of-day. A moment with a stripped timezone offset will display no\\n// timezone offset when .format() is called.\\nnewMomentProto.stripZone = function() {\\n\\tvar wasAmbigTime;\\n\\n\\tif (!this._ambigZone) {\\n\\n\\t\\twasAmbigTime = this._ambigTime;\\n\\n\\t\\tthis.utc(true); // keepLocalTime=true (for keeping date and time values)\\n\\n\\t\\t// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\\n\\t\\tthis._ambigTime = wasAmbigTime || false;\\n\\n\\t\\t// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\\n\\t\\t// which clears the ambig flags.\\n\\t\\tthis._ambigZone = true;\\n\\t}\\n\\n\\treturn this; // for chaining\\n};\\n\\n// Returns of the moment has a non-ambiguous timezone offset (boolean)\\nnewMomentProto.hasZone = function() {\\n\\treturn !this._ambigZone;\\n};\\n\\n\\n// implicitly marks a zone\\nnewMomentProto.local = function(keepLocalTime) {\\n\\n\\t// for when converting from ambiguously-zoned to local,\\n\\t// keep the time values when converting from UTC -> local\\n\\toldMomentProto.local.call(this, this._ambigZone || keepLocalTime);\\n\\n\\t// ensure non-ambiguous\\n\\t// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\\n\\tthis._ambigTime = false;\\n\\tthis._ambigZone = false;\\n\\n\\treturn this; // for chaining\\n};\\n\\n\\n// implicitly marks a zone\\nnewMomentProto.utc = function(keepLocalTime) {\\n\\n\\toldMomentProto.utc.call(this, keepLocalTime);\\n\\n\\t// ensure non-ambiguous\\n\\t// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\\n\\tthis._ambigTime = false;\\n\\tthis._ambigZone = false;\\n\\n\\treturn this;\\n};\\n\\n\\n// implicitly marks a zone (will probably get called upon .utc() and .local())\\nnewMomentProto.utcOffset = function(tzo) {\\n\\n\\tif (tzo != null) { // setter\\n\\t\\t// these assignments needs to happen before the original zone method is called.\\n\\t\\t// I forget why, something to do with a browser crash.\\n\\t\\tthis._ambigTime = false;\\n\\t\\tthis._ambigZone = false;\\n\\t}\\n\\n\\treturn oldMomentProto.utcOffset.apply(this, arguments);\\n};\\n\\n\\n// Formatting\\n// -------------------------------------------------------------------------------------------------\\n\\nnewMomentProto.format = function() {\\n\\n\\tif (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?\\n\\t\\treturn formatDate(this, arguments[0]); // our extended formatting\\n\\t}\\n\\tif (this._ambigTime) {\\n\\t\\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\\n\\t}\\n\\tif (this._ambigZone) {\\n\\t\\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\\n\\t}\\n\\tif (this._fullCalendar) { // enhanced non-ambig moment?\\n\\t\\t// moment.format() doesn't ensure english, but we want to.\\n\\t\\treturn oldMomentFormat(englishMoment(this));\\n\\t}\\n\\n\\treturn oldMomentProto.format.apply(this, arguments);\\n};\\n\\nnewMomentProto.toISOString = function() {\\n\\n\\tif (this._ambigTime) {\\n\\t\\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\\n\\t}\\n\\tif (this._ambigZone) {\\n\\t\\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\\n\\t}\\n\\tif (this._fullCalendar) { // enhanced non-ambig moment?\\n\\t\\t// depending on browser, moment might not output english. ensure english.\\n\\t\\t// https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22\\n\\t\\treturn oldMomentProto.toISOString.apply(englishMoment(this), arguments);\\n\\t}\\n\\n\\treturn oldMomentProto.toISOString.apply(this, arguments);\\n};\\n\\nfunction englishMoment(mom) {\\n\\tif (mom.locale() !== 'en') {\\n\\t\\treturn mom.clone().locale('en');\\n\\t}\\n\\treturn mom;\\n}\\n\\n;;\\n(function() {\\n\\n// exports\\nFC.formatDate = formatDate;\\nFC.formatRange = formatRange;\\nFC.oldMomentFormat = oldMomentFormat;\\nFC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;\\n\\n\\n// Config\\n// ---------------------------------------------------------------------------------------------------------------------\\n\\n/*\\nInserted between chunks in the fake (\\\"intermediate\\\") formatting string.\\nImportant that it passes as whitespace (\\\\s) because moment often identifies non-standalone months\\nvia a regexp with an \\\\s.\\n*/\\nvar PART_SEPARATOR = '\\\\u000b'; // vertical tab\\n\\n/*\\nInserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,\\nbut rather, a \\\"special\\\" token that has custom rendering (see specialTokens map).\\n*/\\nvar SPECIAL_TOKEN_MARKER = '\\\\u001f'; // information separator 1\\n\\n/*\\nInserted at the beginning and end of a span of text that must have non-zero numeric characters.\\nHandling of these markers is done in a post-processing step at the very end of text rendering.\\n*/\\nvar MAYBE_MARKER = '\\\\u001e'; // information separator 2\\nvar MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global\\n\\n/*\\nAddition formatting tokens we want recognized\\n*/\\nvar specialTokens = {\\n\\tt: function(date) { // \\\"a\\\" or \\\"p\\\"\\n\\t\\treturn oldMomentFormat(date, 'a').charAt(0);\\n\\t},\\n\\tT: function(date) { // \\\"A\\\" or \\\"P\\\"\\n\\t\\treturn oldMomentFormat(date, 'A').charAt(0);\\n\\t}\\n};\\n\\n/*\\nThe first characters of formatting tokens for units that are 1 day or larger.\\n`value` is for ranking relative size (lower means bigger).\\n`unit` is a normalized unit, used for comparing moments.\\n*/\\nvar largeTokenMap = {\\n\\tY: { value: 1, unit: 'year' },\\n\\tM: { value: 2, unit: 'month' },\\n\\tW: { value: 3, unit: 'week' }, // ISO week\\n\\tw: { value: 3, unit: 'week' }, // local week\\n\\tD: { value: 4, unit: 'day' }, // day of month\\n\\td: { value: 4, unit: 'day' } // day of week\\n};\\n\\n\\n// Single Date Formatting\\n// ---------------------------------------------------------------------------------------------------------------------\\n\\n/*\\nFormats `date` with a Moment formatting string, but allow our non-zero areas and special token\\n*/\\nfunction formatDate(date, formatStr) {\\n\\treturn renderFakeFormatString(\\n\\t\\tgetParsedFormatString(formatStr).fakeFormatString,\\n\\t\\tdate\\n\\t);\\n}\\n\\n/*\\nCall this if you want Moment's original format method to be used\\n*/\\nfunction oldMomentFormat(mom, formatStr) {\\n\\treturn oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\\n}\\n\\n\\n// Date Range Formatting\\n// -------------------------------------------------------------------------------------------------\\n// TODO: make it work with timezone offset\\n\\n/*\\nUsing a formatting string meant for a single date, generate a range string, like\\n\\\"Sep 2 - 9 2013\\\", that intelligently inserts a separator where the dates differ.\\nIf the dates are the same as far as the format string is concerned, just return a single\\nrendering of one date, without any separator.\\n*/\\nfunction formatRange(date1, date2, formatStr, separator, isRTL) {\\n\\tvar localeData;\\n\\n\\tdate1 = FC.moment.parseZone(date1);\\n\\tdate2 = FC.moment.parseZone(date2);\\n\\n\\tlocaleData = date1.localeData();\\n\\n\\t// Expand localized format strings, like \\\"LL\\\" -> \\\"MMMM D YYYY\\\".\\n\\t// BTW, this is not important for `formatDate` because it is impossible to put custom tokens\\n\\t// or non-zero areas in Moment's localized format strings.\\n\\tformatStr = localeData.longDateFormat(formatStr) || formatStr;\\n\\n\\treturn renderParsedFormat(\\n\\t\\tgetParsedFormatString(formatStr),\\n\\t\\tdate1,\\n\\t\\tdate2,\\n\\t\\tseparator || ' - ',\\n\\t\\tisRTL\\n\\t);\\n}\\n\\n/*\\nRenders a range with an already-parsed format string.\\n*/\\nfunction renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {\\n\\tvar sameUnits = parsedFormat.sameUnits;\\n\\tvar unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons\\n\\tvar unzonedDate2 = date2.clone().stripZone(); // \\\"\\n\\n\\tvar renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);\\n\\tvar renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);\\n\\n\\tvar leftI;\\n\\tvar leftStr = '';\\n\\tvar rightI;\\n\\tvar rightStr = '';\\n\\tvar middleI;\\n\\tvar middleStr1 = '';\\n\\tvar middleStr2 = '';\\n\\tvar middleStr = '';\\n\\n\\t// Start at the leftmost side of the formatting string and continue until you hit a token\\n\\t// that is not the same between dates.\\n\\tfor (\\n\\t\\tleftI = 0;\\n\\t\\tleftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));\\n\\t\\tleftI++\\n\\t) {\\n\\t\\tleftStr += renderedParts1[leftI];\\n\\t}\\n\\n\\t// Similarly, start at the rightmost side of the formatting string and move left\\n\\tfor (\\n\\t\\trightI = sameUnits.length - 1;\\n\\t\\trightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));\\n\\t\\trightI--\\n\\t) {\\n\\t\\t// If current chunk is on the boundary of unique date-content, and is a special-case\\n\\t\\t// date-formatting postfix character, then don't consume it. Consider it unique date-content.\\n\\t\\t// TODO: make configurable\\n\\t\\tif (rightI - 1 === leftI && renderedParts1[rightI] === '.') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\trightStr = renderedParts1[rightI] + rightStr;\\n\\t}\\n\\n\\t// The area in the middle is different for both of the dates.\\n\\t// Collect them distinctly so we can jam them together later.\\n\\tfor (middleI = leftI; middleI <= rightI; middleI++) {\\n\\t\\tmiddleStr1 += renderedParts1[middleI];\\n\\t\\tmiddleStr2 += renderedParts2[middleI];\\n\\t}\\n\\n\\tif (middleStr1 || middleStr2) {\\n\\t\\tif (isRTL) {\\n\\t\\t\\tmiddleStr = middleStr2 + separator + middleStr1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmiddleStr = middleStr1 + separator + middleStr2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn processMaybeMarkers(\\n\\t\\tleftStr + middleStr + rightStr\\n\\t);\\n}\\n\\n\\n// Format String Parsing\\n// ---------------------------------------------------------------------------------------------------------------------\\n\\nvar parsedFormatStrCache = {};\\n\\n/*\\nReturns a parsed format string, leveraging a cache.\\n*/\\nfunction getParsedFormatString(formatStr) {\\n\\treturn parsedFormatStrCache[formatStr] ||\\n\\t\\t(parsedFormatStrCache[formatStr] = parseFormatString(formatStr));\\n}\\n\\n/*\\nParses a format string into the following:\\n- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.\\n- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like \\\"day\\\"),\\n  that indicates how similar a range's start & end must be in order to share the same formatted text.\\n  If not a token, then the value is null.\\n  Always a flat array (not nested liked \\\"chunks\\\").\\n*/\\nfunction parseFormatString(formatStr) {\\n\\tvar chunks = chunkFormatString(formatStr);\\n\\t\\n\\treturn {\\n\\t\\tfakeFormatString: buildFakeFormatString(chunks),\\n\\t\\tsameUnits: buildSameUnits(chunks)\\n\\t};\\n}\\n\\n/*\\nBreak the formatting string into an array of chunks.\\nA 'maybe' chunk will have nested chunks.\\n*/\\nfunction chunkFormatString(formatStr) {\\n\\tvar chunks = [];\\n\\tvar match;\\n\\n\\t// TODO: more descrimination\\n\\t// \\\\4 is a backreference to the first character of a multi-character set.\\n\\tvar chunker = /\\\\[([^\\\\]]*)\\\\]|\\\\(([^\\\\)]*)\\\\)|(LTS|LT|(\\\\w)\\\\4*o?)|([^\\\\w\\\\[\\\\(]+)/g;\\n\\n\\twhile ((match = chunker.exec(formatStr))) {\\n\\t\\tif (match[1]) { // a literal string inside [ ... ]\\n\\t\\t\\tchunks.push.apply(chunks, // append\\n\\t\\t\\t\\tsplitStringLiteral(match[1])\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\telse if (match[2]) { // non-zero formatting inside ( ... )\\n\\t\\t\\tchunks.push({ maybe: chunkFormatString(match[2]) });\\n\\t\\t}\\n\\t\\telse if (match[3]) { // a formatting token\\n\\t\\t\\tchunks.push({ token: match[3] });\\n\\t\\t}\\n\\t\\telse if (match[5]) { // an unenclosed literal string\\n\\t\\t\\tchunks.push.apply(chunks, // append\\n\\t\\t\\t\\tsplitStringLiteral(match[5])\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\treturn chunks;\\n}\\n\\n/*\\nPotentially splits a literal-text string into multiple parts. For special cases.\\n*/\\nfunction splitStringLiteral(s) {\\n\\tif (s === '. ') {\\n\\t\\treturn [ '.', ' ' ]; // for locales with periods bound to the end of each year/month/date\\n\\t}\\n\\telse {\\n\\t\\treturn [ s ];\\n\\t}\\n}\\n\\n/*\\nGiven chunks parsed from a real format string, generate a fake (aka \\\"intermediate\\\") format string with special control\\ncharacters that will eventually be given to moment for formatting, and then post-processed.\\n*/\\nfunction buildFakeFormatString(chunks) {\\n\\tvar parts = [];\\n\\tvar i, chunk;\\n\\n\\tfor (i = 0; i < chunks.length; i++) {\\n\\t\\tchunk = chunks[i];\\n\\n\\t\\tif (typeof chunk === 'string') {\\n\\t\\t\\tparts.push('[' + chunk + ']');\\n\\t\\t}\\n\\t\\telse if (chunk.token) {\\n\\t\\t\\tif (chunk.token in specialTokens) {\\n\\t\\t\\t\\tparts.push(\\n\\t\\t\\t\\t\\tSPECIAL_TOKEN_MARKER + // useful during post-processing\\n\\t\\t\\t\\t\\t'[' + chunk.token + ']' // preserve as literal text\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tparts.push(chunk.token); // unprotected text implies a format string\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (chunk.maybe) {\\n\\t\\t\\tparts.push(\\n\\t\\t\\t\\tMAYBE_MARKER + // useful during post-processing\\n\\t\\t\\t\\tbuildFakeFormatString(chunk.maybe) +\\n\\t\\t\\t\\tMAYBE_MARKER\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\treturn parts.join(PART_SEPARATOR);\\n}\\n\\n/*\\nGiven parsed chunks from a real formatting string, generates an array of unit strings (like \\\"day\\\") that indicate\\nin which regard two dates must be similar in order to share range formatting text.\\nThe `chunks` can be nested (because of \\\"maybe\\\" chunks), however, the returned array will be flat.\\n*/\\nfunction buildSameUnits(chunks) {\\n\\tvar units = [];\\n\\tvar i, chunk;\\n\\tvar tokenInfo;\\n\\n\\tfor (i = 0; i < chunks.length; i++) {\\n\\t\\tchunk = chunks[i];\\n\\n\\t\\tif (chunk.token) {\\n\\t\\t\\ttokenInfo = largeTokenMap[chunk.token.charAt(0)];\\n\\t\\t\\tunits.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second\\n\\t\\t}\\n\\t\\telse if (chunk.maybe) {\\n\\t\\t\\tunits.push.apply(units, // append\\n\\t\\t\\t\\tbuildSameUnits(chunk.maybe)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tunits.push(null);\\n\\t\\t}\\n\\t}\\n\\n\\treturn units;\\n}\\n\\n\\n// Rendering to text\\n// ---------------------------------------------------------------------------------------------------------------------\\n\\n/*\\nFormats a date with a fake format string, post-processes the control characters, then returns.\\n*/\\nfunction renderFakeFormatString(fakeFormatString, date) {\\n\\treturn processMaybeMarkers(\\n\\t\\trenderFakeFormatStringParts(fakeFormatString, date).join('')\\n\\t);\\n}\\n\\n/*\\nFormats a date into parts that will have been post-processed, EXCEPT for the \\\"maybe\\\" markers.\\n*/\\nfunction renderFakeFormatStringParts(fakeFormatString, date) {\\n\\tvar parts = [];\\n\\tvar fakeRender = oldMomentFormat(date, fakeFormatString);\\n\\tvar fakeParts = fakeRender.split(PART_SEPARATOR);\\n\\tvar i, fakePart;\\n\\n\\tfor (i = 0; i < fakeParts.length; i++) {\\n\\t\\tfakePart = fakeParts[i];\\n\\n\\t\\tif (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {\\n\\t\\t\\tparts.push(\\n\\t\\t\\t\\t// the literal string IS the token's name.\\n\\t\\t\\t\\t// call special token's registered function.\\n\\t\\t\\t\\tspecialTokens[fakePart.substring(1)](date)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparts.push(fakePart);\\n\\t\\t}\\n\\t}\\n\\n\\treturn parts;\\n}\\n\\n/*\\nAccepts an almost-finally-formatted string and processes the \\\"maybe\\\" control characters, returning a new string.\\n*/\\nfunction processMaybeMarkers(s) {\\n\\treturn s.replace(MAYBE_REGEXP, function(m0, m1) { // regex assumed to have 'g' flag\\n\\t\\tif (m1.match(/[1-9]/)) { // any non-zero numeric characters?\\n\\t\\t\\treturn m1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\t});\\n}\\n\\n\\n// Misc Utils\\n// -------------------------------------------------------------------------------------------------\\n\\n/*\\nReturns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.\\n*/\\nfunction queryMostGranularFormatUnit(formatStr) {\\n\\tvar chunks = chunkFormatString(formatStr);\\n\\tvar i, chunk;\\n\\tvar candidate;\\n\\tvar best;\\n\\n\\tfor (i = 0; i < chunks.length; i++) {\\n\\t\\tchunk = chunks[i];\\n\\n\\t\\tif (chunk.token) {\\n\\t\\t\\tcandidate = largeTokenMap[chunk.token.charAt(0)];\\n\\t\\t\\tif (candidate) {\\n\\t\\t\\t\\tif (!best || candidate.value > best.value) {\\n\\t\\t\\t\\t\\tbest = candidate;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (best) {\\n\\t\\treturn best.unit;\\n\\t}\\n\\n\\treturn null;\\n};\\n\\n})();\\n\\n// quick local references\\nvar formatDate = FC.formatDate;\\nvar formatRange = FC.formatRange;\\nvar oldMomentFormat = FC.oldMomentFormat;\\n\\n;;\\n\\nFC.Class = Class; // export\\n\\n// Class that all other classes will inherit from\\nfunction Class() { }\\n\\n\\n// Called on a class to create a subclass.\\n// Last argument contains instance methods. Any argument before the last are considered mixins.\\nClass.extend = function() {\\n\\tvar len = arguments.length;\\n\\tvar i;\\n\\tvar members;\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tmembers = arguments[i];\\n\\t\\tif (i < len - 1) { // not the last argument?\\n\\t\\t\\tmixIntoClass(this, members);\\n\\t\\t}\\n\\t}\\n\\n\\treturn extendClass(this, members || {}); // members will be undefined if no arguments\\n};\\n\\n\\n// Adds new member variables/methods to the class's prototype.\\n// Can be called with another class, or a plain object hash containing new members.\\nClass.mixin = function(members) {\\n\\tmixIntoClass(this, members);\\n};\\n\\n\\nfunction extendClass(superClass, members) {\\n\\tvar subClass;\\n\\n\\t// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist\\n\\tif (hasOwnProp(members, 'constructor')) {\\n\\t\\tsubClass = members.constructor;\\n\\t}\\n\\tif (typeof subClass !== 'function') {\\n\\t\\tsubClass = members.constructor = function() {\\n\\t\\t\\tsuperClass.apply(this, arguments);\\n\\t\\t};\\n\\t}\\n\\n\\t// build the base prototype for the subclass, which is an new object chained to the superclass's prototype\\n\\tsubClass.prototype = createObject(superClass.prototype);\\n\\n\\t// copy each member variable/method onto the the subclass's prototype\\n\\tcopyOwnProps(members, subClass.prototype);\\n\\n\\t// copy over all class variables/methods to the subclass, such as `extend` and `mixin`\\n\\tcopyOwnProps(superClass, subClass);\\n\\n\\treturn subClass;\\n}\\n\\n\\nfunction mixIntoClass(theClass, members) {\\n\\tcopyOwnProps(members, theClass.prototype);\\n}\\n;;\\n\\nvar Model = Class.extend(EmitterMixin, ListenerMixin, {\\n\\n\\t_props: null,\\n\\t_watchers: null,\\n\\t_globalWatchArgs: null,\\n\\n\\tconstructor: function() {\\n\\t\\tthis._watchers = {};\\n\\t\\tthis._props = {};\\n\\t\\tthis.applyGlobalWatchers();\\n\\t},\\n\\n\\tapplyGlobalWatchers: function() {\\n\\t\\tvar argSets = this._globalWatchArgs || [];\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < argSets.length; i++) {\\n\\t\\t\\tthis.watch.apply(this, argSets[i]);\\n\\t\\t}\\n\\t},\\n\\n\\thas: function(name) {\\n\\t\\treturn name in this._props;\\n\\t},\\n\\n\\tget: function(name) {\\n\\t\\tif (name === undefined) {\\n\\t\\t\\treturn this._props;\\n\\t\\t}\\n\\n\\t\\treturn this._props[name];\\n\\t},\\n\\n\\tset: function(name, val) {\\n\\t\\tvar newProps;\\n\\n\\t\\tif (typeof name === 'string') {\\n\\t\\t\\tnewProps = {};\\n\\t\\t\\tnewProps[name] = val === undefined ? null : val;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnewProps = name;\\n\\t\\t}\\n\\n\\t\\tthis.setProps(newProps);\\n\\t},\\n\\n\\treset: function(newProps) {\\n\\t\\tvar oldProps = this._props;\\n\\t\\tvar changeset = {}; // will have undefined's to signal unsets\\n\\t\\tvar name;\\n\\n\\t\\tfor (name in oldProps) {\\n\\t\\t\\tchangeset[name] = undefined;\\n\\t\\t}\\n\\n\\t\\tfor (name in newProps) {\\n\\t\\t\\tchangeset[name] = newProps[name];\\n\\t\\t}\\n\\n\\t\\tthis.setProps(changeset);\\n\\t},\\n\\n\\tunset: function(name) { // accepts a string or array of strings\\n\\t\\tvar newProps = {};\\n\\t\\tvar names;\\n\\t\\tvar i;\\n\\n\\t\\tif (typeof name === 'string') {\\n\\t\\t\\tnames = [ name ];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnames = name;\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < names.length; i++) {\\n\\t\\t\\tnewProps[names[i]] = undefined;\\n\\t\\t}\\n\\n\\t\\tthis.setProps(newProps);\\n\\t},\\n\\n\\tsetProps: function(newProps) {\\n\\t\\tvar changedProps = {};\\n\\t\\tvar changedCnt = 0;\\n\\t\\tvar name, val;\\n\\n\\t\\tfor (name in newProps) {\\n\\t\\t\\tval = newProps[name];\\n\\n\\t\\t\\t// a change in value?\\n\\t\\t\\t// if an object, don't check equality, because might have been mutated internally.\\n\\t\\t\\t// TODO: eventually enforce immutability.\\n\\t\\t\\tif (\\n\\t\\t\\t\\ttypeof val === 'object' ||\\n\\t\\t\\t\\tval !== this._props[name]\\n\\t\\t\\t) {\\n\\t\\t\\t\\tchangedProps[name] = val;\\n\\t\\t\\t\\tchangedCnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (changedCnt) {\\n\\n\\t\\t\\tthis.trigger('before:batchChange', changedProps);\\n\\n\\t\\t\\tfor (name in changedProps) {\\n\\t\\t\\t\\tval = changedProps[name];\\n\\n\\t\\t\\t\\tthis.trigger('before:change', name, val);\\n\\t\\t\\t\\tthis.trigger('before:change:' + name, val);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (name in changedProps) {\\n\\t\\t\\t\\tval = changedProps[name];\\n\\n\\t\\t\\t\\tif (val === undefined) {\\n\\t\\t\\t\\t\\tdelete this._props[name];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tthis._props[name] = val;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.trigger('change:' + name, val);\\n\\t\\t\\t\\tthis.trigger('change', name, val);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.trigger('batchChange', changedProps);\\n\\t\\t}\\n\\t},\\n\\n\\twatch: function(name, depList, startFunc, stopFunc) {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.unwatch(name);\\n\\n\\t\\tthis._watchers[name] = this._watchDeps(depList, function(deps) {\\n\\t\\t\\tvar res = startFunc.call(_this, deps);\\n\\n\\t\\t\\tif (res && res.then) {\\n\\t\\t\\t\\t_this.unset(name); // put in an unset state while resolving\\n\\t\\t\\t\\tres.then(function(val) {\\n\\t\\t\\t\\t\\t_this.set(name, val);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t_this.set(name, res);\\n\\t\\t\\t}\\n\\t\\t}, function() {\\n\\t\\t\\t_this.unset(name);\\n\\n\\t\\t\\tif (stopFunc) {\\n\\t\\t\\t\\tstopFunc.call(_this);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\tunwatch: function(name) {\\n\\t\\tvar watcher = this._watchers[name];\\n\\n\\t\\tif (watcher) {\\n\\t\\t\\tdelete this._watchers[name];\\n\\t\\t\\twatcher.teardown();\\n\\t\\t}\\n\\t},\\n\\n\\t_watchDeps: function(depList, startFunc, stopFunc) {\\n\\t\\tvar _this = this;\\n\\t\\tvar queuedChangeCnt = 0;\\n\\t\\tvar depCnt = depList.length;\\n\\t\\tvar satisfyCnt = 0;\\n\\t\\tvar values = {}; // what's passed as the `deps` arguments\\n\\t\\tvar bindTuples = []; // array of [ eventName, handlerFunc ] arrays\\n\\t\\tvar isCallingStop = false;\\n\\n\\t\\tfunction onBeforeDepChange(depName, val, isOptional) {\\n\\t\\t\\tqueuedChangeCnt++;\\n\\t\\t\\tif (queuedChangeCnt === 1) { // first change to cause a \\\"stop\\\" ?\\n\\t\\t\\t\\tif (satisfyCnt === depCnt) { // all deps previously satisfied?\\n\\t\\t\\t\\t\\tisCallingStop = true;\\n\\t\\t\\t\\t\\tstopFunc();\\n\\t\\t\\t\\t\\tisCallingStop = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction onDepChange(depName, val, isOptional) {\\n\\n\\t\\t\\tif (val === undefined) { // unsetting a value?\\n\\n\\t\\t\\t\\t// required dependency that was previously set?\\n\\t\\t\\t\\tif (!isOptional && values[depName] !== undefined) {\\n\\t\\t\\t\\t\\tsatisfyCnt--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete values[depName];\\n\\t\\t\\t}\\n\\t\\t\\telse { // setting a value?\\n\\n\\t\\t\\t\\t// required dependency that was previously unset?\\n\\t\\t\\t\\tif (!isOptional && values[depName] === undefined) {\\n\\t\\t\\t\\t\\tsatisfyCnt++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvalues[depName] = val;\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueuedChangeCnt--;\\n\\t\\t\\tif (!queuedChangeCnt) { // last change to cause a \\\"start\\\"?\\n\\n\\t\\t\\t\\t// now finally satisfied or satisfied all along?\\n\\t\\t\\t\\tif (satisfyCnt === depCnt) {\\n\\n\\t\\t\\t\\t\\t// if the stopFunc initiated another value change, ignore it.\\n\\t\\t\\t\\t\\t// it will be processed by another change event anyway.\\n\\t\\t\\t\\t\\tif (!isCallingStop) {\\n\\t\\t\\t\\t\\t\\tstartFunc(values);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// intercept for .on() that remembers handlers\\n\\t\\tfunction bind(eventName, handler) {\\n\\t\\t\\t_this.on(eventName, handler);\\n\\t\\t\\tbindTuples.push([ eventName, handler ]);\\n\\t\\t}\\n\\n\\t\\t// listen to dependency changes\\n\\t\\tdepList.forEach(function(depName) {\\n\\t\\t\\tvar isOptional = false;\\n\\n\\t\\t\\tif (depName.charAt(0) === '?') { // TODO: more DRY\\n\\t\\t\\t\\tdepName = depName.substring(1);\\n\\t\\t\\t\\tisOptional = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbind('before:change:' + depName, function(val) {\\n\\t\\t\\t\\tonBeforeDepChange(depName, val, isOptional);\\n\\t\\t\\t});\\n\\n\\t\\t\\tbind('change:' + depName, function(val) {\\n\\t\\t\\t\\tonDepChange(depName, val, isOptional);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\t// process current dependency values\\n\\t\\tdepList.forEach(function(depName) {\\n\\t\\t\\tvar isOptional = false;\\n\\n\\t\\t\\tif (depName.charAt(0) === '?') { // TODO: more DRY\\n\\t\\t\\t\\tdepName = depName.substring(1);\\n\\t\\t\\t\\tisOptional = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (_this.has(depName)) {\\n\\t\\t\\t\\tvalues[depName] = _this.get(depName);\\n\\t\\t\\t\\tsatisfyCnt++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (isOptional) {\\n\\t\\t\\t\\tsatisfyCnt++;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// initially satisfied\\n\\t\\tif (satisfyCnt === depCnt) {\\n\\t\\t\\tstartFunc(values);\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\t// remove all handlers\\n\\t\\t\\t\\tfor (var i = 0; i < bindTuples.length; i++) {\\n\\t\\t\\t\\t\\t_this.off(bindTuples[i][0], bindTuples[i][1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbindTuples = null;\\n\\n\\t\\t\\t\\t// was satisfied, so call stopFunc\\n\\t\\t\\t\\tif (satisfyCnt === depCnt) {\\n\\t\\t\\t\\t\\tstopFunc();\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tflash: function() {\\n\\t\\t\\t\\tif (satisfyCnt === depCnt) {\\n\\t\\t\\t\\t\\tstopFunc();\\n\\t\\t\\t\\t\\tstartFunc(values);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t},\\n\\n\\tflash: function(name) {\\n\\t\\tvar watcher = this._watchers[name];\\n\\n\\t\\tif (watcher) {\\n\\t\\t\\twatcher.flash();\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n\\nModel.watch = function(/* same arguments as this.watch() */) {\\n\\tvar proto = this.prototype;\\n\\n\\tif (!proto._globalWatchArgs) {\\n\\t\\tproto._globalWatchArgs = [];\\n\\t}\\n\\n\\tproto._globalWatchArgs.push(arguments);\\n};\\n\\n\\nFC.Model = Model;\\n\\n\\n;;\\n\\nvar Promise = {\\n\\n\\tconstruct: function(executor) {\\n\\t\\tvar deferred = $.Deferred();\\n\\t\\tvar promise = deferred.promise();\\n\\n\\t\\tif (typeof executor === 'function') {\\n\\t\\t\\texecutor(\\n\\t\\t\\t\\tfunction(val) { // resolve\\n\\t\\t\\t\\t\\tdeferred.resolve(val);\\n\\t\\t\\t\\t\\tattachImmediatelyResolvingThen(promise, val);\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tfunction() { // reject\\n\\t\\t\\t\\t\\tdeferred.reject();\\n\\t\\t\\t\\t\\tattachImmediatelyRejectingThen(promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn promise;\\n\\t},\\n\\n\\tresolve: function(val) {\\n\\t\\tvar deferred = $.Deferred().resolve(val);\\n\\t\\tvar promise = deferred.promise();\\n\\n\\t\\tattachImmediatelyResolvingThen(promise, val);\\n\\n\\t\\treturn promise;\\n\\t},\\n\\n\\treject: function() {\\n\\t\\tvar deferred = $.Deferred().reject();\\n\\t\\tvar promise = deferred.promise();\\n\\n\\t\\tattachImmediatelyRejectingThen(promise);\\n\\n\\t\\treturn promise;\\n\\t}\\n\\n};\\n\\n\\nfunction attachImmediatelyResolvingThen(promise, val) {\\n\\tpromise.then = function(onResolve) {\\n\\t\\tif (typeof onResolve === 'function') {\\n\\t\\t\\tonResolve(val);\\n\\t\\t}\\n\\t\\treturn promise; // for chaining\\n\\t};\\n}\\n\\n\\nfunction attachImmediatelyRejectingThen(promise) {\\n\\tpromise.then = function(onResolve, onReject) {\\n\\t\\tif (typeof onReject === 'function') {\\n\\t\\t\\tonReject();\\n\\t\\t}\\n\\t\\treturn promise; // for chaining\\n\\t};\\n}\\n\\n\\nFC.Promise = Promise;\\n\\n;;\\n\\nvar TaskQueue = Class.extend(EmitterMixin, {\\n\\n\\tq: null,\\n\\tisPaused: false,\\n\\tisRunning: false,\\n\\n\\n\\tconstructor: function() {\\n\\t\\tthis.q = [];\\n\\t},\\n\\n\\n\\tqueue: function(/* taskFunc, taskFunc... */) {\\n\\t\\tthis.q.push.apply(this.q, arguments); // append\\n\\t\\tthis.tryStart();\\n\\t},\\n\\n\\n\\tpause: function() {\\n\\t\\tthis.isPaused = true;\\n\\t},\\n\\n\\n\\tresume: function() {\\n\\t\\tthis.isPaused = false;\\n\\t\\tthis.tryStart();\\n\\t},\\n\\n\\n\\ttryStart: function() {\\n\\t\\tif (!this.isRunning && this.canRunNext()) {\\n\\t\\t\\tthis.isRunning = true;\\n\\t\\t\\tthis.trigger('start');\\n\\t\\t\\tthis.runNext();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tcanRunNext: function() {\\n\\t\\treturn !this.isPaused && this.q.length;\\n\\t},\\n\\n\\n\\trunNext: function() { // does not check canRunNext\\n\\t\\tthis.runTask(this.q.shift());\\n\\t},\\n\\n\\n\\trunTask: function(task) {\\n\\t\\tthis.runTaskFunc(task);\\n\\t},\\n\\n\\n\\trunTaskFunc: function(taskFunc) {\\n\\t\\tvar _this = this;\\n\\t\\tvar res = taskFunc();\\n\\n\\t\\tif (res && res.then) {\\n\\t\\t\\tres.then(done);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdone();\\n\\t\\t}\\n\\n\\t\\tfunction done() {\\n\\t\\t\\tif (_this.canRunNext()) {\\n\\t\\t\\t\\t_this.runNext();\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t_this.isRunning = false;\\n\\t\\t\\t\\t_this.trigger('stop');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n});\\n\\nFC.TaskQueue = TaskQueue;\\n\\n;;\\n\\nvar RenderQueue = TaskQueue.extend({\\n\\n\\twaitsByNamespace: null,\\n\\twaitNamespace: null,\\n\\twaitId: null,\\n\\n\\n\\tconstructor: function(waitsByNamespace) {\\n\\t\\tTaskQueue.call(this); // super-constructor\\n\\n\\t\\tthis.waitsByNamespace = waitsByNamespace || {};\\n\\t},\\n\\n\\n\\tqueue: function(taskFunc, namespace, type) {\\n\\t\\tvar task = {\\n\\t\\t\\tfunc: taskFunc,\\n\\t\\t\\tnamespace: namespace,\\n\\t\\t\\ttype: type\\n\\t\\t};\\n\\t\\tvar waitMs;\\n\\n\\t\\tif (namespace) {\\n\\t\\t\\twaitMs = this.waitsByNamespace[namespace];\\n\\t\\t}\\n\\n\\t\\tif (this.waitNamespace) {\\n\\t\\t\\tif (namespace === this.waitNamespace && waitMs != null) {\\n\\t\\t\\t\\tthis.delayWait(waitMs);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tthis.clearWait();\\n\\t\\t\\t\\tthis.tryStart();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (this.compoundTask(task)) { // appended to queue?\\n\\n\\t\\t\\tif (!this.waitNamespace && waitMs != null) {\\n\\t\\t\\t\\tthis.startWait(namespace, waitMs);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tthis.tryStart();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\tstartWait: function(namespace, waitMs) {\\n\\t\\tthis.waitNamespace = namespace;\\n\\t\\tthis.spawnWait(waitMs);\\n\\t},\\n\\n\\n\\tdelayWait: function(waitMs) {\\n\\t\\tclearTimeout(this.waitId);\\n\\t\\tthis.spawnWait(waitMs);\\n\\t},\\n\\n\\n\\tspawnWait: function(waitMs) {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.waitId = setTimeout(function() {\\n\\t\\t\\t_this.waitNamespace = null;\\n\\t\\t\\t_this.tryStart();\\n\\t\\t}, waitMs);\\n\\t},\\n\\n\\n\\tclearWait: function() {\\n\\t\\tif (this.waitNamespace) {\\n\\t\\t\\tclearTimeout(this.waitId);\\n\\t\\t\\tthis.waitId = null;\\n\\t\\t\\tthis.waitNamespace = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\tcanRunNext: function() {\\n\\t\\tif (!TaskQueue.prototype.canRunNext.apply(this, arguments)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// waiting for a certain namespace to stop receiving tasks?\\n\\t\\tif (this.waitNamespace) {\\n\\n\\t\\t\\t// if there was a different namespace task in the meantime,\\n\\t\\t\\t// that forces all previously-waiting tasks to suddenly execute.\\n\\t\\t\\t// TODO: find a way to do this in constant time.\\n\\t\\t\\tfor (var q = this.q, i = 0; i < q.length; i++) {\\n\\t\\t\\t\\tif (q[i].namespace !== this.waitNamespace) {\\n\\t\\t\\t\\t\\treturn true; // allow execution\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t},\\n\\n\\n\\trunTask: function(task) {\\n\\t\\tthis.runTaskFunc(task.func);\\n\\t},\\n\\n\\n\\tcompoundTask: function(newTask) {\\n\\t\\tvar q = this.q;\\n\\t\\tvar shouldAppend = true;\\n\\t\\tvar i, task;\\n\\n\\t\\tif (newTask.namespace) {\\n\\n\\t\\t\\tif (newTask.type === 'destroy' || newTask.type === 'init') {\\n\\n\\t\\t\\t\\t// remove all add/remove ops with same namespace, regardless of order\\n\\t\\t\\t\\tfor (i = q.length - 1; i >= 0; i--) {\\n\\t\\t\\t\\t\\ttask = q[i];\\n\\n\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\ttask.namespace === newTask.namespace &&\\n\\t\\t\\t\\t\\t\\t(task.type === 'add' || task.type === 'remove')\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\tq.splice(i, 1); // remove task\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (newTask.type === 'destroy') {\\n\\t\\t\\t\\t\\t// eat away final init/destroy operation\\n\\t\\t\\t\\t\\tif (q.length) {\\n\\t\\t\\t\\t\\t\\ttask = q[q.length - 1]; // last task\\n\\n\\t\\t\\t\\t\\t\\tif (task.namespace === newTask.namespace) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// the init and our destroy cancel each other out\\n\\t\\t\\t\\t\\t\\t\\tif (task.type === 'init') {\\n\\t\\t\\t\\t\\t\\t\\t\\tshouldAppend = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t// prefer to use the destroy operation that's already present\\n\\t\\t\\t\\t\\t\\t\\telse if (task.type === 'destroy') {\\n\\t\\t\\t\\t\\t\\t\\t\\tshouldAppend = false;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (newTask.type === 'init') {\\n\\t\\t\\t\\t\\t// eat away final init operation\\n\\t\\t\\t\\t\\tif (q.length) {\\n\\t\\t\\t\\t\\t\\ttask = q[q.length - 1]; // last task\\n\\n\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\ttask.namespace === newTask.namespace &&\\n\\t\\t\\t\\t\\t\\t\\ttask.type === 'init'\\n\\t\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t\\t// our init operation takes precedence\\n\\t\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (shouldAppend) {\\n\\t\\t\\tq.push(newTask);\\n\\t\\t}\\n\\n\\t\\treturn shouldAppend;\\n\\t}\\n\\n});\\n\\nFC.RenderQueue = RenderQueue;\\n\\n;;\\n\\nvar EmitterMixin = FC.EmitterMixin = {\\n\\n\\t// jQuery-ification via $(this) allows a non-DOM object to have\\n\\t// the same event handling capabilities (including namespaces).\\n\\n\\n\\ton: function(types, handler) {\\n\\t\\t$(this).on(types, this._prepareIntercept(handler));\\n\\t\\treturn this; // for chaining\\n\\t},\\n\\n\\n\\tone: function(types, handler) {\\n\\t\\t$(this).one(types, this._prepareIntercept(handler));\\n\\t\\treturn this; // for chaining\\n\\t},\\n\\n\\n\\t_prepareIntercept: function(handler) {\\n\\t\\t// handlers are always called with an \\\"event\\\" object as their first param.\\n\\t\\t// sneak the `this` context and arguments into the extra parameter object\\n\\t\\t// and forward them on to the original handler.\\n\\t\\tvar intercept = function(ev, extra) {\\n\\t\\t\\treturn handler.apply(\\n\\t\\t\\t\\textra.context || this,\\n\\t\\t\\t\\textra.args || []\\n\\t\\t\\t);\\n\\t\\t};\\n\\n\\t\\t// mimick jQuery's internal \\\"proxy\\\" system (risky, I know)\\n\\t\\t// causing all functions with the same .guid to appear to be the same.\\n\\t\\t// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\\n\\t\\t// this is needed for calling .off with the original non-intercept handler.\\n\\t\\tif (!handler.guid) {\\n\\t\\t\\thandler.guid = $.guid++;\\n\\t\\t}\\n\\t\\tintercept.guid = handler.guid;\\n\\n\\t\\treturn intercept;\\n\\t},\\n\\n\\n\\toff: function(types, handler) {\\n\\t\\t$(this).off(types, handler);\\n\\n\\t\\treturn this; // for chaining\\n\\t},\\n\\n\\n\\ttrigger: function(types) {\\n\\t\\tvar args = Array.prototype.slice.call(arguments, 1); // arguments after the first\\n\\n\\t\\t// pass in \\\"extra\\\" info to the intercept\\n\\t\\t$(this).triggerHandler(types, { args: args });\\n\\n\\t\\treturn this; // for chaining\\n\\t},\\n\\n\\n\\ttriggerWith: function(types, context, args) {\\n\\n\\t\\t// `triggerHandler` is less reliant on the DOM compared to `trigger`.\\n\\t\\t// pass in \\\"extra\\\" info to the intercept.\\n\\t\\t$(this).triggerHandler(types, { context: context, args: args });\\n\\n\\t\\treturn this; // for chaining\\n\\t}\\n\\n};\\n\\n;;\\n\\n/*\\nUtility methods for easily listening to events on another object,\\nand more importantly, easily unlistening from them.\\n*/\\nvar ListenerMixin = FC.ListenerMixin = (function() {\\n\\tvar guid = 0;\\n\\tvar ListenerMixin = {\\n\\n\\t\\tlistenerId: null,\\n\\n\\t\\t/*\\n\\t\\tGiven an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\\n\\t\\tThe `callback` will be called with the `this` context of the object that .listenTo is being called on.\\n\\t\\tCan be called:\\n\\t\\t\\t.listenTo(other, eventName, callback)\\n\\t\\tOR\\n\\t\\t\\t.listenTo(other, {\\n\\t\\t\\t\\teventName1: callback1,\\n\\t\\t\\t\\teventName2: callback2\\n\\t\\t\\t})\\n\\t\\t*/\\n\\t\\tlistenTo: function(other, arg, callback) {\\n\\t\\t\\tif (typeof arg === 'object') { // given dictionary of callbacks\\n\\t\\t\\t\\tfor (var eventName in arg) {\\n\\t\\t\\t\\t\\tif (arg.hasOwnProperty(eventName)) {\\n\\t\\t\\t\\t\\t\\tthis.listenTo(other, eventName, arg[eventName]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (typeof arg === 'string') {\\n\\t\\t\\t\\tother.on(\\n\\t\\t\\t\\t\\targ + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\\n\\t\\t\\t\\t\\t$.proxy(callback, this) // always use `this` context\\n\\t\\t\\t\\t\\t\\t// the usually-undesired jQuery guid behavior doesn't matter,\\n\\t\\t\\t\\t\\t\\t// because we always unbind via namespace\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\tCauses the current object to stop listening to events on the `other` object.\\n\\t\\t`eventName` is optional. If omitted, will stop listening to ALL events on `other`.\\n\\t\\t*/\\n\\t\\tstopListeningTo: function(other, eventName) {\\n\\t\\t\\tother.off((eventName || '') + '.' + this.getListenerNamespace());\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\tReturns a string, unique to this object, to be used for event namespacing\\n\\t\\t*/\\n\\t\\tgetListenerNamespace: function() {\\n\\t\\t\\tif (this.listenerId == null) {\\n\\t\\t\\t\\tthis.listenerId = guid++;\\n\\t\\t\\t}\\n\\t\\t\\treturn '_listener' + this.listenerId;\\n\\t\\t}\\n\\n\\t};\\n\\treturn ListenerMixin;\\n})();\\n;;\\n\\n/* A rectangular panel that is absolutely positioned over other content\\n------------------------------------------------------------------------------------------------------------------------\\nOptions:\\n\\t- className (string)\\n\\t- content (HTML string or jQuery element set)\\n\\t- parentEl\\n\\t- top\\n\\t- left\\n\\t- right (the x coord of where the right edge should be. not a \\\"CSS\\\" right)\\n\\t- autoHide (boolean)\\n\\t- show (callback)\\n\\t- hide (callback)\\n*/\\n\\nvar Popover = Class.extend(ListenerMixin, {\\n\\n\\tisHidden: true,\\n\\toptions: null,\\n\\tel: null, // the container element for the popover. generated by this object\\n\\tmargin: 10, // the space required between the popover and the edges of the scroll container\\n\\n\\n\\tconstructor: function(options) {\\n\\t\\tthis.options = options || {};\\n\\t},\\n\\n\\n\\t// Shows the popover on the specified position. Renders it if not already\\n\\tshow: function() {\\n\\t\\tif (this.isHidden) {\\n\\t\\t\\tif (!this.el) {\\n\\t\\t\\t\\tthis.render();\\n\\t\\t\\t}\\n\\t\\t\\tthis.el.show();\\n\\t\\t\\tthis.position();\\n\\t\\t\\tthis.isHidden = false;\\n\\t\\t\\tthis.trigger('show');\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Hides the popover, through CSS, but does not remove it from the DOM\\n\\thide: function() {\\n\\t\\tif (!this.isHidden) {\\n\\t\\t\\tthis.el.hide();\\n\\t\\t\\tthis.isHidden = true;\\n\\t\\t\\tthis.trigger('hide');\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Creates `this.el` and renders content inside of it\\n\\trender: function() {\\n\\t\\tvar _this = this;\\n\\t\\tvar options = this.options;\\n\\n\\t\\tthis.el = $('<div class=\\\"fc-popover\\\"/>')\\n\\t\\t\\t.addClass(options.className || '')\\n\\t\\t\\t.css({\\n\\t\\t\\t\\t// position initially to the top left to avoid creating scrollbars\\n\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\tleft: 0\\n\\t\\t\\t})\\n\\t\\t\\t.append(options.content)\\n\\t\\t\\t.appendTo(options.parentEl);\\n\\n\\t\\t// when a click happens on anything inside with a 'fc-close' className, hide the popover\\n\\t\\tthis.el.on('click', '.fc-close', function() {\\n\\t\\t\\t_this.hide();\\n\\t\\t});\\n\\n\\t\\tif (options.autoHide) {\\n\\t\\t\\tthis.listenTo($(document), 'mousedown', this.documentMousedown);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Triggered when the user clicks *anywhere* in the document, for the autoHide feature\\n\\tdocumentMousedown: function(ev) {\\n\\t\\t// only hide the popover if the click happened outside the popover\\n\\t\\tif (this.el && !$(ev.target).closest(this.el).length) {\\n\\t\\t\\tthis.hide();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Hides and unregisters any handlers\\n\\tremoveElement: function() {\\n\\t\\tthis.hide();\\n\\n\\t\\tif (this.el) {\\n\\t\\t\\tthis.el.remove();\\n\\t\\t\\tthis.el = null;\\n\\t\\t}\\n\\n\\t\\tthis.stopListeningTo($(document), 'mousedown');\\n\\t},\\n\\n\\n\\t// Positions the popover optimally, using the top/left/right options\\n\\tposition: function() {\\n\\t\\tvar options = this.options;\\n\\t\\tvar origin = this.el.offsetParent().offset();\\n\\t\\tvar width = this.el.outerWidth();\\n\\t\\tvar height = this.el.outerHeight();\\n\\t\\tvar windowEl = $(window);\\n\\t\\tvar viewportEl = getScrollParent(this.el);\\n\\t\\tvar viewportTop;\\n\\t\\tvar viewportLeft;\\n\\t\\tvar viewportOffset;\\n\\t\\tvar top; // the \\\"position\\\" (not \\\"offset\\\") values for the popover\\n\\t\\tvar left; //\\n\\n\\t\\t// compute top and left\\n\\t\\ttop = options.top || 0;\\n\\t\\tif (options.left !== undefined) {\\n\\t\\t\\tleft = options.left;\\n\\t\\t}\\n\\t\\telse if (options.right !== undefined) {\\n\\t\\t\\tleft = options.right - width; // derive the left value from the right value\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tleft = 0;\\n\\t\\t}\\n\\n\\t\\tif (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result\\n\\t\\t\\tviewportEl = windowEl;\\n\\t\\t\\tviewportTop = 0; // the window is always at the top left\\n\\t\\t\\tviewportLeft = 0; // (and .offset() won't work if called here)\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tviewportOffset = viewportEl.offset();\\n\\t\\t\\tviewportTop = viewportOffset.top;\\n\\t\\t\\tviewportLeft = viewportOffset.left;\\n\\t\\t}\\n\\n\\t\\t// if the window is scrolled, it causes the visible area to be further down\\n\\t\\tviewportTop += windowEl.scrollTop();\\n\\t\\tviewportLeft += windowEl.scrollLeft();\\n\\n\\t\\t// constrain to the view port. if constrained by two edges, give precedence to top/left\\n\\t\\tif (options.viewportConstrain !== false) {\\n\\t\\t\\ttop = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\\n\\t\\t\\ttop = Math.max(top, viewportTop + this.margin);\\n\\t\\t\\tleft = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\\n\\t\\t\\tleft = Math.max(left, viewportLeft + this.margin);\\n\\t\\t}\\n\\n\\t\\tthis.el.css({\\n\\t\\t\\ttop: top - origin.top,\\n\\t\\t\\tleft: left - origin.left\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Triggers a callback. Calls a function in the option hash of the same name.\\n\\t// Arguments beyond the first `name` are forwarded on.\\n\\t// TODO: better code reuse for this. Repeat code\\n\\ttrigger: function(name) {\\n\\t\\tif (this.options[name]) {\\n\\t\\t\\tthis.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n;;\\n\\n/*\\nA cache for the left/right/top/bottom/width/height values for one or more elements.\\nWorks with both offset (from topleft document) and position (from offsetParent).\\n\\noptions:\\n- els\\n- isHorizontal\\n- isVertical\\n*/\\nvar CoordCache = FC.CoordCache = Class.extend({\\n\\n\\tels: null, // jQuery set (assumed to be siblings)\\n\\tforcedOffsetParentEl: null, // options can override the natural offsetParent\\n\\torigin: null, // {left,top} position of offsetParent of els\\n\\tboundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null\\n\\tisHorizontal: false, // whether to query for left/right/width\\n\\tisVertical: false, // whether to query for top/bottom/height\\n\\n\\t// arrays of coordinates (offsets from topleft of document)\\n\\tlefts: null,\\n\\trights: null,\\n\\ttops: null,\\n\\tbottoms: null,\\n\\n\\n\\tconstructor: function(options) {\\n\\t\\tthis.els = $(options.els);\\n\\t\\tthis.isHorizontal = options.isHorizontal;\\n\\t\\tthis.isVertical = options.isVertical;\\n\\t\\tthis.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\\n\\t},\\n\\n\\n\\t// Queries the els for coordinates and stores them.\\n\\t// Call this method before using and of the get* methods below.\\n\\tbuild: function() {\\n\\t\\tvar offsetParentEl = this.forcedOffsetParentEl;\\n\\t\\tif (!offsetParentEl && this.els.length > 0) {\\n\\t\\t\\toffsetParentEl = this.els.eq(0).offsetParent();\\n\\t\\t}\\n\\n\\t\\tthis.origin = offsetParentEl ?\\n\\t\\t\\toffsetParentEl.offset() :\\n\\t\\t\\tnull;\\n\\n\\t\\tthis.boundingRect = this.queryBoundingRect();\\n\\n\\t\\tif (this.isHorizontal) {\\n\\t\\t\\tthis.buildElHorizontals();\\n\\t\\t}\\n\\t\\tif (this.isVertical) {\\n\\t\\t\\tthis.buildElVerticals();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Destroys all internal data about coordinates, freeing memory\\n\\tclear: function() {\\n\\t\\tthis.origin = null;\\n\\t\\tthis.boundingRect = null;\\n\\t\\tthis.lefts = null;\\n\\t\\tthis.rights = null;\\n\\t\\tthis.tops = null;\\n\\t\\tthis.bottoms = null;\\n\\t},\\n\\n\\n\\t// When called, if coord caches aren't built, builds them\\n\\tensureBuilt: function() {\\n\\t\\tif (!this.origin) {\\n\\t\\t\\tthis.build();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Populates the left/right internal coordinate arrays\\n\\tbuildElHorizontals: function() {\\n\\t\\tvar lefts = [];\\n\\t\\tvar rights = [];\\n\\n\\t\\tthis.els.each(function(i, node) {\\n\\t\\t\\tvar el = $(node);\\n\\t\\t\\tvar left = el.offset().left;\\n\\t\\t\\tvar width = el.outerWidth();\\n\\n\\t\\t\\tlefts.push(left);\\n\\t\\t\\trights.push(left + width);\\n\\t\\t});\\n\\n\\t\\tthis.lefts = lefts;\\n\\t\\tthis.rights = rights;\\n\\t},\\n\\n\\n\\t// Populates the top/bottom internal coordinate arrays\\n\\tbuildElVerticals: function() {\\n\\t\\tvar tops = [];\\n\\t\\tvar bottoms = [];\\n\\n\\t\\tthis.els.each(function(i, node) {\\n\\t\\t\\tvar el = $(node);\\n\\t\\t\\tvar top = el.offset().top;\\n\\t\\t\\tvar height = el.outerHeight();\\n\\n\\t\\t\\ttops.push(top);\\n\\t\\t\\tbottoms.push(top + height);\\n\\t\\t});\\n\\n\\t\\tthis.tops = tops;\\n\\t\\tthis.bottoms = bottoms;\\n\\t},\\n\\n\\n\\t// Given a left offset (from document left), returns the index of the el that it horizontally intersects.\\n\\t// If no intersection is made, returns undefined.\\n\\tgetHorizontalIndex: function(leftOffset) {\\n\\t\\tthis.ensureBuilt();\\n\\n\\t\\tvar lefts = this.lefts;\\n\\t\\tvar rights = this.rights;\\n\\t\\tvar len = lefts.length;\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\tif (leftOffset >= lefts[i] && leftOffset < rights[i]) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Given a top offset (from document top), returns the index of the el that it vertically intersects.\\n\\t// If no intersection is made, returns undefined.\\n\\tgetVerticalIndex: function(topOffset) {\\n\\t\\tthis.ensureBuilt();\\n\\n\\t\\tvar tops = this.tops;\\n\\t\\tvar bottoms = this.bottoms;\\n\\t\\tvar len = tops.length;\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\tif (topOffset >= tops[i] && topOffset < bottoms[i]) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Gets the left offset (from document left) of the element at the given index\\n\\tgetLeftOffset: function(leftIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.lefts[leftIndex];\\n\\t},\\n\\n\\n\\t// Gets the left position (from offsetParent left) of the element at the given index\\n\\tgetLeftPosition: function(leftIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.lefts[leftIndex] - this.origin.left;\\n\\t},\\n\\n\\n\\t// Gets the right offset (from document left) of the element at the given index.\\n\\t// This value is NOT relative to the document's right edge, like the CSS concept of \\\"right\\\" would be.\\n\\tgetRightOffset: function(leftIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.rights[leftIndex];\\n\\t},\\n\\n\\n\\t// Gets the right position (from offsetParent left) of the element at the given index.\\n\\t// This value is NOT relative to the offsetParent's right edge, like the CSS concept of \\\"right\\\" would be.\\n\\tgetRightPosition: function(leftIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.rights[leftIndex] - this.origin.left;\\n\\t},\\n\\n\\n\\t// Gets the width of the element at the given index\\n\\tgetWidth: function(leftIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.rights[leftIndex] - this.lefts[leftIndex];\\n\\t},\\n\\n\\n\\t// Gets the top offset (from document top) of the element at the given index\\n\\tgetTopOffset: function(topIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.tops[topIndex];\\n\\t},\\n\\n\\n\\t// Gets the top position (from offsetParent top) of the element at the given position\\n\\tgetTopPosition: function(topIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.tops[topIndex] - this.origin.top;\\n\\t},\\n\\n\\t// Gets the bottom offset (from the document top) of the element at the given index.\\n\\t// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \\\"bottom\\\" would be.\\n\\tgetBottomOffset: function(topIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.bottoms[topIndex];\\n\\t},\\n\\n\\n\\t// Gets the bottom position (from the offsetParent top) of the element at the given index.\\n\\t// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \\\"bottom\\\" would be.\\n\\tgetBottomPosition: function(topIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.bottoms[topIndex] - this.origin.top;\\n\\t},\\n\\n\\n\\t// Gets the height of the element at the given index\\n\\tgetHeight: function(topIndex) {\\n\\t\\tthis.ensureBuilt();\\n\\t\\treturn this.bottoms[topIndex] - this.tops[topIndex];\\n\\t},\\n\\n\\n\\t// Bounding Rect\\n\\t// TODO: decouple this from CoordCache\\n\\n\\t// Compute and return what the elements' bounding rectangle is, from the user's perspective.\\n\\t// Right now, only returns a rectangle if constrained by an overflow:scroll element.\\n\\t// Returns null if there are no elements\\n\\tqueryBoundingRect: function() {\\n\\t\\tvar scrollParentEl;\\n\\n\\t\\tif (this.els.length > 0) {\\n\\t\\t\\tscrollParentEl = getScrollParent(this.els.eq(0));\\n\\n\\t\\t\\tif (!scrollParentEl.is(document)) {\\n\\t\\t\\t\\treturn getClientRect(scrollParentEl);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn null;\\n\\t},\\n\\n\\tisPointInBounds: function(leftOffset, topOffset) {\\n\\t\\treturn this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);\\n\\t},\\n\\n\\tisLeftInBounds: function(leftOffset) {\\n\\t\\treturn !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);\\n\\t},\\n\\n\\tisTopInBounds: function(topOffset) {\\n\\t\\treturn !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);\\n\\t}\\n\\n});\\n\\n;;\\n\\n/* Tracks a drag's mouse movement, firing various handlers\\n----------------------------------------------------------------------------------------------------------------------*/\\n// TODO: use Emitter\\n\\nvar DragListener = FC.DragListener = Class.extend(ListenerMixin, {\\n\\n\\toptions: null,\\n\\tsubjectEl: null,\\n\\n\\t// coordinates of the initial mousedown\\n\\toriginX: null,\\n\\toriginY: null,\\n\\n\\t// the wrapping element that scrolls, or MIGHT scroll if there's overflow.\\n\\t// TODO: do this for wrappers that have overflow:hidden as well.\\n\\tscrollEl: null,\\n\\n\\tisInteracting: false,\\n\\tisDistanceSurpassed: false,\\n\\tisDelayEnded: false,\\n\\tisDragging: false,\\n\\tisTouch: false,\\n\\tisGeneric: false, // initiated by 'dragstart' (jqui)\\n\\n\\tdelay: null,\\n\\tdelayTimeoutId: null,\\n\\tminDistance: null,\\n\\n\\tshouldCancelTouchScroll: true,\\n\\tscrollAlwaysKills: false,\\n\\n\\n\\tconstructor: function(options) {\\n\\t\\tthis.options = options || {};\\n\\t},\\n\\n\\n\\t// Interaction (high-level)\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tstartInteraction: function(ev, extraOptions) {\\n\\n\\t\\tif (ev.type === 'mousedown') {\\n\\t\\t\\tif (GlobalEmitter.get().shouldIgnoreMouse()) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse if (!isPrimaryMouseButton(ev)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tev.preventDefault(); // prevents native selection in most browsers\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!this.isInteracting) {\\n\\n\\t\\t\\t// process options\\n\\t\\t\\textraOptions = extraOptions || {};\\n\\t\\t\\tthis.delay = firstDefined(extraOptions.delay, this.options.delay, 0);\\n\\t\\t\\tthis.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);\\n\\t\\t\\tthis.subjectEl = this.options.subjectEl;\\n\\n\\t\\t\\tpreventSelection($('body'));\\n\\n\\t\\t\\tthis.isInteracting = true;\\n\\t\\t\\tthis.isTouch = getEvIsTouch(ev);\\n\\t\\t\\tthis.isGeneric = ev.type === 'dragstart';\\n\\t\\t\\tthis.isDelayEnded = false;\\n\\t\\t\\tthis.isDistanceSurpassed = false;\\n\\n\\t\\t\\tthis.originX = getEvX(ev);\\n\\t\\t\\tthis.originY = getEvY(ev);\\n\\t\\t\\tthis.scrollEl = getScrollParent($(ev.target));\\n\\n\\t\\t\\tthis.bindHandlers();\\n\\t\\t\\tthis.initAutoScroll();\\n\\t\\t\\tthis.handleInteractionStart(ev);\\n\\t\\t\\tthis.startDelay(ev);\\n\\n\\t\\t\\tif (!this.minDistance) {\\n\\t\\t\\t\\tthis.handleDistanceSurpassed(ev);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\thandleInteractionStart: function(ev) {\\n\\t\\tthis.trigger('interactionStart', ev);\\n\\t},\\n\\n\\n\\tendInteraction: function(ev, isCancelled) {\\n\\t\\tif (this.isInteracting) {\\n\\t\\t\\tthis.endDrag(ev);\\n\\n\\t\\t\\tif (this.delayTimeoutId) {\\n\\t\\t\\t\\tclearTimeout(this.delayTimeoutId);\\n\\t\\t\\t\\tthis.delayTimeoutId = null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.destroyAutoScroll();\\n\\t\\t\\tthis.unbindHandlers();\\n\\n\\t\\t\\tthis.isInteracting = false;\\n\\t\\t\\tthis.handleInteractionEnd(ev, isCancelled);\\n\\n\\t\\t\\tallowSelection($('body'));\\n\\t\\t}\\n\\t},\\n\\n\\n\\thandleInteractionEnd: function(ev, isCancelled) {\\n\\t\\tthis.trigger('interactionEnd', ev, isCancelled || false);\\n\\t},\\n\\n\\n\\t// Binding To DOM\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tbindHandlers: function() {\\n\\t\\t// some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,\\n\\t\\t// so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.\\n\\t\\tvar globalEmitter = GlobalEmitter.get();\\n\\n\\t\\tif (this.isGeneric) {\\n\\t\\t\\tthis.listenTo($(document), { // might only work on iOS because of GlobalEmitter's bind :(\\n\\t\\t\\t\\tdrag: this.handleMove,\\n\\t\\t\\t\\tdragstop: this.endInteraction\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\telse if (this.isTouch) {\\n\\t\\t\\tthis.listenTo(globalEmitter, {\\n\\t\\t\\t\\ttouchmove: this.handleTouchMove,\\n\\t\\t\\t\\ttouchend: this.endInteraction,\\n\\t\\t\\t\\tscroll: this.handleTouchScroll\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.listenTo(globalEmitter, {\\n\\t\\t\\t\\tmousemove: this.handleMouseMove,\\n\\t\\t\\t\\tmouseup: this.endInteraction\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tthis.listenTo(globalEmitter, {\\n\\t\\t\\tselectstart: preventDefault, // don't allow selection while dragging\\n\\t\\t\\tcontextmenu: preventDefault // long taps would open menu on Chrome dev tools\\n\\t\\t});\\n\\t},\\n\\n\\n\\tunbindHandlers: function() {\\n\\t\\tthis.stopListeningTo(GlobalEmitter.get());\\n\\t\\tthis.stopListeningTo($(document)); // for isGeneric\\n\\t},\\n\\n\\n\\t// Drag (high-level)\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// extraOptions ignored if drag already started\\n\\tstartDrag: function(ev, extraOptions) {\\n\\t\\tthis.startInteraction(ev, extraOptions); // ensure interaction began\\n\\n\\t\\tif (!this.isDragging) {\\n\\t\\t\\tthis.isDragging = true;\\n\\t\\t\\tthis.handleDragStart(ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\thandleDragStart: function(ev) {\\n\\t\\tthis.trigger('dragStart', ev);\\n\\t},\\n\\n\\n\\thandleMove: function(ev) {\\n\\t\\tvar dx = getEvX(ev) - this.originX;\\n\\t\\tvar dy = getEvY(ev) - this.originY;\\n\\t\\tvar minDistance = this.minDistance;\\n\\t\\tvar distanceSq; // current distance from the origin, squared\\n\\n\\t\\tif (!this.isDistanceSurpassed) {\\n\\t\\t\\tdistanceSq = dx * dx + dy * dy;\\n\\t\\t\\tif (distanceSq >= minDistance * minDistance) { // use pythagorean theorem\\n\\t\\t\\t\\tthis.handleDistanceSurpassed(ev);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (this.isDragging) {\\n\\t\\t\\tthis.handleDrag(dx, dy, ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called while the mouse is being moved and when we know a legitimate drag is taking place\\n\\thandleDrag: function(dx, dy, ev) {\\n\\t\\tthis.trigger('drag', dx, dy, ev);\\n\\t\\tthis.updateAutoScroll(ev); // will possibly cause scrolling\\n\\t},\\n\\n\\n\\tendDrag: function(ev) {\\n\\t\\tif (this.isDragging) {\\n\\t\\t\\tthis.isDragging = false;\\n\\t\\t\\tthis.handleDragEnd(ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\thandleDragEnd: function(ev) {\\n\\t\\tthis.trigger('dragEnd', ev);\\n\\t},\\n\\n\\n\\t// Delay\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tstartDelay: function(initialEv) {\\n\\t\\tvar _this = this;\\n\\n\\t\\tif (this.delay) {\\n\\t\\t\\tthis.delayTimeoutId = setTimeout(function() {\\n\\t\\t\\t\\t_this.handleDelayEnd(initialEv);\\n\\t\\t\\t}, this.delay);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.handleDelayEnd(initialEv);\\n\\t\\t}\\n\\t},\\n\\n\\n\\thandleDelayEnd: function(initialEv) {\\n\\t\\tthis.isDelayEnded = true;\\n\\n\\t\\tif (this.isDistanceSurpassed) {\\n\\t\\t\\tthis.startDrag(initialEv);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Distance\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\thandleDistanceSurpassed: function(ev) {\\n\\t\\tthis.isDistanceSurpassed = true;\\n\\n\\t\\tif (this.isDelayEnded) {\\n\\t\\t\\tthis.startDrag(ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Mouse / Touch\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\thandleTouchMove: function(ev) {\\n\\n\\t\\t// prevent inertia and touchmove-scrolling while dragging\\n\\t\\tif (this.isDragging && this.shouldCancelTouchScroll) {\\n\\t\\t\\tev.preventDefault();\\n\\t\\t}\\n\\n\\t\\tthis.handleMove(ev);\\n\\t},\\n\\n\\n\\thandleMouseMove: function(ev) {\\n\\t\\tthis.handleMove(ev);\\n\\t},\\n\\n\\n\\t// Scrolling (unrelated to auto-scroll)\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\thandleTouchScroll: function(ev) {\\n\\t\\t// if the drag is being initiated by touch, but a scroll happens before\\n\\t\\t// the drag-initiating delay is over, cancel the drag\\n\\t\\tif (!this.isDragging || this.scrollAlwaysKills) {\\n\\t\\t\\tthis.endInteraction(ev, true); // isCancelled=true\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Utils\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Triggers a callback. Calls a function in the option hash of the same name.\\n\\t// Arguments beyond the first `name` are forwarded on.\\n\\ttrigger: function(name) {\\n\\t\\tif (this.options[name]) {\\n\\t\\t\\tthis.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\\n\\t\\t}\\n\\t\\t// makes _methods callable by event name. TODO: kill this\\n\\t\\tif (this['_' + name]) {\\n\\t\\t\\tthis['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));\\n\\t\\t}\\n\\t}\\n\\n\\n});\\n\\n;;\\n/*\\nthis.scrollEl is set in DragListener\\n*/\\nDragListener.mixin({\\n\\n\\tisAutoScroll: false,\\n\\n\\tscrollBounds: null, // { top, bottom, left, right }\\n\\tscrollTopVel: null, // pixels per second\\n\\tscrollLeftVel: null, // pixels per second\\n\\tscrollIntervalId: null, // ID of setTimeout for scrolling animation loop\\n\\n\\t// defaults\\n\\tscrollSensitivity: 30, // pixels from edge for scrolling to start\\n\\tscrollSpeed: 200, // pixels per second, at maximum speed\\n\\tscrollIntervalMs: 50, // millisecond wait between scroll increment\\n\\n\\n\\tinitAutoScroll: function() {\\n\\t\\tvar scrollEl = this.scrollEl;\\n\\n\\t\\tthis.isAutoScroll =\\n\\t\\t\\tthis.options.scroll &&\\n\\t\\t\\tscrollEl &&\\n\\t\\t\\t!scrollEl.is(window) &&\\n\\t\\t\\t!scrollEl.is(document);\\n\\n\\t\\tif (this.isAutoScroll) {\\n\\t\\t\\t// debounce makes sure rapid calls don't happen\\n\\t\\t\\tthis.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));\\n\\t\\t}\\n\\t},\\n\\n\\n\\tdestroyAutoScroll: function() {\\n\\t\\tthis.endAutoScroll(); // kill any animation loop\\n\\n\\t\\t// remove the scroll handler if there is a scrollEl\\n\\t\\tif (this.isAutoScroll) {\\n\\t\\t\\tthis.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Computes and stores the bounding rectangle of scrollEl\\n\\tcomputeScrollBounds: function() {\\n\\t\\tif (this.isAutoScroll) {\\n\\t\\t\\tthis.scrollBounds = getOuterRect(this.scrollEl);\\n\\t\\t\\t// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called when the dragging is in progress and scrolling should be updated\\n\\tupdateAutoScroll: function(ev) {\\n\\t\\tvar sensitivity = this.scrollSensitivity;\\n\\t\\tvar bounds = this.scrollBounds;\\n\\t\\tvar topCloseness, bottomCloseness;\\n\\t\\tvar leftCloseness, rightCloseness;\\n\\t\\tvar topVel = 0;\\n\\t\\tvar leftVel = 0;\\n\\n\\t\\tif (bounds) { // only scroll if scrollEl exists\\n\\n\\t\\t\\t// compute closeness to edges. valid range is from 0.0 - 1.0\\n\\t\\t\\ttopCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;\\n\\t\\t\\tbottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;\\n\\t\\t\\tleftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;\\n\\t\\t\\trightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;\\n\\n\\t\\t\\t// translate vertical closeness into velocity.\\n\\t\\t\\t// mouse must be completely in bounds for velocity to happen.\\n\\t\\t\\tif (topCloseness >= 0 && topCloseness <= 1) {\\n\\t\\t\\t\\ttopVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\\n\\t\\t\\t}\\n\\t\\t\\telse if (bottomCloseness >= 0 && bottomCloseness <= 1) {\\n\\t\\t\\t\\ttopVel = bottomCloseness * this.scrollSpeed;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// translate horizontal closeness into velocity\\n\\t\\t\\tif (leftCloseness >= 0 && leftCloseness <= 1) {\\n\\t\\t\\t\\tleftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\\n\\t\\t\\t}\\n\\t\\t\\telse if (rightCloseness >= 0 && rightCloseness <= 1) {\\n\\t\\t\\t\\tleftVel = rightCloseness * this.scrollSpeed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.setScrollVel(topVel, leftVel);\\n\\t},\\n\\n\\n\\t// Sets the speed-of-scrolling for the scrollEl\\n\\tsetScrollVel: function(topVel, leftVel) {\\n\\n\\t\\tthis.scrollTopVel = topVel;\\n\\t\\tthis.scrollLeftVel = leftVel;\\n\\n\\t\\tthis.constrainScrollVel(); // massages into realistic values\\n\\n\\t\\t// if there is non-zero velocity, and an animation loop hasn't already started, then START\\n\\t\\tif ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\\n\\t\\t\\tthis.scrollIntervalId = setInterval(\\n\\t\\t\\t\\tproxy(this, 'scrollIntervalFunc'), // scope to `this`\\n\\t\\t\\t\\tthis.scrollIntervalMs\\n\\t\\t\\t);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\\n\\tconstrainScrollVel: function() {\\n\\t\\tvar el = this.scrollEl;\\n\\n\\t\\tif (this.scrollTopVel < 0) { // scrolling up?\\n\\t\\t\\tif (el.scrollTop() <= 0) { // already scrolled all the way up?\\n\\t\\t\\t\\tthis.scrollTopVel = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (this.scrollTopVel > 0) { // scrolling down?\\n\\t\\t\\tif (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?\\n\\t\\t\\t\\tthis.scrollTopVel = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (this.scrollLeftVel < 0) { // scrolling left?\\n\\t\\t\\tif (el.scrollLeft() <= 0) { // already scrolled all the left?\\n\\t\\t\\t\\tthis.scrollLeftVel = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (this.scrollLeftVel > 0) { // scrolling right?\\n\\t\\t\\tif (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?\\n\\t\\t\\t\\tthis.scrollLeftVel = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// This function gets called during every iteration of the scrolling animation loop\\n\\tscrollIntervalFunc: function() {\\n\\t\\tvar el = this.scrollEl;\\n\\t\\tvar frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\\n\\n\\t\\t// change the value of scrollEl's scroll\\n\\t\\tif (this.scrollTopVel) {\\n\\t\\t\\tel.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\\n\\t\\t}\\n\\t\\tif (this.scrollLeftVel) {\\n\\t\\t\\tel.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\\n\\t\\t}\\n\\n\\t\\tthis.constrainScrollVel(); // since the scroll values changed, recompute the velocities\\n\\n\\t\\t// if scrolled all the way, which causes the vels to be zero, stop the animation loop\\n\\t\\tif (!this.scrollTopVel && !this.scrollLeftVel) {\\n\\t\\t\\tthis.endAutoScroll();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Kills any existing scrolling animation loop\\n\\tendAutoScroll: function() {\\n\\t\\tif (this.scrollIntervalId) {\\n\\t\\t\\tclearInterval(this.scrollIntervalId);\\n\\t\\t\\tthis.scrollIntervalId = null;\\n\\n\\t\\t\\tthis.handleScrollEnd();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\\n\\thandleDebouncedScroll: function() {\\n\\t\\t// recompute all coordinates, but *only* if this is *not* part of our scrolling animation\\n\\t\\tif (!this.scrollIntervalId) {\\n\\t\\t\\tthis.handleScrollEnd();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called when scrolling has stopped, whether through auto scroll, or the user scrolling\\n\\thandleScrollEnd: function() {\\n\\t}\\n\\n});\\n;;\\n\\n/* Tracks mouse movements over a component and raises events about which hit the mouse is over.\\n------------------------------------------------------------------------------------------------------------------------\\noptions:\\n- subjectEl\\n- subjectCenter\\n*/\\n\\nvar HitDragListener = DragListener.extend({\\n\\n\\tcomponent: null, // converts coordinates to hits\\n\\t\\t// methods: hitsNeeded, hitsNotNeeded, queryHit\\n\\n\\torigHit: null, // the hit the mouse was over when listening started\\n\\thit: null, // the hit the mouse is over\\n\\tcoordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions\\n\\n\\n\\tconstructor: function(component, options) {\\n\\t\\tDragListener.call(this, options); // call the super-constructor\\n\\n\\t\\tthis.component = component;\\n\\t},\\n\\n\\n\\t// Called when drag listening starts (but a real drag has not necessarily began).\\n\\t// ev might be undefined if dragging was started manually.\\n\\thandleInteractionStart: function(ev) {\\n\\t\\tvar subjectEl = this.subjectEl;\\n\\t\\tvar subjectRect;\\n\\t\\tvar origPoint;\\n\\t\\tvar point;\\n\\n\\t\\tthis.component.hitsNeeded();\\n\\t\\tthis.computeScrollBounds(); // for autoscroll\\n\\n\\t\\tif (ev) {\\n\\t\\t\\torigPoint = { left: getEvX(ev), top: getEvY(ev) };\\n\\t\\t\\tpoint = origPoint;\\n\\n\\t\\t\\t// constrain the point to bounds of the element being dragged\\n\\t\\t\\tif (subjectEl) {\\n\\t\\t\\t\\tsubjectRect = getOuterRect(subjectEl); // used for centering as well\\n\\t\\t\\t\\tpoint = constrainPoint(point, subjectRect);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.origHit = this.queryHit(point.left, point.top);\\n\\n\\t\\t\\t// treat the center of the subject as the collision point?\\n\\t\\t\\tif (subjectEl && this.options.subjectCenter) {\\n\\n\\t\\t\\t\\t// only consider the area the subject overlaps the hit. best for large subjects.\\n\\t\\t\\t\\t// TODO: skip this if hit didn't supply left/right/top/bottom\\n\\t\\t\\t\\tif (this.origHit) {\\n\\t\\t\\t\\t\\tsubjectRect = intersectRects(this.origHit, subjectRect) ||\\n\\t\\t\\t\\t\\t\\tsubjectRect; // in case there is no intersection\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpoint = getRectCenter(subjectRect);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.coordAdjust = diffPoints(point, origPoint); // point - origPoint\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.origHit = null;\\n\\t\\t\\tthis.coordAdjust = null;\\n\\t\\t}\\n\\n\\t\\t// call the super-method. do it after origHit has been computed\\n\\t\\tDragListener.prototype.handleInteractionStart.apply(this, arguments);\\n\\t},\\n\\n\\n\\t// Called when the actual drag has started\\n\\thandleDragStart: function(ev) {\\n\\t\\tvar hit;\\n\\n\\t\\tDragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method\\n\\n\\t\\t// might be different from this.origHit if the min-distance is large\\n\\t\\thit = this.queryHit(getEvX(ev), getEvY(ev));\\n\\n\\t\\t// report the initial hit the mouse is over\\n\\t\\t// especially important if no min-distance and drag starts immediately\\n\\t\\tif (hit) {\\n\\t\\t\\tthis.handleHitOver(hit);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called when the drag moves\\n\\thandleDrag: function(dx, dy, ev) {\\n\\t\\tvar hit;\\n\\n\\t\\tDragListener.prototype.handleDrag.apply(this, arguments); // call the super-method\\n\\n\\t\\thit = this.queryHit(getEvX(ev), getEvY(ev));\\n\\n\\t\\tif (!isHitsEqual(hit, this.hit)) { // a different hit than before?\\n\\t\\t\\tif (this.hit) {\\n\\t\\t\\t\\tthis.handleHitOut();\\n\\t\\t\\t}\\n\\t\\t\\tif (hit) {\\n\\t\\t\\t\\tthis.handleHitOver(hit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called when dragging has been stopped\\n\\thandleDragEnd: function() {\\n\\t\\tthis.handleHitDone();\\n\\t\\tDragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method\\n\\t},\\n\\n\\n\\t// Called when a the mouse has just moved over a new hit\\n\\thandleHitOver: function(hit) {\\n\\t\\tvar isOrig = isHitsEqual(hit, this.origHit);\\n\\n\\t\\tthis.hit = hit;\\n\\n\\t\\tthis.trigger('hitOver', this.hit, isOrig, this.origHit);\\n\\t},\\n\\n\\n\\t// Called when the mouse has just moved out of a hit\\n\\thandleHitOut: function() {\\n\\t\\tif (this.hit) {\\n\\t\\t\\tthis.trigger('hitOut', this.hit);\\n\\t\\t\\tthis.handleHitDone();\\n\\t\\t\\tthis.hit = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called after a hitOut. Also called before a dragStop\\n\\thandleHitDone: function() {\\n\\t\\tif (this.hit) {\\n\\t\\t\\tthis.trigger('hitDone', this.hit);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called when the interaction ends, whether there was a real drag or not\\n\\thandleInteractionEnd: function() {\\n\\t\\tDragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method\\n\\n\\t\\tthis.origHit = null;\\n\\t\\tthis.hit = null;\\n\\n\\t\\tthis.component.hitsNotNeeded();\\n\\t},\\n\\n\\n\\t// Called when scrolling has stopped, whether through auto scroll, or the user scrolling\\n\\thandleScrollEnd: function() {\\n\\t\\tDragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method\\n\\n\\t\\t// hits' absolute positions will be in new places after a user's scroll.\\n\\t\\t// HACK for recomputing.\\n\\t\\tif (this.isDragging) {\\n\\t\\t\\tthis.component.releaseHits();\\n\\t\\t\\tthis.component.prepareHits();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Gets the hit underneath the coordinates for the given mouse event\\n\\tqueryHit: function(left, top) {\\n\\n\\t\\tif (this.coordAdjust) {\\n\\t\\t\\tleft += this.coordAdjust.left;\\n\\t\\t\\ttop += this.coordAdjust.top;\\n\\t\\t}\\n\\n\\t\\treturn this.component.queryHit(left, top);\\n\\t}\\n\\n});\\n\\n\\n// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\\n// Two null values will be considered equal, as two \\\"out of the component\\\" states are the same.\\nfunction isHitsEqual(hit0, hit1) {\\n\\n\\tif (!hit0 && !hit1) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (hit0 && hit1) {\\n\\t\\treturn hit0.component === hit1.component &&\\n\\t\\t\\tisHitPropsWithin(hit0, hit1) &&\\n\\t\\t\\tisHitPropsWithin(hit1, hit0); // ensures all props are identical\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\n// Returns true if all of subHit's non-standard properties are within superHit\\nfunction isHitPropsWithin(subHit, superHit) {\\n\\tfor (var propName in subHit) {\\n\\t\\tif (!/^(component|left|right|top|bottom)$/.test(propName)) {\\n\\t\\t\\tif (subHit[propName] !== superHit[propName]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\n;;\\n\\n/*\\nListens to document and window-level user-interaction events, like touch events and mouse events,\\nand fires these events as-is to whoever is observing a GlobalEmitter.\\nBest when used as a singleton via GlobalEmitter.get()\\n\\nNormalizes mouse/touch events. For examples:\\n- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click\\n- compensates for various buggy scenarios where a touchend does not fire\\n*/\\n\\nFC.touchMouseIgnoreWait = 500;\\n\\nvar GlobalEmitter = Class.extend(ListenerMixin, EmitterMixin, {\\n\\n\\tisTouching: false,\\n\\tmouseIgnoreDepth: 0,\\n\\thandleScrollProxy: null,\\n\\n\\n\\tbind: function() {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.listenTo($(document), {\\n\\t\\t\\ttouchstart: this.handleTouchStart,\\n\\t\\t\\ttouchcancel: this.handleTouchCancel,\\n\\t\\t\\ttouchend: this.handleTouchEnd,\\n\\t\\t\\tmousedown: this.handleMouseDown,\\n\\t\\t\\tmousemove: this.handleMouseMove,\\n\\t\\t\\tmouseup: this.handleMouseUp,\\n\\t\\t\\tclick: this.handleClick,\\n\\t\\t\\tselectstart: this.handleSelectStart,\\n\\t\\t\\tcontextmenu: this.handleContextMenu\\n\\t\\t});\\n\\n\\t\\t// because we need to call preventDefault\\n\\t\\t// because https://www.chromestatus.com/features/5093566007214080\\n\\t\\t// TODO: investigate performance because this is a global handler\\n\\t\\twindow.addEventListener(\\n\\t\\t\\t'touchmove',\\n\\t\\t\\tthis.handleTouchMoveProxy = function(ev) {\\n\\t\\t\\t\\t_this.handleTouchMove($.Event(ev));\\n\\t\\t\\t},\\n\\t\\t\\t{ passive: false } // allows preventDefault()\\n\\t\\t);\\n\\n\\t\\t// attach a handler to get called when ANY scroll action happens on the page.\\n\\t\\t// this was impossible to do with normal on/off because 'scroll' doesn't bubble.\\n\\t\\t// http://stackoverflow.com/a/32954565/96342\\n\\t\\twindow.addEventListener(\\n\\t\\t\\t'scroll',\\n\\t\\t\\tthis.handleScrollProxy = function(ev) {\\n\\t\\t\\t\\t_this.handleScroll($.Event(ev));\\n\\t\\t\\t},\\n\\t\\t\\ttrue // useCapture\\n\\t\\t);\\n\\t},\\n\\n\\tunbind: function() {\\n\\t\\tthis.stopListeningTo($(document));\\n\\n\\t\\twindow.removeEventListener(\\n\\t\\t\\t'touchmove',\\n\\t\\t\\tthis.handleTouchMoveProxy\\n\\t\\t);\\n\\n\\t\\twindow.removeEventListener(\\n\\t\\t\\t'scroll',\\n\\t\\t\\tthis.handleScrollProxy,\\n\\t\\t\\ttrue // useCapture\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Touch Handlers\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\thandleTouchStart: function(ev) {\\n\\n\\t\\t// if a previous touch interaction never ended with a touchend, then implicitly end it,\\n\\t\\t// but since a new touch interaction is about to begin, don't start the mouse ignore period.\\n\\t\\tthis.stopTouch(ev, true); // skipMouseIgnore=true\\n\\n\\t\\tthis.isTouching = true;\\n\\t\\tthis.trigger('touchstart', ev);\\n\\t},\\n\\n\\thandleTouchMove: function(ev) {\\n\\t\\tif (this.isTouching) {\\n\\t\\t\\tthis.trigger('touchmove', ev);\\n\\t\\t}\\n\\t},\\n\\n\\thandleTouchCancel: function(ev) {\\n\\t\\tif (this.isTouching) {\\n\\t\\t\\tthis.trigger('touchcancel', ev);\\n\\n\\t\\t\\t// Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.\\n\\t\\t\\t// If touchend fires later, it won't have any effect b/c isTouching will be false.\\n\\t\\t\\tthis.stopTouch(ev);\\n\\t\\t}\\n\\t},\\n\\n\\thandleTouchEnd: function(ev) {\\n\\t\\tthis.stopTouch(ev);\\n\\t},\\n\\n\\n\\t// Mouse Handlers\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\thandleMouseDown: function(ev) {\\n\\t\\tif (!this.shouldIgnoreMouse()) {\\n\\t\\t\\tthis.trigger('mousedown', ev);\\n\\t\\t}\\n\\t},\\n\\n\\thandleMouseMove: function(ev) {\\n\\t\\tif (!this.shouldIgnoreMouse()) {\\n\\t\\t\\tthis.trigger('mousemove', ev);\\n\\t\\t}\\n\\t},\\n\\n\\thandleMouseUp: function(ev) {\\n\\t\\tif (!this.shouldIgnoreMouse()) {\\n\\t\\t\\tthis.trigger('mouseup', ev);\\n\\t\\t}\\n\\t},\\n\\n\\thandleClick: function(ev) {\\n\\t\\tif (!this.shouldIgnoreMouse()) {\\n\\t\\t\\tthis.trigger('click', ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Misc Handlers\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\thandleSelectStart: function(ev) {\\n\\t\\tthis.trigger('selectstart', ev);\\n\\t},\\n\\n\\thandleContextMenu: function(ev) {\\n\\t\\tthis.trigger('contextmenu', ev);\\n\\t},\\n\\n\\thandleScroll: function(ev) {\\n\\t\\tthis.trigger('scroll', ev);\\n\\t},\\n\\n\\n\\t// Utils\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\tstopTouch: function(ev, skipMouseIgnore) {\\n\\t\\tif (this.isTouching) {\\n\\t\\t\\tthis.isTouching = false;\\n\\t\\t\\tthis.trigger('touchend', ev);\\n\\n\\t\\t\\tif (!skipMouseIgnore) {\\n\\t\\t\\t\\tthis.startTouchMouseIgnore();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tstartTouchMouseIgnore: function() {\\n\\t\\tvar _this = this;\\n\\t\\tvar wait = FC.touchMouseIgnoreWait;\\n\\n\\t\\tif (wait) {\\n\\t\\t\\tthis.mouseIgnoreDepth++;\\n\\t\\t\\tsetTimeout(function() {\\n\\t\\t\\t\\t_this.mouseIgnoreDepth--;\\n\\t\\t\\t}, wait);\\n\\t\\t}\\n\\t},\\n\\n\\tshouldIgnoreMouse: function() {\\n\\t\\treturn this.isTouching || Boolean(this.mouseIgnoreDepth);\\n\\t}\\n\\n});\\n\\n\\n// Singleton\\n// ---------------------------------------------------------------------------------------------------------------------\\n\\n(function() {\\n\\tvar globalEmitter = null;\\n\\tvar neededCount = 0;\\n\\n\\n\\t// gets the singleton\\n\\tGlobalEmitter.get = function() {\\n\\n\\t\\tif (!globalEmitter) {\\n\\t\\t\\tglobalEmitter = new GlobalEmitter();\\n\\t\\t\\tglobalEmitter.bind();\\n\\t\\t}\\n\\n\\t\\treturn globalEmitter;\\n\\t};\\n\\n\\n\\t// called when an object knows it will need a GlobalEmitter in the near future.\\n\\tGlobalEmitter.needed = function() {\\n\\t\\tGlobalEmitter.get(); // ensures globalEmitter\\n\\t\\tneededCount++;\\n\\t};\\n\\n\\n\\t// called when the object that originally called needed() doesn't need a GlobalEmitter anymore.\\n\\tGlobalEmitter.unneeded = function() {\\n\\t\\tneededCount--;\\n\\n\\t\\tif (!neededCount) { // nobody else needs it\\n\\t\\t\\tglobalEmitter.unbind();\\n\\t\\t\\tglobalEmitter = null;\\n\\t\\t}\\n\\t};\\n\\n})();\\n\\n;;\\n\\n/* Creates a clone of an element and lets it track the mouse as it moves\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nvar MouseFollower = Class.extend(ListenerMixin, {\\n\\n\\toptions: null,\\n\\n\\tsourceEl: null, // the element that will be cloned and made to look like it is dragging\\n\\tel: null, // the clone of `sourceEl` that will track the mouse\\n\\tparentEl: null, // the element that `el` (the clone) will be attached to\\n\\n\\t// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl\\n\\ttop0: null,\\n\\tleft0: null,\\n\\n\\t// the absolute coordinates of the initiating touch/mouse action\\n\\ty0: null,\\n\\tx0: null,\\n\\n\\t// the number of pixels the mouse has moved from its initial position\\n\\ttopDelta: null,\\n\\tleftDelta: null,\\n\\n\\tisFollowing: false,\\n\\tisHidden: false,\\n\\tisAnimating: false, // doing the revert animation?\\n\\n\\tconstructor: function(sourceEl, options) {\\n\\t\\tthis.options = options = options || {};\\n\\t\\tthis.sourceEl = sourceEl;\\n\\t\\tthis.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\\n\\t},\\n\\n\\n\\t// Causes the element to start following the mouse\\n\\tstart: function(ev) {\\n\\t\\tif (!this.isFollowing) {\\n\\t\\t\\tthis.isFollowing = true;\\n\\n\\t\\t\\tthis.y0 = getEvY(ev);\\n\\t\\t\\tthis.x0 = getEvX(ev);\\n\\t\\t\\tthis.topDelta = 0;\\n\\t\\t\\tthis.leftDelta = 0;\\n\\n\\t\\t\\tif (!this.isHidden) {\\n\\t\\t\\t\\tthis.updatePosition();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (getEvIsTouch(ev)) {\\n\\t\\t\\t\\tthis.listenTo($(document), 'touchmove', this.handleMove);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tthis.listenTo($(document), 'mousemove', this.handleMove);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\\n\\t// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\\n\\tstop: function(shouldRevert, callback) {\\n\\t\\tvar _this = this;\\n\\t\\tvar revertDuration = this.options.revertDuration;\\n\\n\\t\\tfunction complete() { // might be called by .animate(), which might change `this` context\\n\\t\\t\\t_this.isAnimating = false;\\n\\t\\t\\t_this.removeElement();\\n\\n\\t\\t\\t_this.top0 = _this.left0 = null; // reset state for future updatePosition calls\\n\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\tcallback();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time\\n\\t\\t\\tthis.isFollowing = false;\\n\\n\\t\\t\\tthis.stopListeningTo($(document));\\n\\n\\t\\t\\tif (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?\\n\\t\\t\\t\\tthis.isAnimating = true;\\n\\t\\t\\t\\tthis.el.animate({\\n\\t\\t\\t\\t\\ttop: this.top0,\\n\\t\\t\\t\\t\\tleft: this.left0\\n\\t\\t\\t\\t}, {\\n\\t\\t\\t\\t\\tduration: revertDuration,\\n\\t\\t\\t\\t\\tcomplete: complete\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcomplete();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Gets the tracking element. Create it if necessary\\n\\tgetEl: function() {\\n\\t\\tvar el = this.el;\\n\\n\\t\\tif (!el) {\\n\\t\\t\\tel = this.el = this.sourceEl.clone()\\n\\t\\t\\t\\t.addClass(this.options.additionalClass || '')\\n\\t\\t\\t\\t.css({\\n\\t\\t\\t\\t\\tposition: 'absolute',\\n\\t\\t\\t\\t\\tvisibility: '', // in case original element was hidden (commonly through hideEvents())\\n\\t\\t\\t\\t\\tdisplay: this.isHidden ? 'none' : '', // for when initially hidden\\n\\t\\t\\t\\t\\tmargin: 0,\\n\\t\\t\\t\\t\\tright: 'auto', // erase and set width instead\\n\\t\\t\\t\\t\\tbottom: 'auto', // erase and set height instead\\n\\t\\t\\t\\t\\twidth: this.sourceEl.width(), // explicit height in case there was a 'right' value\\n\\t\\t\\t\\t\\theight: this.sourceEl.height(), // explicit width in case there was a 'bottom' value\\n\\t\\t\\t\\t\\topacity: this.options.opacity || '',\\n\\t\\t\\t\\t\\tzIndex: this.options.zIndex\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t// we don't want long taps or any mouse interaction causing selection/menus.\\n\\t\\t\\t// would use preventSelection(), but that prevents selectstart, causing problems.\\n\\t\\t\\tel.addClass('fc-unselectable');\\n\\n\\t\\t\\tel.appendTo(this.parentEl);\\n\\t\\t}\\n\\n\\t\\treturn el;\\n\\t},\\n\\n\\n\\t// Removes the tracking element if it has already been created\\n\\tremoveElement: function() {\\n\\t\\tif (this.el) {\\n\\t\\t\\tthis.el.remove();\\n\\t\\t\\tthis.el = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Update the CSS position of the tracking element\\n\\tupdatePosition: function() {\\n\\t\\tvar sourceOffset;\\n\\t\\tvar origin;\\n\\n\\t\\tthis.getEl(); // ensure this.el\\n\\n\\t\\t// make sure origin info was computed\\n\\t\\tif (this.top0 === null) {\\n\\t\\t\\tsourceOffset = this.sourceEl.offset();\\n\\t\\t\\torigin = this.el.offsetParent().offset();\\n\\t\\t\\tthis.top0 = sourceOffset.top - origin.top;\\n\\t\\t\\tthis.left0 = sourceOffset.left - origin.left;\\n\\t\\t}\\n\\n\\t\\tthis.el.css({\\n\\t\\t\\ttop: this.top0 + this.topDelta,\\n\\t\\t\\tleft: this.left0 + this.leftDelta\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Gets called when the user moves the mouse\\n\\thandleMove: function(ev) {\\n\\t\\tthis.topDelta = getEvY(ev) - this.y0;\\n\\t\\tthis.leftDelta = getEvX(ev) - this.x0;\\n\\n\\t\\tif (!this.isHidden) {\\n\\t\\t\\tthis.updatePosition();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Temporarily makes the tracking element invisible. Can be called before following starts\\n\\thide: function() {\\n\\t\\tif (!this.isHidden) {\\n\\t\\t\\tthis.isHidden = true;\\n\\t\\t\\tif (this.el) {\\n\\t\\t\\t\\tthis.el.hide();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Show the tracking element after it has been temporarily hidden\\n\\tshow: function() {\\n\\t\\tif (this.isHidden) {\\n\\t\\t\\tthis.isHidden = false;\\n\\t\\t\\tthis.updatePosition();\\n\\t\\t\\tthis.getEl().show();\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n;;\\n\\n/* An abstract class comprised of a \\\"grid\\\" of areas that each represent a specific datetime\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nvar Grid = FC.Grid = Class.extend(ListenerMixin, {\\n\\n\\t// self-config, overridable by subclasses\\n\\thasDayInteractions: true, // can user click/select ranges of time?\\n\\n\\tview: null, // a View object\\n\\tisRTL: null, // shortcut to the view's isRTL option\\n\\n\\tstart: null,\\n\\tend: null,\\n\\n\\tel: null, // the containing element\\n\\telsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.\\n\\n\\t// derived from options\\n\\teventTimeFormat: null,\\n\\tdisplayEventTime: null,\\n\\tdisplayEventEnd: null,\\n\\n\\tminResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration\\n\\n\\t// if defined, holds the unit identified (ex: \\\"year\\\" or \\\"month\\\") that determines the level of granularity\\n\\t// of the date areas. if not defined, assumes to be day and time granularity.\\n\\t// TODO: port isTimeScale into same system?\\n\\tlargeUnit: null,\\n\\n\\tdayClickListener: null,\\n\\tdaySelectListener: null,\\n\\tsegDragListener: null,\\n\\tsegResizeListener: null,\\n\\texternalDragListener: null,\\n\\n\\n\\tconstructor: function(view) {\\n\\t\\tthis.view = view;\\n\\t\\tthis.isRTL = view.opt('isRTL');\\n\\t\\tthis.elsByFill = {};\\n\\n\\t\\tthis.dayClickListener = this.buildDayClickListener();\\n\\t\\tthis.daySelectListener = this.buildDaySelectListener();\\n\\t},\\n\\n\\n\\t/* Options\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'\\n\\tcomputeEventTimeFormat: function() {\\n\\t\\treturn this.view.opt('smallTimeFormat');\\n\\t},\\n\\n\\n\\t// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.\\n\\t// Only applies to non-all-day events.\\n\\tcomputeDisplayEventTime: function() {\\n\\t\\treturn true;\\n\\t},\\n\\n\\n\\t// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'\\n\\tcomputeDisplayEventEnd: function() {\\n\\t\\treturn true;\\n\\t},\\n\\n\\n\\t/* Dates\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Tells the grid about what period of time to display.\\n\\t// Any date-related internal data should be generated.\\n\\tsetRange: function(range) {\\n\\t\\tthis.start = range.start.clone();\\n\\t\\tthis.end = range.end.clone();\\n\\n\\t\\tthis.rangeUpdated();\\n\\t\\tthis.processRangeOptions();\\n\\t},\\n\\n\\n\\t// Called when internal variables that rely on the range should be updated\\n\\trangeUpdated: function() {\\n\\t},\\n\\n\\n\\t// Updates values that rely on options and also relate to range\\n\\tprocessRangeOptions: function() {\\n\\t\\tvar view = this.view;\\n\\t\\tvar displayEventTime;\\n\\t\\tvar displayEventEnd;\\n\\n\\t\\tthis.eventTimeFormat =\\n\\t\\t\\tview.opt('eventTimeFormat') ||\\n\\t\\t\\tview.opt('timeFormat') || // deprecated\\n\\t\\t\\tthis.computeEventTimeFormat();\\n\\n\\t\\tdisplayEventTime = view.opt('displayEventTime');\\n\\t\\tif (displayEventTime == null) {\\n\\t\\t\\tdisplayEventTime = this.computeDisplayEventTime(); // might be based off of range\\n\\t\\t}\\n\\n\\t\\tdisplayEventEnd = view.opt('displayEventEnd');\\n\\t\\tif (displayEventEnd == null) {\\n\\t\\t\\tdisplayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\\n\\t\\t}\\n\\n\\t\\tthis.displayEventTime = displayEventTime;\\n\\t\\tthis.displayEventEnd = displayEventEnd;\\n\\t},\\n\\n\\n\\t// Converts a span (has unzoned start/end and any other grid-specific location information)\\n\\t// into an array of segments (pieces of events whose format is decided by the grid).\\n\\tspanToSegs: function(span) {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Diffs the two dates, returning a duration, based on granularity of the grid\\n\\t// TODO: port isTimeScale into this system?\\n\\tdiffDates: function(a, b) {\\n\\t\\tif (this.largeUnit) {\\n\\t\\t\\treturn diffByUnit(a, b, this.largeUnit);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn diffDayTime(a, b);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Hit Area\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\thitsNeededDepth: 0, // necessary because multiple callers might need the same hits\\n\\n\\thitsNeeded: function() {\\n\\t\\tif (!(this.hitsNeededDepth++)) {\\n\\t\\t\\tthis.prepareHits();\\n\\t\\t}\\n\\t},\\n\\n\\thitsNotNeeded: function() {\\n\\t\\tif (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {\\n\\t\\t\\tthis.releaseHits();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit\\n\\tprepareHits: function() {\\n\\t},\\n\\n\\n\\t// Called when queryHit calls have subsided. Good place to clear any coordinate caches.\\n\\treleaseHits: function() {\\n\\t},\\n\\n\\n\\t// Given coordinates from the topleft of the document, return data about the date-related area underneath.\\n\\t// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\\n\\t// Must have a `grid` property, a reference to this current grid. TODO: avoid this\\n\\t// The returned object will be processed by getHitSpan and getHitEl.\\n\\tqueryHit: function(leftOffset, topOffset) {\\n\\t},\\n\\n\\n\\t// like getHitSpan, but returns null if the resulting span's range is invalid\\n\\tgetSafeHitSpan: function(hit) {\\n\\t\\tvar hitSpan = this.getHitSpan(hit);\\n\\n\\t\\tif (!isRangeWithinRange(hitSpan, this.view.activeRange)) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn hitSpan;\\n\\t},\\n\\n\\n\\t// Given position-level information about a date-related area within the grid,\\n\\t// should return an object with at least a start/end date. Can provide other information as well.\\n\\tgetHitSpan: function(hit) {\\n\\t},\\n\\n\\n\\t// Given position-level information about a date-related area within the grid,\\n\\t// should return a jQuery element that best represents it. passed to dayClick callback.\\n\\tgetHitEl: function(hit) {\\n\\t},\\n\\n\\n\\t/* Rendering\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Sets the container element that the grid should render inside of.\\n\\t// Does other DOM-related initializations.\\n\\tsetElement: function(el) {\\n\\t\\tthis.el = el;\\n\\n\\t\\tif (this.hasDayInteractions) {\\n\\t\\t\\tpreventSelection(el);\\n\\n\\t\\t\\tthis.bindDayHandler('touchstart', this.dayTouchStart);\\n\\t\\t\\tthis.bindDayHandler('mousedown', this.dayMousedown);\\n\\t\\t}\\n\\n\\t\\t// attach event-element-related handlers. in Grid.events\\n\\t\\t// same garbage collection note as above.\\n\\t\\tthis.bindSegHandlers();\\n\\n\\t\\tthis.bindGlobalHandlers();\\n\\t},\\n\\n\\n\\tbindDayHandler: function(name, handler) {\\n\\t\\tvar _this = this;\\n\\n\\t\\t// attach a handler to the grid's root element.\\n\\t\\t// jQuery will take care of unregistering them when removeElement gets called.\\n\\t\\tthis.el.on(name, function(ev) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!$(ev.target).is(\\n\\t\\t\\t\\t\\t_this.segSelector + ',' + // directly on an event element\\n\\t\\t\\t\\t\\t_this.segSelector + ' *,' + // within an event element\\n\\t\\t\\t\\t\\t'.fc-more,' + // a \\\"more..\\\" link\\n\\t\\t\\t\\t\\t'a[data-goto]' // a clickable nav link\\n\\t\\t\\t\\t)\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn handler.call(_this, ev);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.\\n\\t// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View\\n\\tremoveElement: function() {\\n\\t\\tthis.unbindGlobalHandlers();\\n\\t\\tthis.clearDragListeners();\\n\\n\\t\\tthis.el.remove();\\n\\n\\t\\t// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement\\n\\t},\\n\\n\\n\\t// Renders the basic structure of grid view before any content is rendered\\n\\trenderSkeleton: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Renders the grid's date-related content (like areas that represent days/times).\\n\\t// Assumes setRange has already been called and the skeleton has already been rendered.\\n\\trenderDates: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Unrenders the grid's date-related content\\n\\tunrenderDates: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t/* Handlers\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Binds DOM handlers to elements that reside outside the grid, such as the document\\n\\tbindGlobalHandlers: function() {\\n\\t\\tthis.listenTo($(document), {\\n\\t\\t\\tdragstart: this.externalDragStart, // jqui\\n\\t\\t\\tsortstart: this.externalDragStart // jqui\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Unbinds DOM handlers from elements that reside outside the grid\\n\\tunbindGlobalHandlers: function() {\\n\\t\\tthis.stopListeningTo($(document));\\n\\t},\\n\\n\\n\\t// Process a mousedown on an element that represents a day. For day clicking and selecting.\\n\\tdayMousedown: function(ev) {\\n\\t\\tvar view = this.view;\\n\\n\\t\\t// HACK\\n\\t\\t// This will still work even though bindDayHandler doesn't use GlobalEmitter.\\n\\t\\tif (GlobalEmitter.get().shouldIgnoreMouse()) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.dayClickListener.startInteraction(ev);\\n\\n\\t\\tif (view.opt('selectable')) {\\n\\t\\t\\tthis.daySelectListener.startInteraction(ev, {\\n\\t\\t\\t\\tdistance: view.opt('selectMinDistance')\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\n\\tdayTouchStart: function(ev) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar selectLongPressDelay;\\n\\n\\t\\t// On iOS (and Android?) when a new selection is initiated overtop another selection,\\n\\t\\t// the touchend never fires because the elements gets removed mid-touch-interaction (my theory).\\n\\t\\t// HACK: simply don't allow this to happen.\\n\\t\\t// ALSO: prevent selection when an *event* is already raised.\\n\\t\\tif (view.isSelected || view.selectedEvent) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tselectLongPressDelay = view.opt('selectLongPressDelay');\\n\\t\\tif (selectLongPressDelay == null) {\\n\\t\\t\\tselectLongPressDelay = view.opt('longPressDelay'); // fallback\\n\\t\\t}\\n\\n\\t\\tthis.dayClickListener.startInteraction(ev);\\n\\n\\t\\tif (view.opt('selectable')) {\\n\\t\\t\\tthis.daySelectListener.startInteraction(ev, {\\n\\t\\t\\t\\tdelay: selectLongPressDelay\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Creates a listener that tracks the user's drag across day elements, for day clicking.\\n\\tbuildDayClickListener: function() {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\t\\tvar dayClickHit; // null if invalid dayClick\\n\\n\\t\\tvar dragListener = new HitDragListener(this, {\\n\\t\\t\\tscroll: view.opt('dragScroll'),\\n\\t\\t\\tinteractionStart: function() {\\n\\t\\t\\t\\tdayClickHit = dragListener.origHit;\\n\\t\\t\\t},\\n\\t\\t\\thitOver: function(hit, isOrig, origHit) {\\n\\t\\t\\t\\t// if user dragged to another cell at any point, it can no longer be a dayClick\\n\\t\\t\\t\\tif (!isOrig) {\\n\\t\\t\\t\\t\\tdayClickHit = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\\n\\t\\t\\t\\tdayClickHit = null;\\n\\t\\t\\t},\\n\\t\\t\\tinteractionEnd: function(ev, isCancelled) {\\n\\t\\t\\t\\tvar hitSpan;\\n\\n\\t\\t\\t\\tif (!isCancelled && dayClickHit) {\\n\\t\\t\\t\\t\\thitSpan = _this.getSafeHitSpan(dayClickHit);\\n\\n\\t\\t\\t\\t\\tif (hitSpan) {\\n\\t\\t\\t\\t\\t\\tview.triggerDayClick(hitSpan, _this.getHitEl(dayClickHit), ev);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// because dayClickListener won't be called with any time delay, \\\"dragging\\\" will begin immediately,\\n\\t\\t// which will kill any touchmoving/scrolling. Prevent this.\\n\\t\\tdragListener.shouldCancelTouchScroll = false;\\n\\n\\t\\tdragListener.scrollAlwaysKills = true;\\n\\n\\t\\treturn dragListener;\\n\\t},\\n\\n\\n\\t// Creates a listener that tracks the user's drag across day elements, for day selecting.\\n\\tbuildDaySelectListener: function() {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\t\\tvar selectionSpan; // null if invalid selection\\n\\n\\t\\tvar dragListener = new HitDragListener(this, {\\n\\t\\t\\tscroll: view.opt('dragScroll'),\\n\\t\\t\\tinteractionStart: function() {\\n\\t\\t\\t\\tselectionSpan = null;\\n\\t\\t\\t},\\n\\t\\t\\tdragStart: function() {\\n\\t\\t\\t\\tview.unselect(); // since we could be rendering a new selection, we want to clear any old one\\n\\t\\t\\t},\\n\\t\\t\\thitOver: function(hit, isOrig, origHit) {\\n\\t\\t\\t\\tvar origHitSpan;\\n\\t\\t\\t\\tvar hitSpan;\\n\\n\\t\\t\\t\\tif (origHit) { // click needs to have started on a hit\\n\\n\\t\\t\\t\\t\\torigHitSpan = _this.getSafeHitSpan(origHit);\\n\\t\\t\\t\\t\\thitSpan = _this.getSafeHitSpan(hit);\\n\\n\\t\\t\\t\\t\\tif (origHitSpan && hitSpan) {\\n\\t\\t\\t\\t\\t\\tselectionSpan = _this.computeSelection(origHitSpan, hitSpan);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tselectionSpan = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (selectionSpan) {\\n\\t\\t\\t\\t\\t\\t_this.renderSelection(selectionSpan);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (selectionSpan === false) {\\n\\t\\t\\t\\t\\t\\tdisableCursor();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\\n\\t\\t\\t\\tselectionSpan = null;\\n\\t\\t\\t\\t_this.unrenderSelection();\\n\\t\\t\\t},\\n\\t\\t\\thitDone: function() { // called after a hitOut OR before a dragEnd\\n\\t\\t\\t\\tenableCursor();\\n\\t\\t\\t},\\n\\t\\t\\tinteractionEnd: function(ev, isCancelled) {\\n\\t\\t\\t\\tif (!isCancelled && selectionSpan) {\\n\\t\\t\\t\\t\\t// the selection will already have been rendered. just report it\\n\\t\\t\\t\\t\\tview.reportSelection(selectionSpan, ev);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn dragListener;\\n\\t},\\n\\n\\n\\t// Kills all in-progress dragging.\\n\\t// Useful for when public API methods that result in re-rendering are invoked during a drag.\\n\\t// Also useful for when touch devices misbehave and don't fire their touchend.\\n\\tclearDragListeners: function() {\\n\\t\\tthis.dayClickListener.endInteraction();\\n\\t\\tthis.daySelectListener.endInteraction();\\n\\n\\t\\tif (this.segDragListener) {\\n\\t\\t\\tthis.segDragListener.endInteraction(); // will clear this.segDragListener\\n\\t\\t}\\n\\t\\tif (this.segResizeListener) {\\n\\t\\t\\tthis.segResizeListener.endInteraction(); // will clear this.segResizeListener\\n\\t\\t}\\n\\t\\tif (this.externalDragListener) {\\n\\t\\t\\tthis.externalDragListener.endInteraction(); // will clear this.externalDragListener\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Event Helper\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\t// TODO: should probably move this to Grid.events, like we did event dragging / resizing\\n\\n\\n\\t// Renders a mock event at the given event location, which contains zoned start/end properties.\\n\\t// Returns all mock event elements.\\n\\trenderEventLocationHelper: function(eventLocation, sourceSeg) {\\n\\t\\tvar fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);\\n\\n\\t\\treturn this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering\\n\\t},\\n\\n\\n\\t// Builds a fake event given zoned event date properties and a segment is should be inspired from.\\n\\t// The range's end can be null, in which case the mock event that is rendered will have a null end time.\\n\\t// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.\\n\\tfabricateHelperEvent: function(eventLocation, sourceSeg) {\\n\\t\\tvar fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible\\n\\n\\t\\tfakeEvent.start = eventLocation.start.clone();\\n\\t\\tfakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;\\n\\t\\tfakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates\\n\\t\\tthis.view.calendar.normalizeEventDates(fakeEvent);\\n\\n\\t\\t// this extra className will be useful for differentiating real events from mock events in CSS\\n\\t\\tfakeEvent.className = (fakeEvent.className || []).concat('fc-helper');\\n\\n\\t\\t// if something external is being dragged in, don't render a resizer\\n\\t\\tif (!sourceSeg) {\\n\\t\\t\\tfakeEvent.editable = false;\\n\\t\\t}\\n\\n\\t\\treturn fakeEvent;\\n\\t},\\n\\n\\n\\t// Renders a mock event. Given zoned event date properties.\\n\\t// Must return all mock event elements.\\n\\trenderHelper: function(eventLocation, sourceSeg) {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Unrenders a mock event\\n\\tunrenderHelper: function() {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t/* Selection\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.\\n\\t// Given a span (unzoned start/end and other misc data)\\n\\trenderSelection: function(span) {\\n\\t\\tthis.renderHighlight(span);\\n\\t},\\n\\n\\n\\t// Unrenders any visual indications of a selection. Will unrender a highlight by default.\\n\\tunrenderSelection: function() {\\n\\t\\tthis.unrenderHighlight();\\n\\t},\\n\\n\\n\\t// Given the first and last date-spans of a selection, returns another date-span object.\\n\\t// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().\\n\\t// Will return false if the selection is invalid and this should be indicated to the user.\\n\\t// Will return null/undefined if a selection invalid but no error should be reported.\\n\\tcomputeSelection: function(span0, span1) {\\n\\t\\tvar span = this.computeSelectionSpan(span0, span1);\\n\\n\\t\\tif (span && !this.view.calendar.isSelectionSpanAllowed(span)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn span;\\n\\t},\\n\\n\\n\\t// Given two spans, must return the combination of the two.\\n\\t// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\\n\\tcomputeSelectionSpan: function(span0, span1) {\\n\\t\\tvar dates = [ span0.start, span0.end, span1.start, span1.end ];\\n\\n\\t\\tdates.sort(compareNumbers); // sorts chronologically. works with Moments\\n\\n\\t\\treturn { start: dates[0].clone(), end: dates[3].clone() };\\n\\t},\\n\\n\\n\\t/* Highlight\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\\n\\trenderHighlight: function(span) {\\n\\t\\tthis.renderFill('highlight', this.spanToSegs(span));\\n\\t},\\n\\n\\n\\t// Unrenders the emphasis on a date range\\n\\tunrenderHighlight: function() {\\n\\t\\tthis.unrenderFill('highlight');\\n\\t},\\n\\n\\n\\t// Generates an array of classNames for rendering the highlight. Used by the fill system.\\n\\thighlightSegClasses: function() {\\n\\t\\treturn [ 'fc-highlight' ];\\n\\t},\\n\\n\\n\\t/* Business Hours\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderBusinessHours: function() {\\n\\t},\\n\\n\\n\\tunrenderBusinessHours: function() {\\n\\t},\\n\\n\\n\\t/* Now Indicator\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tgetNowIndicatorUnit: function() {\\n\\t},\\n\\n\\n\\trenderNowIndicator: function(date) {\\n\\t},\\n\\n\\n\\tunrenderNowIndicator: function() {\\n\\t},\\n\\n\\n\\t/* Fill System (highlight, background events, business hours)\\n\\t--------------------------------------------------------------------------------------------------------------------\\n\\tTODO: remove this system. like we did in TimeGrid\\n\\t*/\\n\\n\\n\\t// Renders a set of rectangles over the given segments of time.\\n\\t// MUST RETURN a subset of segs, the segs that were actually rendered.\\n\\t// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement\\n\\trenderFill: function(type, segs) {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Unrenders a specific type of fill that is currently rendered on the grid\\n\\tunrenderFill: function(type) {\\n\\t\\tvar el = this.elsByFill[type];\\n\\n\\t\\tif (el) {\\n\\t\\t\\tel.remove();\\n\\t\\t\\tdelete this.elsByFill[type];\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\\n\\t// Only returns segments that successfully rendered.\\n\\t// To be harnessed by renderFill (implemented by subclasses).\\n\\t// Analagous to renderFgSegEls.\\n\\trenderFillSegEls: function(type, segs) {\\n\\t\\tvar _this = this;\\n\\t\\tvar segElMethod = this[type + 'SegEl'];\\n\\t\\tvar html = '';\\n\\t\\tvar renderedSegs = [];\\n\\t\\tvar i;\\n\\n\\t\\tif (segs.length) {\\n\\n\\t\\t\\t// build a large concatenation of segment HTML\\n\\t\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\t\\thtml += this.fillSegHtml(type, segs[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Grab individual elements from the combined HTML string. Use each as the default rendering.\\n\\t\\t\\t// Then, compute the 'el' for each segment.\\n\\t\\t\\t$(html).each(function(i, node) {\\n\\t\\t\\t\\tvar seg = segs[i];\\n\\t\\t\\t\\tvar el = $(node);\\n\\n\\t\\t\\t\\t// allow custom filter methods per-type\\n\\t\\t\\t\\tif (segElMethod) {\\n\\t\\t\\t\\t\\tel = segElMethod.call(_this, seg, el);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (el) { // custom filters did not cancel the render\\n\\t\\t\\t\\t\\tel = $(el); // allow custom filter to return raw DOM node\\n\\n\\t\\t\\t\\t\\t// correct element type? (would be bad if a non-TD were inserted into a table for example)\\n\\t\\t\\t\\t\\tif (el.is(_this.fillSegTag)) {\\n\\t\\t\\t\\t\\t\\tseg.el = el;\\n\\t\\t\\t\\t\\t\\trenderedSegs.push(seg);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn renderedSegs;\\n\\t},\\n\\n\\n\\tfillSegTag: 'div', // subclasses can override\\n\\n\\n\\t// Builds the HTML needed for one fill segment. Generic enough to work with different types.\\n\\tfillSegHtml: function(type, seg) {\\n\\n\\t\\t// custom hooks per-type\\n\\t\\tvar classesMethod = this[type + 'SegClasses'];\\n\\t\\tvar cssMethod = this[type + 'SegCss'];\\n\\n\\t\\tvar classes = classesMethod ? classesMethod.call(this, seg) : [];\\n\\t\\tvar css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});\\n\\n\\t\\treturn '<' + this.fillSegTag +\\n\\t\\t\\t(classes.length ? ' class=\\\"' + classes.join(' ') + '\\\"' : '') +\\n\\t\\t\\t(css ? ' style=\\\"' + css + '\\\"' : '') +\\n\\t\\t\\t' />';\\n\\t},\\n\\n\\n\\n\\t/* Generic rendering utilities for subclasses\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Computes HTML classNames for a single-day element\\n\\tgetDayClasses: function(date, noThemeHighlight) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar classes = [];\\n\\t\\tvar today;\\n\\n\\t\\tif (!isDateWithinRange(date, view.activeRange)) {\\n\\t\\t\\tclasses.push('fc-disabled-day'); // TODO: jQuery UI theme?\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tclasses.push('fc-' + dayIDs[date.day()]);\\n\\n\\t\\t\\tif (\\n\\t\\t\\t\\tview.currentRangeAs('months') == 1 && // TODO: somehow get into MonthView\\n\\t\\t\\t\\tdate.month() != view.currentRange.start.month()\\n\\t\\t\\t) {\\n\\t\\t\\t\\tclasses.push('fc-other-month');\\n\\t\\t\\t}\\n\\n\\t\\t\\ttoday = view.calendar.getNow();\\n\\n\\t\\t\\tif (date.isSame(today, 'day')) {\\n\\t\\t\\t\\tclasses.push('fc-today');\\n\\n\\t\\t\\t\\tif (noThemeHighlight !== true) {\\n\\t\\t\\t\\t\\tclasses.push(view.highlightStateClass);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (date < today) {\\n\\t\\t\\t\\tclasses.push('fc-past');\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tclasses.push('fc-future');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn classes;\\n\\t}\\n\\n});\\n\\n;;\\n\\n/* Event-rendering and event-interaction methods for the abstract Grid class\\n----------------------------------------------------------------------------------------------------------------------\\n\\nData Types:\\n\\tevent - { title, id, start, (end), whatever }\\n\\tlocation - { start, (end), allDay }\\n\\trawEventRange - { start, end }\\n\\teventRange - { start, end, isStart, isEnd }\\n\\teventSpan - { start, end, isStart, isEnd, whatever }\\n\\teventSeg - { event, whatever }\\n\\tseg - { whatever }\\n*/\\n\\nGrid.mixin({\\n\\n\\t// self-config, overridable by subclasses\\n\\tsegSelector: '.fc-event-container > *', // what constitutes an event element?\\n\\n\\tmousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing\\n\\tisDraggingSeg: false, // is a segment being dragged? boolean\\n\\tisResizingSeg: false, // is a segment being resized? boolean\\n\\tisDraggingExternal: false, // jqui-dragging an external element? boolean\\n\\tsegs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`\\n\\n\\n\\t// Renders the given events onto the grid\\n\\trenderEvents: function(events) {\\n\\t\\tvar bgEvents = [];\\n\\t\\tvar fgEvents = [];\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < events.length; i++) {\\n\\t\\t\\t(isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);\\n\\t\\t}\\n\\n\\t\\tthis.segs = [].concat( // record all segs\\n\\t\\t\\tthis.renderBgEvents(bgEvents),\\n\\t\\t\\tthis.renderFgEvents(fgEvents)\\n\\t\\t);\\n\\t},\\n\\n\\n\\trenderBgEvents: function(events) {\\n\\t\\tvar segs = this.eventsToSegs(events);\\n\\n\\t\\t// renderBgSegs might return a subset of segs, segs that were actually rendered\\n\\t\\treturn this.renderBgSegs(segs) || segs;\\n\\t},\\n\\n\\n\\trenderFgEvents: function(events) {\\n\\t\\tvar segs = this.eventsToSegs(events);\\n\\n\\t\\t// renderFgSegs might return a subset of segs, segs that were actually rendered\\n\\t\\treturn this.renderFgSegs(segs) || segs;\\n\\t},\\n\\n\\n\\t// Unrenders all events currently rendered on the grid\\n\\tunrenderEvents: function() {\\n\\t\\tthis.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event\\n\\t\\tthis.clearDragListeners();\\n\\n\\t\\tthis.unrenderFgSegs();\\n\\t\\tthis.unrenderBgSegs();\\n\\n\\t\\tthis.segs = null;\\n\\t},\\n\\n\\n\\t// Retrieves all rendered segment objects currently rendered on the grid\\n\\tgetEventSegs: function() {\\n\\t\\treturn this.segs || [];\\n\\t},\\n\\n\\n\\t/* Foreground Segment Rendering\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.\\n\\trenderFgSegs: function(segs) {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Unrenders all currently rendered foreground segments\\n\\tunrenderFgSegs: function() {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Renders and assigns an `el` property for each foreground event segment.\\n\\t// Only returns segments that successfully rendered.\\n\\t// A utility that subclasses may use.\\n\\trenderFgSegEls: function(segs, disableResizing) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar html = '';\\n\\t\\tvar renderedSegs = [];\\n\\t\\tvar i;\\n\\n\\t\\tif (segs.length) { // don't build an empty html string\\n\\n\\t\\t\\t// build a large concatenation of event segment HTML\\n\\t\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\t\\thtml += this.fgSegHtml(segs[i], disableResizing);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Grab individual elements from the combined HTML string. Use each as the default rendering.\\n\\t\\t\\t// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\\n\\t\\t\\t$(html).each(function(i, node) {\\n\\t\\t\\t\\tvar seg = segs[i];\\n\\t\\t\\t\\tvar el = view.resolveEventEl(seg.event, $(node));\\n\\n\\t\\t\\t\\tif (el) {\\n\\t\\t\\t\\t\\tel.data('fc-seg', seg); // used by handlers\\n\\t\\t\\t\\t\\tseg.el = el;\\n\\t\\t\\t\\t\\trenderedSegs.push(seg);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn renderedSegs;\\n\\t},\\n\\n\\n\\t// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\\n\\tfgSegHtml: function(seg, disableResizing) {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t/* Background Segment Rendering\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders the given background event segments onto the grid.\\n\\t// Returns a subset of the segs that were actually rendered.\\n\\trenderBgSegs: function(segs) {\\n\\t\\treturn this.renderFill('bgEvent', segs);\\n\\t},\\n\\n\\n\\t// Unrenders all the currently rendered background event segments\\n\\tunrenderBgSegs: function() {\\n\\t\\tthis.unrenderFill('bgEvent');\\n\\t},\\n\\n\\n\\t// Renders a background event element, given the default rendering. Called by the fill system.\\n\\tbgEventSegEl: function(seg, el) {\\n\\t\\treturn this.view.resolveEventEl(seg.event, el); // will filter through eventRender\\n\\t},\\n\\n\\n\\t// Generates an array of classNames to be used for the default rendering of a background event.\\n\\t// Called by fillSegHtml.\\n\\tbgEventSegClasses: function(seg) {\\n\\t\\tvar event = seg.event;\\n\\t\\tvar source = event.source || {};\\n\\n\\t\\treturn [ 'fc-bgevent' ].concat(\\n\\t\\t\\tevent.className,\\n\\t\\t\\tsource.className || []\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.\\n\\t// Called by fillSegHtml.\\n\\tbgEventSegCss: function(seg) {\\n\\t\\treturn {\\n\\t\\t\\t'background-color': this.getSegSkinCss(seg)['background-color']\\n\\t\\t};\\n\\t},\\n\\n\\n\\t// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.\\n\\t// Called by fillSegHtml.\\n\\tbusinessHoursSegClasses: function(seg) {\\n\\t\\treturn [ 'fc-nonbusiness', 'fc-bgevent' ];\\n\\t},\\n\\n\\n\\t/* Business Hours\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Compute business hour segs for the grid's current date range.\\n\\t// Caller must ask if whole-day business hours are needed.\\n\\t// If no `businessHours` configuration value is specified, assumes the calendar default.\\n\\tbuildBusinessHourSegs: function(wholeDay, businessHours) {\\n\\t\\treturn this.eventsToSegs(\\n\\t\\t\\tthis.buildBusinessHourEvents(wholeDay, businessHours)\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Compute business hour *events* for the grid's current date range.\\n\\t// Caller must ask if whole-day business hours are needed.\\n\\t// If no `businessHours` configuration value is specified, assumes the calendar default.\\n\\tbuildBusinessHourEvents: function(wholeDay, businessHours) {\\n\\t\\tvar calendar = this.view.calendar;\\n\\t\\tvar events;\\n\\n\\t\\tif (businessHours == null) {\\n\\t\\t\\t// fallback\\n\\t\\t\\t// access from calendawr. don't access from view. doesn't update with dynamic options.\\n\\t\\t\\tbusinessHours = calendar.opt('businessHours');\\n\\t\\t}\\n\\n\\t\\tevents = calendar.computeBusinessHourEvents(wholeDay, businessHours);\\n\\n\\t\\t// HACK. Eventually refactor business hours \\\"events\\\" system.\\n\\t\\t// If no events are given, but businessHours is activated, this means the entire visible range should be\\n\\t\\t// marked as *not* business-hours, via inverse-background rendering.\\n\\t\\tif (!events.length && businessHours) {\\n\\t\\t\\tevents = [\\n\\t\\t\\t\\t$.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {\\n\\t\\t\\t\\t\\tstart: this.view.activeRange.end, // guaranteed out-of-range\\n\\t\\t\\t\\t\\tend: this.view.activeRange.end,   // \\\"\\n\\t\\t\\t\\t\\tdow: null\\n\\t\\t\\t\\t})\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\treturn events;\\n\\t},\\n\\n\\n\\t/* Handlers\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Attaches event-element-related handlers for *all* rendered event segments of the view.\\n\\tbindSegHandlers: function() {\\n\\t\\tthis.bindSegHandlersToEl(this.el);\\n\\t},\\n\\n\\n\\t// Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.\\n\\tbindSegHandlersToEl: function(el) {\\n\\t\\tthis.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);\\n\\t\\tthis.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);\\n\\t\\tthis.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);\\n\\t\\tthis.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);\\n\\t\\tthis.bindSegHandlerToEl(el, 'click', this.handleSegClick);\\n\\t},\\n\\n\\n\\t// Executes a handler for any a user-interaction on a segment.\\n\\t// Handler gets called with (seg, ev), and with the `this` context of the Grid\\n\\tbindSegHandlerToEl: function(el, name, handler) {\\n\\t\\tvar _this = this;\\n\\n\\t\\tel.on(name, this.segSelector, function(ev) {\\n\\t\\t\\tvar seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents\\n\\n\\t\\t\\t// only call the handlers if there is not a drag/resize in progress\\n\\t\\t\\tif (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {\\n\\t\\t\\t\\treturn handler.call(_this, seg, ev); // context will be the Grid\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\n\\thandleSegClick: function(seg, ev) {\\n\\t\\tvar res = this.view.publiclyTrigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel\\n\\t\\tif (res === false) {\\n\\t\\t\\tev.preventDefault();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Updates internal state and triggers handlers for when an event element is moused over\\n\\thandleSegMouseover: function(seg, ev) {\\n\\t\\tif (\\n\\t\\t\\t!GlobalEmitter.get().shouldIgnoreMouse() &&\\n\\t\\t\\t!this.mousedOverSeg\\n\\t\\t) {\\n\\t\\t\\tthis.mousedOverSeg = seg;\\n\\t\\t\\tif (this.view.isEventResizable(seg.event)) {\\n\\t\\t\\t\\tseg.el.addClass('fc-allow-mouse-resize');\\n\\t\\t\\t}\\n\\t\\t\\tthis.view.publiclyTrigger('eventMouseover', seg.el[0], seg.event, ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Updates internal state and triggers handlers for when an event element is moused out.\\n\\t// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\\n\\thandleSegMouseout: function(seg, ev) {\\n\\t\\tev = ev || {}; // if given no args, make a mock mouse event\\n\\n\\t\\tif (this.mousedOverSeg) {\\n\\t\\t\\tseg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment\\n\\t\\t\\tthis.mousedOverSeg = null;\\n\\t\\t\\tif (this.view.isEventResizable(seg.event)) {\\n\\t\\t\\t\\tseg.el.removeClass('fc-allow-mouse-resize');\\n\\t\\t\\t}\\n\\t\\t\\tthis.view.publiclyTrigger('eventMouseout', seg.el[0], seg.event, ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\thandleSegMousedown: function(seg, ev) {\\n\\t\\tvar isResizing = this.startSegResize(seg, ev, { distance: 5 });\\n\\n\\t\\tif (!isResizing && this.view.isEventDraggable(seg.event)) {\\n\\t\\t\\tthis.buildSegDragListener(seg)\\n\\t\\t\\t\\t.startInteraction(ev, {\\n\\t\\t\\t\\t\\tdistance: 5\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\n\\thandleSegTouchStart: function(seg, ev) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar event = seg.event;\\n\\t\\tvar isSelected = view.isEventSelected(event);\\n\\t\\tvar isDraggable = view.isEventDraggable(event);\\n\\t\\tvar isResizable = view.isEventResizable(event);\\n\\t\\tvar isResizing = false;\\n\\t\\tvar dragListener;\\n\\t\\tvar eventLongPressDelay;\\n\\n\\t\\tif (isSelected && isResizable) {\\n\\t\\t\\t// only allow resizing of the event is selected\\n\\t\\t\\tisResizing = this.startSegResize(seg, ev);\\n\\t\\t}\\n\\n\\t\\tif (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?\\n\\n\\t\\t\\teventLongPressDelay = view.opt('eventLongPressDelay');\\n\\t\\t\\tif (eventLongPressDelay == null) {\\n\\t\\t\\t\\teventLongPressDelay = view.opt('longPressDelay'); // fallback\\n\\t\\t\\t}\\n\\n\\t\\t\\tdragListener = isDraggable ?\\n\\t\\t\\t\\tthis.buildSegDragListener(seg) :\\n\\t\\t\\t\\tthis.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected\\n\\n\\t\\t\\tdragListener.startInteraction(ev, { // won't start if already started\\n\\t\\t\\t\\tdelay: isSelected ? 0 : eventLongPressDelay // do delay if not already selected\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// returns boolean whether resizing actually started or not.\\n\\t// assumes the seg allows resizing.\\n\\t// `dragOptions` are optional.\\n\\tstartSegResize: function(seg, ev, dragOptions) {\\n\\t\\tif ($(ev.target).is('.fc-resizer')) {\\n\\t\\t\\tthis.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))\\n\\t\\t\\t\\t.startInteraction(ev, dragOptions);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t},\\n\\n\\n\\n\\t/* Event Dragging\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Builds a listener that will track user-dragging on an event segment.\\n\\t// Generic enough to work with any type of Grid.\\n\\t// Has side effect of setting/unsetting `segDragListener`\\n\\tbuildSegDragListener: function(seg) {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\t\\tvar el = seg.el;\\n\\t\\tvar event = seg.event;\\n\\t\\tvar isDragging;\\n\\t\\tvar mouseFollower; // A clone of the original element that will move with the mouse\\n\\t\\tvar dropLocation; // zoned event date properties\\n\\n\\t\\tif (this.segDragListener) {\\n\\t\\t\\treturn this.segDragListener;\\n\\t\\t}\\n\\n\\t\\t// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\\n\\t\\t// of the view.\\n\\t\\tvar dragListener = this.segDragListener = new HitDragListener(view, {\\n\\t\\t\\tscroll: view.opt('dragScroll'),\\n\\t\\t\\tsubjectEl: el,\\n\\t\\t\\tsubjectCenter: true,\\n\\t\\t\\tinteractionStart: function(ev) {\\n\\t\\t\\t\\tseg.component = _this; // for renderDrag\\n\\t\\t\\t\\tisDragging = false;\\n\\t\\t\\t\\tmouseFollower = new MouseFollower(seg.el, {\\n\\t\\t\\t\\t\\tadditionalClass: 'fc-dragging',\\n\\t\\t\\t\\t\\tparentEl: view.el,\\n\\t\\t\\t\\t\\topacity: dragListener.isTouch ? null : view.opt('dragOpacity'),\\n\\t\\t\\t\\t\\trevertDuration: view.opt('dragRevertDuration'),\\n\\t\\t\\t\\t\\tzIndex: 2 // one above the .fc-view\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tmouseFollower.hide(); // don't show until we know this is a real drag\\n\\t\\t\\t\\tmouseFollower.start(ev);\\n\\t\\t\\t},\\n\\t\\t\\tdragStart: function(ev) {\\n\\t\\t\\t\\tif (dragListener.isTouch && !view.isEventSelected(event)) {\\n\\t\\t\\t\\t\\t// if not previously selected, will fire after a delay. then, select the event\\n\\t\\t\\t\\t\\tview.selectEvent(event);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisDragging = true;\\n\\t\\t\\t\\t_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\\n\\t\\t\\t\\t_this.segDragStart(seg, ev);\\n\\t\\t\\t\\tview.hideEvent(event); // hide all event segments. our mouseFollower will take over\\n\\t\\t\\t},\\n\\t\\t\\thitOver: function(hit, isOrig, origHit) {\\n\\t\\t\\t\\tvar isAllowed = true;\\n\\t\\t\\t\\tvar origHitSpan;\\n\\t\\t\\t\\tvar hitSpan;\\n\\t\\t\\t\\tvar dragHelperEls;\\n\\n\\t\\t\\t\\t// starting hit could be forced (DayGrid.limit)\\n\\t\\t\\t\\tif (seg.hit) {\\n\\t\\t\\t\\t\\torigHit = seg.hit;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// hit might not belong to this grid, so query origin grid\\n\\t\\t\\t\\torigHitSpan = origHit.component.getSafeHitSpan(origHit);\\n\\t\\t\\t\\thitSpan = hit.component.getSafeHitSpan(hit);\\n\\n\\t\\t\\t\\tif (origHitSpan && hitSpan) {\\n\\t\\t\\t\\t\\tdropLocation = _this.computeEventDrop(origHitSpan, hitSpan, event);\\n\\t\\t\\t\\t\\tisAllowed = dropLocation && _this.isEventLocationAllowed(dropLocation, event);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tisAllowed = false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!isAllowed) {\\n\\t\\t\\t\\t\\tdropLocation = null;\\n\\t\\t\\t\\t\\tdisableCursor();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if a valid drop location, have the subclass render a visual indication\\n\\t\\t\\t\\tif (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {\\n\\n\\t\\t\\t\\t\\tdragHelperEls.addClass('fc-dragging');\\n\\t\\t\\t\\t\\tif (!dragListener.isTouch) {\\n\\t\\t\\t\\t\\t\\t_this.applyDragOpacity(dragHelperEls);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmouseFollower.hide(); // if the subclass is already using a mock event \\\"helper\\\", hide our own\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tmouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (isOrig) {\\n\\t\\t\\t\\t\\tdropLocation = null; // needs to have moved hits to be a valid drop\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\\n\\t\\t\\t\\tview.unrenderDrag(); // unrender whatever was done in renderDrag\\n\\t\\t\\t\\tmouseFollower.show(); // show in case we are moving out of all hits\\n\\t\\t\\t\\tdropLocation = null;\\n\\t\\t\\t},\\n\\t\\t\\thitDone: function() { // Called after a hitOut OR before a dragEnd\\n\\t\\t\\t\\tenableCursor();\\n\\t\\t\\t},\\n\\t\\t\\tinteractionEnd: function(ev) {\\n\\t\\t\\t\\tdelete seg.component; // prevent side effects\\n\\n\\t\\t\\t\\t// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\\n\\t\\t\\t\\tmouseFollower.stop(!dropLocation, function() {\\n\\t\\t\\t\\t\\tif (isDragging) {\\n\\t\\t\\t\\t\\t\\tview.unrenderDrag();\\n\\t\\t\\t\\t\\t\\t_this.segDragStop(seg, ev);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (dropLocation) {\\n\\t\\t\\t\\t\\t\\t// no need to re-show original, will rerender all anyways. esp important if eventRenderWait\\n\\t\\t\\t\\t\\t\\tview.reportSegDrop(seg, dropLocation, _this.largeUnit, el, ev);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tview.showEvent(event);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\t_this.segDragListener = null;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn dragListener;\\n\\t},\\n\\n\\n\\t// seg isn't draggable, but let's use a generic DragListener\\n\\t// simply for the delay, so it can be selected.\\n\\t// Has side effect of setting/unsetting `segDragListener`\\n\\tbuildSegSelectListener: function(seg) {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\t\\tvar event = seg.event;\\n\\n\\t\\tif (this.segDragListener) {\\n\\t\\t\\treturn this.segDragListener;\\n\\t\\t}\\n\\n\\t\\tvar dragListener = this.segDragListener = new DragListener({\\n\\t\\t\\tdragStart: function(ev) {\\n\\t\\t\\t\\tif (dragListener.isTouch && !view.isEventSelected(event)) {\\n\\t\\t\\t\\t\\t// if not previously selected, will fire after a delay. then, select the event\\n\\t\\t\\t\\t\\tview.selectEvent(event);\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tinteractionEnd: function(ev) {\\n\\t\\t\\t\\t_this.segDragListener = null;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn dragListener;\\n\\t},\\n\\n\\n\\t// Called before event segment dragging starts\\n\\tsegDragStart: function(seg, ev) {\\n\\t\\tthis.isDraggingSeg = true;\\n\\t\\tthis.view.publiclyTrigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\\n\\t},\\n\\n\\n\\t// Called after event segment dragging stops\\n\\tsegDragStop: function(seg, ev) {\\n\\t\\tthis.isDraggingSeg = false;\\n\\t\\tthis.view.publiclyTrigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\\n\\t},\\n\\n\\n\\t// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay\\n\\t// values for the event. Subclasses may override and set additional properties to be used by renderDrag.\\n\\t// A falsy returned value indicates an invalid drop.\\n\\t// DOES NOT consider overlap/constraint.\\n\\tcomputeEventDrop: function(startSpan, endSpan, event) {\\n\\t\\tvar calendar = this.view.calendar;\\n\\t\\tvar dragStart = startSpan.start;\\n\\t\\tvar dragEnd = endSpan.start;\\n\\t\\tvar delta;\\n\\t\\tvar dropLocation; // zoned event date properties\\n\\n\\t\\tif (dragStart.hasTime() === dragEnd.hasTime()) {\\n\\t\\t\\tdelta = this.diffDates(dragEnd, dragStart);\\n\\n\\t\\t\\t// if an all-day event was in a timed area and it was dragged to a different time,\\n\\t\\t\\t// guarantee an end and adjust start/end to have times\\n\\t\\t\\tif (event.allDay && durationHasTime(delta)) {\\n\\t\\t\\t\\tdropLocation = {\\n\\t\\t\\t\\t\\tstart: event.start.clone(),\\n\\t\\t\\t\\t\\tend: calendar.getEventEnd(event), // will be an ambig day\\n\\t\\t\\t\\t\\tallDay: false // for normalizeEventTimes\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tcalendar.normalizeEventTimes(dropLocation);\\n\\t\\t\\t}\\n\\t\\t\\t// othewise, work off existing values\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdropLocation = pluckEventDateProps(event);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdropLocation.start.add(delta);\\n\\t\\t\\tif (dropLocation.end) {\\n\\t\\t\\t\\tdropLocation.end.add(delta);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared\\n\\t\\t\\tdropLocation = {\\n\\t\\t\\t\\tstart: dragEnd.clone(),\\n\\t\\t\\t\\tend: null, // end should be cleared\\n\\t\\t\\t\\tallDay: !dragEnd.hasTime()\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn dropLocation;\\n\\t},\\n\\n\\n\\t// Utility for apply dragOpacity to a jQuery set\\n\\tapplyDragOpacity: function(els) {\\n\\t\\tvar opacity = this.view.opt('dragOpacity');\\n\\n\\t\\tif (opacity != null) {\\n\\t\\t\\tels.css('opacity', opacity);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* External Element Dragging\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Called when a jQuery UI drag is initiated anywhere in the DOM\\n\\texternalDragStart: function(ev, ui) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar el;\\n\\t\\tvar accept;\\n\\n\\t\\tif (view.opt('droppable')) { // only listen if this setting is on\\n\\t\\t\\tel = $((ui ? ui.item : null) || ev.target);\\n\\n\\t\\t\\t// Test that the dragged element passes the dropAccept selector or filter function.\\n\\t\\t\\t// FYI, the default is \\\"*\\\" (matches all)\\n\\t\\t\\taccept = view.opt('dropAccept');\\n\\t\\t\\tif ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\\n\\t\\t\\t\\tif (!this.isDraggingExternal) { // prevent double-listening if fired twice\\n\\t\\t\\t\\t\\tthis.listenToExternalDrag(el, ev, ui);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Called when a jQuery UI drag starts and it needs to be monitored for dropping\\n\\tlistenToExternalDrag: function(el, ev, ui) {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\t\\tvar meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\\n\\t\\tvar dropLocation; // a null value signals an unsuccessful drag\\n\\n\\t\\t// listener that tracks mouse movement over date-associated pixel regions\\n\\t\\tvar dragListener = _this.externalDragListener = new HitDragListener(this, {\\n\\t\\t\\tinteractionStart: function() {\\n\\t\\t\\t\\t_this.isDraggingExternal = true;\\n\\t\\t\\t},\\n\\t\\t\\thitOver: function(hit) {\\n\\t\\t\\t\\tvar isAllowed = true;\\n\\t\\t\\t\\tvar hitSpan = hit.component.getSafeHitSpan(hit); // hit might not belong to this grid\\n\\n\\t\\t\\t\\tif (hitSpan) {\\n\\t\\t\\t\\t\\tdropLocation = _this.computeExternalDrop(hitSpan, meta);\\n\\t\\t\\t\\t\\tisAllowed = dropLocation && _this.isExternalLocationAllowed(dropLocation, meta.eventProps);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tisAllowed = false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!isAllowed) {\\n\\t\\t\\t\\t\\tdropLocation = null;\\n\\t\\t\\t\\t\\tdisableCursor();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (dropLocation) {\\n\\t\\t\\t\\t\\t_this.renderDrag(dropLocation); // called without a seg parameter\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\thitOut: function() {\\n\\t\\t\\t\\tdropLocation = null; // signal unsuccessful\\n\\t\\t\\t},\\n\\t\\t\\thitDone: function() { // Called after a hitOut OR before a dragEnd\\n\\t\\t\\t\\tenableCursor();\\n\\t\\t\\t\\t_this.unrenderDrag();\\n\\t\\t\\t},\\n\\t\\t\\tinteractionEnd: function(ev) {\\n\\t\\t\\t\\tif (dropLocation) { // element was dropped on a valid hit\\n\\t\\t\\t\\t\\tview.reportExternalDrop(meta, dropLocation, el, ev, ui);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_this.isDraggingExternal = false;\\n\\t\\t\\t\\t_this.externalDragListener = null;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tdragListener.startDrag(ev); // start listening immediately\\n\\t},\\n\\n\\n\\t// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\\n\\t// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\\n\\t// Returning a null value signals an invalid drop hit.\\n\\t// DOES NOT consider overlap/constraint.\\n\\tcomputeExternalDrop: function(span, meta) {\\n\\t\\tvar calendar = this.view.calendar;\\n\\t\\tvar dropLocation = {\\n\\t\\t\\tstart: calendar.applyTimezone(span.start), // simulate a zoned event start date\\n\\t\\t\\tend: null\\n\\t\\t};\\n\\n\\t\\t// if dropped on an all-day span, and element's metadata specified a time, set it\\n\\t\\tif (meta.startTime && !dropLocation.start.hasTime()) {\\n\\t\\t\\tdropLocation.start.time(meta.startTime);\\n\\t\\t}\\n\\n\\t\\tif (meta.duration) {\\n\\t\\t\\tdropLocation.end = dropLocation.start.clone().add(meta.duration);\\n\\t\\t}\\n\\n\\t\\treturn dropLocation;\\n\\t},\\n\\n\\n\\n\\t/* Drag Rendering (for both events and an external elements)\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of an event or external element being dragged.\\n\\t// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.\\n\\t// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.\\n\\t// A truthy returned value indicates this method has rendered a helper element.\\n\\t// Must return elements used for any mock events.\\n\\trenderDrag: function(dropLocation, seg) {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Unrenders a visual indication of an event or external element being dragged\\n\\tunrenderDrag: function() {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t/* Resizing\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Creates a listener that tracks the user as they resize an event segment.\\n\\t// Generic enough to work with any type of Grid.\\n\\tbuildSegResizeListener: function(seg, isStart) {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\t\\tvar calendar = view.calendar;\\n\\t\\tvar el = seg.el;\\n\\t\\tvar event = seg.event;\\n\\t\\tvar eventEnd = calendar.getEventEnd(event);\\n\\t\\tvar isDragging;\\n\\t\\tvar resizeLocation; // zoned event date properties. falsy if invalid resize\\n\\n\\t\\t// Tracks mouse movement over the *grid's* coordinate map\\n\\t\\tvar dragListener = this.segResizeListener = new HitDragListener(this, {\\n\\t\\t\\tscroll: view.opt('dragScroll'),\\n\\t\\t\\tsubjectEl: el,\\n\\t\\t\\tinteractionStart: function() {\\n\\t\\t\\t\\tisDragging = false;\\n\\t\\t\\t},\\n\\t\\t\\tdragStart: function(ev) {\\n\\t\\t\\t\\tisDragging = true;\\n\\t\\t\\t\\t_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\\n\\t\\t\\t\\t_this.segResizeStart(seg, ev);\\n\\t\\t\\t},\\n\\t\\t\\thitOver: function(hit, isOrig, origHit) {\\n\\t\\t\\t\\tvar isAllowed = true;\\n\\t\\t\\t\\tvar origHitSpan = _this.getSafeHitSpan(origHit);\\n\\t\\t\\t\\tvar hitSpan = _this.getSafeHitSpan(hit);\\n\\n\\t\\t\\t\\tif (origHitSpan && hitSpan) {\\n\\t\\t\\t\\t\\tresizeLocation = isStart ?\\n\\t\\t\\t\\t\\t\\t_this.computeEventStartResize(origHitSpan, hitSpan, event) :\\n\\t\\t\\t\\t\\t\\t_this.computeEventEndResize(origHitSpan, hitSpan, event);\\n\\n\\t\\t\\t\\t\\tisAllowed = resizeLocation && _this.isEventLocationAllowed(resizeLocation, event);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tisAllowed = false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!isAllowed) {\\n\\t\\t\\t\\t\\tresizeLocation = null;\\n\\t\\t\\t\\t\\tdisableCursor();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\tresizeLocation.start.isSame(event.start.clone().stripZone()) &&\\n\\t\\t\\t\\t\\t\\tresizeLocation.end.isSame(eventEnd.clone().stripZone())\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t// no change. (FYI, event dates might have zones)\\n\\t\\t\\t\\t\\t\\tresizeLocation = null;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (resizeLocation) {\\n\\t\\t\\t\\t\\tview.hideEvent(event);\\n\\t\\t\\t\\t\\t_this.renderEventResize(resizeLocation, seg);\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\\n\\t\\t\\t\\tresizeLocation = null;\\n\\t\\t\\t\\tview.showEvent(event); // for when out-of-bounds. show original\\n\\t\\t\\t},\\n\\t\\t\\thitDone: function() { // resets the rendering to show the original event\\n\\t\\t\\t\\t_this.unrenderEventResize();\\n\\t\\t\\t\\tenableCursor();\\n\\t\\t\\t},\\n\\t\\t\\tinteractionEnd: function(ev) {\\n\\t\\t\\t\\tif (isDragging) {\\n\\t\\t\\t\\t\\t_this.segResizeStop(seg, ev);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (resizeLocation) { // valid date to resize to?\\n\\t\\t\\t\\t\\t// no need to re-show original, will rerender all anyways. esp important if eventRenderWait\\n\\t\\t\\t\\t\\tview.reportSegResize(seg, resizeLocation, _this.largeUnit, el, ev);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tview.showEvent(event);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_this.segResizeListener = null;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn dragListener;\\n\\t},\\n\\n\\n\\t// Called before event segment resizing starts\\n\\tsegResizeStart: function(seg, ev) {\\n\\t\\tthis.isResizingSeg = true;\\n\\t\\tthis.view.publiclyTrigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\\n\\t},\\n\\n\\n\\t// Called after event segment resizing stops\\n\\tsegResizeStop: function(seg, ev) {\\n\\t\\tthis.isResizingSeg = false;\\n\\t\\tthis.view.publiclyTrigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\\n\\t},\\n\\n\\n\\t// Returns new date-information for an event segment being resized from its start\\n\\tcomputeEventStartResize: function(startSpan, endSpan, event) {\\n\\t\\treturn this.computeEventResize('start', startSpan, endSpan, event);\\n\\t},\\n\\n\\n\\t// Returns new date-information for an event segment being resized from its end\\n\\tcomputeEventEndResize: function(startSpan, endSpan, event) {\\n\\t\\treturn this.computeEventResize('end', startSpan, endSpan, event);\\n\\t},\\n\\n\\n\\t// Returns new zoned date information for an event segment being resized from its start OR end\\n\\t// `type` is either 'start' or 'end'.\\n\\t// DOES NOT consider overlap/constraint.\\n\\tcomputeEventResize: function(type, startSpan, endSpan, event) {\\n\\t\\tvar calendar = this.view.calendar;\\n\\t\\tvar delta = this.diffDates(endSpan[type], startSpan[type]);\\n\\t\\tvar resizeLocation; // zoned event date properties\\n\\t\\tvar defaultDuration;\\n\\n\\t\\t// build original values to work from, guaranteeing a start and end\\n\\t\\tresizeLocation = {\\n\\t\\t\\tstart: event.start.clone(),\\n\\t\\t\\tend: calendar.getEventEnd(event),\\n\\t\\t\\tallDay: event.allDay\\n\\t\\t};\\n\\n\\t\\t// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times\\n\\t\\tif (resizeLocation.allDay && durationHasTime(delta)) {\\n\\t\\t\\tresizeLocation.allDay = false;\\n\\t\\t\\tcalendar.normalizeEventTimes(resizeLocation);\\n\\t\\t}\\n\\n\\t\\tresizeLocation[type].add(delta); // apply delta to start or end\\n\\n\\t\\t// if the event was compressed too small, find a new reasonable duration for it\\n\\t\\tif (!resizeLocation.start.isBefore(resizeLocation.end)) {\\n\\n\\t\\t\\tdefaultDuration =\\n\\t\\t\\t\\tthis.minResizeDuration || // TODO: hack\\n\\t\\t\\t\\t(event.allDay ?\\n\\t\\t\\t\\t\\tcalendar.defaultAllDayEventDuration :\\n\\t\\t\\t\\t\\tcalendar.defaultTimedEventDuration);\\n\\n\\t\\t\\tif (type == 'start') { // resizing the start?\\n\\t\\t\\t\\tresizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);\\n\\t\\t\\t}\\n\\t\\t\\telse { // resizing the end?\\n\\t\\t\\t\\tresizeLocation.end = resizeLocation.start.clone().add(defaultDuration);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn resizeLocation;\\n\\t},\\n\\n\\n\\t// Renders a visual indication of an event being resized.\\n\\t// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.\\n\\t// Must return elements used for any mock events.\\n\\trenderEventResize: function(range, seg) {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Unrenders a visual indication of an event being resized.\\n\\tunrenderEventResize: function() {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t/* Rendering Utils\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Compute the text that should be displayed on an event's element.\\n\\t// `range` can be the Event object itself, or something range-like, with at least a `start`.\\n\\t// If event times are disabled, or the event has no time, will return a blank string.\\n\\t// If not specified, formatStr will default to the eventTimeFormat setting,\\n\\t// and displayEnd will default to the displayEventEnd setting.\\n\\tgetEventTimeText: function(range, formatStr, displayEnd) {\\n\\n\\t\\tif (formatStr == null) {\\n\\t\\t\\tformatStr = this.eventTimeFormat;\\n\\t\\t}\\n\\n\\t\\tif (displayEnd == null) {\\n\\t\\t\\tdisplayEnd = this.displayEventEnd;\\n\\t\\t}\\n\\n\\t\\tif (this.displayEventTime && range.start.hasTime()) {\\n\\t\\t\\tif (displayEnd && range.end) {\\n\\t\\t\\t\\treturn this.view.formatRange(range, formatStr);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn range.start.format(formatStr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t},\\n\\n\\n\\t// Generic utility for generating the HTML classNames for an event segment's element\\n\\tgetSegClasses: function(seg, isDraggable, isResizable) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar classes = [\\n\\t\\t\\t'fc-event',\\n\\t\\t\\tseg.isStart ? 'fc-start' : 'fc-not-start',\\n\\t\\t\\tseg.isEnd ? 'fc-end' : 'fc-not-end'\\n\\t\\t].concat(this.getSegCustomClasses(seg));\\n\\n\\t\\tif (isDraggable) {\\n\\t\\t\\tclasses.push('fc-draggable');\\n\\t\\t}\\n\\t\\tif (isResizable) {\\n\\t\\t\\tclasses.push('fc-resizable');\\n\\t\\t}\\n\\n\\t\\t// event is currently selected? attach a className.\\n\\t\\tif (view.isEventSelected(seg.event)) {\\n\\t\\t\\tclasses.push('fc-selected');\\n\\t\\t}\\n\\n\\t\\treturn classes;\\n\\t},\\n\\n\\n\\t// List of classes that were defined by the caller of the API in some way\\n\\tgetSegCustomClasses: function(seg) {\\n\\t\\tvar event = seg.event;\\n\\n\\t\\treturn [].concat(\\n\\t\\t\\tevent.className, // guaranteed to be an array\\n\\t\\t\\tevent.source ? event.source.className : []\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Utility for generating event skin-related CSS properties\\n\\tgetSegSkinCss: function(seg) {\\n\\t\\treturn {\\n\\t\\t\\t'background-color': this.getSegBackgroundColor(seg),\\n\\t\\t\\t'border-color': this.getSegBorderColor(seg),\\n\\t\\t\\tcolor: this.getSegTextColor(seg)\\n\\t\\t};\\n\\t},\\n\\n\\n\\t// Queries for caller-specified color, then falls back to default\\n\\tgetSegBackgroundColor: function(seg) {\\n\\t\\treturn seg.event.backgroundColor ||\\n\\t\\t\\tseg.event.color ||\\n\\t\\t\\tthis.getSegDefaultBackgroundColor(seg);\\n\\t},\\n\\n\\n\\tgetSegDefaultBackgroundColor: function(seg) {\\n\\t\\tvar source = seg.event.source || {};\\n\\n\\t\\treturn source.backgroundColor ||\\n\\t\\t\\tsource.color ||\\n\\t\\t\\tthis.view.opt('eventBackgroundColor') ||\\n\\t\\t\\tthis.view.opt('eventColor');\\n\\t},\\n\\n\\n\\t// Queries for caller-specified color, then falls back to default\\n\\tgetSegBorderColor: function(seg) {\\n\\t\\treturn seg.event.borderColor ||\\n\\t\\t\\tseg.event.color ||\\n\\t\\t\\tthis.getSegDefaultBorderColor(seg);\\n\\t},\\n\\n\\n\\tgetSegDefaultBorderColor: function(seg) {\\n\\t\\tvar source = seg.event.source || {};\\n\\n\\t\\treturn source.borderColor ||\\n\\t\\t\\tsource.color ||\\n\\t\\t\\tthis.view.opt('eventBorderColor') ||\\n\\t\\t\\tthis.view.opt('eventColor');\\n\\t},\\n\\n\\n\\t// Queries for caller-specified color, then falls back to default\\n\\tgetSegTextColor: function(seg) {\\n\\t\\treturn seg.event.textColor ||\\n\\t\\t\\tthis.getSegDefaultTextColor(seg);\\n\\t},\\n\\n\\n\\tgetSegDefaultTextColor: function(seg) {\\n\\t\\tvar source = seg.event.source || {};\\n\\n\\t\\treturn source.textColor ||\\n\\t\\t\\tthis.view.opt('eventTextColor');\\n\\t},\\n\\n\\n\\t/* Event Location Validation\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tisEventLocationAllowed: function(eventLocation, event) {\\n\\t\\tif (this.isEventLocationInRange(eventLocation)) {\\n\\t\\t\\tvar calendar = this.view.calendar;\\n\\t\\t\\tvar eventSpans = this.eventToSpans(eventLocation);\\n\\t\\t\\tvar i;\\n\\n\\t\\t\\tif (eventSpans.length) {\\n\\t\\t\\t\\tfor (i = 0; i < eventSpans.length; i++) {\\n\\t\\t\\t\\t\\tif (!calendar.isEventSpanAllowed(eventSpans[i], event)) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\n\\tisExternalLocationAllowed: function(eventLocation, metaProps) { // FOR the external element\\n\\t\\tif (this.isEventLocationInRange(eventLocation)) {\\n\\t\\t\\tvar calendar = this.view.calendar;\\n\\t\\t\\tvar eventSpans = this.eventToSpans(eventLocation);\\n\\t\\t\\tvar i;\\n\\n\\t\\t\\tif (eventSpans.length) {\\n\\t\\t\\t\\tfor (i = 0; i < eventSpans.length; i++) {\\n\\t\\t\\t\\t\\tif (!calendar.isExternalSpanAllowed(eventSpans[i], eventLocation, metaProps)) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\n\\tisEventLocationInRange: function(eventLocation) {\\n\\t\\treturn isRangeWithinRange(\\n\\t\\t\\tthis.eventToRawRange(eventLocation),\\n\\t\\t\\tthis.view.validRange\\n\\t\\t);\\n\\t},\\n\\n\\n\\t/* Converting events -> eventRange -> eventSpan -> eventSegs\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Generates an array of segments for the given single event\\n\\t// Can accept an event \\\"location\\\" as well (which only has start/end and no allDay)\\n\\teventToSegs: function(event) {\\n\\t\\treturn this.eventsToSegs([ event ]);\\n\\t},\\n\\n\\n\\t// Generates spans (always unzoned) for the given event.\\n\\t// Does not do any inverting for inverse-background events.\\n\\t// Can accept an event \\\"location\\\" as well (which only has start/end and no allDay)\\n\\teventToSpans: function(event) {\\n\\t\\tvar eventRange = this.eventToRange(event); // { start, end, isStart, isEnd }\\n\\n\\t\\tif (eventRange) {\\n\\t\\t\\treturn this.eventRangeToSpans(eventRange, event);\\n\\t\\t}\\n\\t\\telse { // out of view's valid range\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\t},\\n\\n\\n\\n\\t// Converts an array of event objects into an array of event segment objects.\\n\\t// A custom `segSliceFunc` may be given for arbitrarily slicing up events.\\n\\t// Doesn't guarantee an order for the resulting array.\\n\\teventsToSegs: function(allEvents, segSliceFunc) {\\n\\t\\tvar _this = this;\\n\\t\\tvar eventsById = groupEventsById(allEvents);\\n\\t\\tvar segs = [];\\n\\n\\t\\t$.each(eventsById, function(id, events) {\\n\\t\\t\\tvar visibleEvents = [];\\n\\t\\t\\tvar eventRanges = [];\\n\\t\\t\\tvar eventRange; // { start, end, isStart, isEnd }\\n\\t\\t\\tvar i;\\n\\n\\t\\t\\tfor (i = 0; i < events.length; i++) {\\n\\t\\t\\t\\teventRange = _this.eventToRange(events[i]); // might be null if completely out of range\\n\\n\\t\\t\\t\\tif (eventRange) {\\n\\t\\t\\t\\t\\teventRanges.push(eventRange);\\n\\t\\t\\t\\t\\tvisibleEvents.push(events[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// inverse-background events (utilize only the first event in calculations)\\n\\t\\t\\tif (isInverseBgEvent(events[0])) {\\n\\t\\t\\t\\teventRanges = _this.invertRanges(eventRanges); // will lose isStart/isEnd\\n\\n\\t\\t\\t\\tfor (i = 0; i < eventRanges.length; i++) {\\n\\t\\t\\t\\t\\tsegs.push.apply(segs, // append to\\n\\t\\t\\t\\t\\t\\t_this.eventRangeToSegs(eventRanges[i], events[0], segSliceFunc)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// normal event ranges\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (i = 0; i < eventRanges.length; i++) {\\n\\t\\t\\t\\t\\tsegs.push.apply(segs, // append to\\n\\t\\t\\t\\t\\t\\t_this.eventRangeToSegs(eventRanges[i], visibleEvents[i], segSliceFunc)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t// Generates the unzoned start/end dates an event appears to occupy\\n\\t// Can accept an event \\\"location\\\" as well (which only has start/end and no allDay)\\n\\t// returns { start, end, isStart, isEnd }\\n\\t// If the event is completely outside of the grid's valid range, will return undefined.\\n\\teventToRange: function(event) {\\n\\t\\treturn this.refineRawEventRange(\\n\\t\\t\\tthis.eventToRawRange(event)\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Ensures the given range is within the view's activeRange and is correctly localized.\\n\\t// Always returns a result\\n\\trefineRawEventRange: function(rawRange) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar calendar = view.calendar;\\n\\t\\tvar range = intersectRanges(rawRange, view.activeRange);\\n\\n\\t\\tif (range) { // otherwise, event doesn't have valid range\\n\\n\\t\\t\\t// hack: dynamic locale change forgets to upate stored event localed\\n\\t\\t\\tcalendar.localizeMoment(range.start);\\n\\t\\t\\tcalendar.localizeMoment(range.end);\\n\\n\\t\\t\\treturn range;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// not constrained to valid dates\\n\\t// not given localizeMoment hack\\n\\teventToRawRange: function(event) {\\n\\t\\tvar calendar = this.view.calendar;\\n\\t\\tvar start = event.start.clone().stripZone();\\n\\t\\tvar end = (\\n\\t\\t\\t\\tevent.end ?\\n\\t\\t\\t\\t\\tevent.end.clone() :\\n\\t\\t\\t\\t\\t// derive the end from the start and allDay. compute allDay if necessary\\n\\t\\t\\t\\t\\tcalendar.getDefaultEventEnd(\\n\\t\\t\\t\\t\\t\\tevent.allDay != null ?\\n\\t\\t\\t\\t\\t\\t\\tevent.allDay :\\n\\t\\t\\t\\t\\t\\t\\t!event.start.hasTime(),\\n\\t\\t\\t\\t\\t\\tevent.start\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t).stripZone();\\n\\n\\t\\treturn { start: start, end: end };\\n\\t},\\n\\n\\n\\t// Given an event's range (unzoned start/end), and the event itself,\\n\\t// slice into segments (using the segSliceFunc function if specified)\\n\\t// eventRange - { start, end, isStart, isEnd }\\n\\teventRangeToSegs: function(eventRange, event, segSliceFunc) {\\n\\t\\tvar eventSpans = this.eventRangeToSpans(eventRange, event);\\n\\t\\tvar segs = [];\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < eventSpans.length; i++) {\\n\\t\\t\\tsegs.push.apply(segs, // append to\\n\\t\\t\\t\\tthis.eventSpanToSegs(eventSpans[i], event, segSliceFunc)\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t// Given an event's unzoned date range, return an array of eventSpan objects.\\n\\t// eventSpan - { start, end, isStart, isEnd, otherthings... }\\n\\t// Subclasses can override.\\n\\t// Subclasses are obligated to forward eventRange.isStart/isEnd to the resulting spans.\\n\\teventRangeToSpans: function(eventRange, event) {\\n\\t\\treturn [ $.extend({}, eventRange) ]; // copy into a single-item array\\n\\t},\\n\\n\\n\\t// Given an event's span (unzoned start/end and other misc data), and the event itself,\\n\\t// slices into segments and attaches event-derived properties to them.\\n\\t// eventSpan - { start, end, isStart, isEnd, otherthings... }\\n\\teventSpanToSegs: function(eventSpan, event, segSliceFunc) {\\n\\t\\tvar segs = segSliceFunc ? segSliceFunc(eventSpan) : this.spanToSegs(eventSpan);\\n\\t\\tvar i, seg;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\n\\t\\t\\t// the eventSpan's isStart/isEnd takes precedence over the seg's\\n\\t\\t\\tif (!eventSpan.isStart) {\\n\\t\\t\\t\\tseg.isStart = false;\\n\\t\\t\\t}\\n\\t\\t\\tif (!eventSpan.isEnd) {\\n\\t\\t\\t\\tseg.isEnd = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tseg.event = event;\\n\\t\\t\\tseg.eventStartMS = +eventSpan.start; // TODO: not the best name after making spans unzoned\\n\\t\\t\\tseg.eventDurationMS = eventSpan.end - eventSpan.start;\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.\\n\\t// SIDE EFFECT: will mutate the given array and will use its date references.\\n\\tinvertRanges: function(ranges) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar viewStart = view.activeRange.start.clone(); // need a copy\\n\\t\\tvar viewEnd = view.activeRange.end.clone(); // need a copy\\n\\t\\tvar inverseRanges = [];\\n\\t\\tvar start = viewStart; // the end of the previous range. the start of the new range\\n\\t\\tvar i, range;\\n\\n\\t\\t// ranges need to be in order. required for our date-walking algorithm\\n\\t\\tranges.sort(compareRanges);\\n\\n\\t\\tfor (i = 0; i < ranges.length; i++) {\\n\\t\\t\\trange = ranges[i];\\n\\n\\t\\t\\t// add the span of time before the event (if there is any)\\n\\t\\t\\tif (range.start > start) { // compare millisecond time (skip any ambig logic)\\n\\t\\t\\t\\tinverseRanges.push({\\n\\t\\t\\t\\t\\tstart: start,\\n\\t\\t\\t\\t\\tend: range.start\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (range.end > start) {\\n\\t\\t\\t\\tstart = range.end;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// add the span of time after the last event (if there is any)\\n\\t\\tif (start < viewEnd) { // compare millisecond time (skip any ambig logic)\\n\\t\\t\\tinverseRanges.push({\\n\\t\\t\\t\\tstart: start,\\n\\t\\t\\t\\tend: viewEnd\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn inverseRanges;\\n\\t},\\n\\n\\n\\tsortEventSegs: function(segs) {\\n\\t\\tsegs.sort(proxy(this, 'compareEventSegs'));\\n\\t},\\n\\n\\n\\t// A cmp function for determining which segments should take visual priority\\n\\tcompareEventSegs: function(seg1, seg2) {\\n\\t\\treturn seg1.eventStartMS - seg2.eventStartMS || // earlier events go first\\n\\t\\t\\tseg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first\\n\\t\\t\\tseg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)\\n\\t\\t\\tcompareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);\\n\\t}\\n\\n});\\n\\n\\n/* Utilities\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\n\\nfunction pluckEventDateProps(event) {\\n\\treturn {\\n\\t\\tstart: event.start.clone(),\\n\\t\\tend: event.end ? event.end.clone() : null,\\n\\t\\tallDay: event.allDay // keep it the same\\n\\t};\\n}\\nFC.pluckEventDateProps = pluckEventDateProps;\\n\\n\\nfunction isBgEvent(event) { // returns true if background OR inverse-background\\n\\tvar rendering = getEventRendering(event);\\n\\treturn rendering === 'background' || rendering === 'inverse-background';\\n}\\nFC.isBgEvent = isBgEvent; // export\\n\\n\\nfunction isInverseBgEvent(event) {\\n\\treturn getEventRendering(event) === 'inverse-background';\\n}\\n\\n\\nfunction getEventRendering(event) {\\n\\treturn firstDefined((event.source || {}).rendering, event.rendering);\\n}\\n\\n\\nfunction groupEventsById(events) {\\n\\tvar eventsById = {};\\n\\tvar i, event;\\n\\n\\tfor (i = 0; i < events.length; i++) {\\n\\t\\tevent = events[i];\\n\\t\\t(eventsById[event._id] || (eventsById[event._id] = [])).push(event);\\n\\t}\\n\\n\\treturn eventsById;\\n}\\n\\n\\n// A cmp function for determining which non-inverted \\\"ranges\\\" (see above) happen earlier\\nfunction compareRanges(range1, range2) {\\n\\treturn range1.start - range2.start; // earlier ranges go first\\n}\\n\\n\\n/* External-Dragging-Element Data\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\n// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\\n// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\\nFC.dataAttrPrefix = '';\\n\\n// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\\n// to be used for Event Object creation.\\n// A defined `.eventProps`, even when empty, indicates that an event should be created.\\nfunction getDraggedElMeta(el) {\\n\\tvar prefix = FC.dataAttrPrefix;\\n\\tvar eventProps; // properties for creating the event, not related to date/time\\n\\tvar startTime; // a Duration\\n\\tvar duration;\\n\\tvar stick;\\n\\n\\tif (prefix) { prefix += '-'; }\\n\\teventProps = el.data(prefix + 'event') || null;\\n\\n\\tif (eventProps) {\\n\\t\\tif (typeof eventProps === 'object') {\\n\\t\\t\\teventProps = $.extend({}, eventProps); // make a copy\\n\\t\\t}\\n\\t\\telse { // something like 1 or true. still signal event creation\\n\\t\\t\\teventProps = {};\\n\\t\\t}\\n\\n\\t\\t// pluck special-cased date/time properties\\n\\t\\tstartTime = eventProps.start;\\n\\t\\tif (startTime == null) { startTime = eventProps.time; } // accept 'time' as well\\n\\t\\tduration = eventProps.duration;\\n\\t\\tstick = eventProps.stick;\\n\\t\\tdelete eventProps.start;\\n\\t\\tdelete eventProps.time;\\n\\t\\tdelete eventProps.duration;\\n\\t\\tdelete eventProps.stick;\\n\\t}\\n\\n\\t// fallback to standalone attribute values for each of the date/time properties\\n\\tif (startTime == null) { startTime = el.data(prefix + 'start'); }\\n\\tif (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well\\n\\tif (duration == null) { duration = el.data(prefix + 'duration'); }\\n\\tif (stick == null) { stick = el.data(prefix + 'stick'); }\\n\\n\\t// massage into correct data types\\n\\tstartTime = startTime != null ? moment.duration(startTime) : null;\\n\\tduration = duration != null ? moment.duration(duration) : null;\\n\\tstick = Boolean(stick);\\n\\n\\treturn { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };\\n}\\n\\n\\n;;\\n\\n/*\\nA set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\\nPrerequisite: the object being mixed into needs to be a *Grid*\\n*/\\nvar DayTableMixin = FC.DayTableMixin = {\\n\\n\\tbreakOnWeeks: false, // should create a new row for each week?\\n\\tdayDates: null, // whole-day dates for each column. left to right\\n\\tdayIndices: null, // for each day from start, the offset\\n\\tdaysPerRow: null,\\n\\trowCnt: null,\\n\\tcolCnt: null,\\n\\tcolHeadFormat: null,\\n\\n\\n\\t// Populates internal variables used for date calculation and rendering\\n\\tupdateDayTable: function() {\\n\\t\\tvar view = this.view;\\n\\t\\tvar date = this.start.clone();\\n\\t\\tvar dayIndex = -1;\\n\\t\\tvar dayIndices = [];\\n\\t\\tvar dayDates = [];\\n\\t\\tvar daysPerRow;\\n\\t\\tvar firstDay;\\n\\t\\tvar rowCnt;\\n\\n\\t\\twhile (date.isBefore(this.end)) { // loop each day from start to end\\n\\t\\t\\tif (view.isHiddenDay(date)) {\\n\\t\\t\\t\\tdayIndices.push(dayIndex + 0.5); // mark that it's between indices\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdayIndex++;\\n\\t\\t\\t\\tdayIndices.push(dayIndex);\\n\\t\\t\\t\\tdayDates.push(date.clone());\\n\\t\\t\\t}\\n\\t\\t\\tdate.add(1, 'days');\\n\\t\\t}\\n\\n\\t\\tif (this.breakOnWeeks) {\\n\\t\\t\\t// count columns until the day-of-week repeats\\n\\t\\t\\tfirstDay = dayDates[0].day();\\n\\t\\t\\tfor (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\\n\\t\\t\\t\\tif (dayDates[daysPerRow].day() == firstDay) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trowCnt = Math.ceil(dayDates.length / daysPerRow);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\trowCnt = 1;\\n\\t\\t\\tdaysPerRow = dayDates.length;\\n\\t\\t}\\n\\n\\t\\tthis.dayDates = dayDates;\\n\\t\\tthis.dayIndices = dayIndices;\\n\\t\\tthis.daysPerRow = daysPerRow;\\n\\t\\tthis.rowCnt = rowCnt;\\n\\n\\t\\tthis.updateDayTableCols();\\n\\t},\\n\\n\\n\\t// Computes and assigned the colCnt property and updates any options that may be computed from it\\n\\tupdateDayTableCols: function() {\\n\\t\\tthis.colCnt = this.computeColCnt();\\n\\t\\tthis.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();\\n\\t},\\n\\n\\n\\t// Determines how many columns there should be in the table\\n\\tcomputeColCnt: function() {\\n\\t\\treturn this.daysPerRow;\\n\\t},\\n\\n\\n\\t// Computes the ambiguously-timed moment for the given cell\\n\\tgetCellDate: function(row, col) {\\n\\t\\treturn this.dayDates[\\n\\t\\t\\t\\tthis.getCellDayIndex(row, col)\\n\\t\\t\\t].clone();\\n\\t},\\n\\n\\n\\t// Computes the ambiguously-timed date range for the given cell\\n\\tgetCellRange: function(row, col) {\\n\\t\\tvar start = this.getCellDate(row, col);\\n\\t\\tvar end = start.clone().add(1, 'days');\\n\\n\\t\\treturn { start: start, end: end };\\n\\t},\\n\\n\\n\\t// Returns the number of day cells, chronologically, from the first of the grid (0-based)\\n\\tgetCellDayIndex: function(row, col) {\\n\\t\\treturn row * this.daysPerRow + this.getColDayIndex(col);\\n\\t},\\n\\n\\n\\t// Returns the numner of day cells, chronologically, from the first cell in *any given row*\\n\\tgetColDayIndex: function(col) {\\n\\t\\tif (this.isRTL) {\\n\\t\\t\\treturn this.colCnt - 1 - col;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn col;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Given a date, returns its chronolocial cell-index from the first cell of the grid.\\n\\t// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\\n\\t// If before the first offset, returns a negative number.\\n\\t// If after the last offset, returns an offset past the last cell offset.\\n\\t// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\\n\\tgetDateDayIndex: function(date) {\\n\\t\\tvar dayIndices = this.dayIndices;\\n\\t\\tvar dayOffset = date.diff(this.start, 'days');\\n\\n\\t\\tif (dayOffset < 0) {\\n\\t\\t\\treturn dayIndices[0] - 1;\\n\\t\\t}\\n\\t\\telse if (dayOffset >= dayIndices.length) {\\n\\t\\t\\treturn dayIndices[dayIndices.length - 1] + 1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn dayIndices[dayOffset];\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Options\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Computes a default column header formatting string if `colFormat` is not explicitly defined\\n\\tcomputeColHeadFormat: function() {\\n\\t\\t// if more than one week row, or if there are a lot of columns with not much space,\\n\\t\\t// put just the day numbers will be in each cell\\n\\t\\tif (this.rowCnt > 1 || this.colCnt > 10) {\\n\\t\\t\\treturn 'ddd'; // \\\"Sat\\\"\\n\\t\\t}\\n\\t\\t// multiple days, so full single date string WON'T be in title text\\n\\t\\telse if (this.colCnt > 1) {\\n\\t\\t\\treturn this.view.opt('dayOfMonthFormat'); // \\\"Sat 12/10\\\"\\n\\t\\t}\\n\\t\\t// single day, so full single date string will probably be in title text\\n\\t\\telse {\\n\\t\\t\\treturn 'dddd'; // \\\"Saturday\\\"\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Slicing\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Slices up a date range into a segment for every week-row it intersects with\\n\\tsliceRangeByRow: function(range) {\\n\\t\\tvar daysPerRow = this.daysPerRow;\\n\\t\\tvar normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\\n\\t\\tvar rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\\n\\t\\tvar rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\\n\\t\\tvar segs = [];\\n\\t\\tvar row;\\n\\t\\tvar rowFirst, rowLast; // inclusive day-index range for current row\\n\\t\\tvar segFirst, segLast; // inclusive day-index range for segment\\n\\n\\t\\tfor (row = 0; row < this.rowCnt; row++) {\\n\\t\\t\\trowFirst = row * daysPerRow;\\n\\t\\t\\trowLast = rowFirst + daysPerRow - 1;\\n\\n\\t\\t\\t// intersect segment's offset range with the row's\\n\\t\\t\\tsegFirst = Math.max(rangeFirst, rowFirst);\\n\\t\\t\\tsegLast = Math.min(rangeLast, rowLast);\\n\\n\\t\\t\\t// deal with in-between indices\\n\\t\\t\\tsegFirst = Math.ceil(segFirst); // in-between starts round to next cell\\n\\t\\t\\tsegLast = Math.floor(segLast); // in-between ends round to prev cell\\n\\n\\t\\t\\tif (segFirst <= segLast) { // was there any intersection with the current row?\\n\\t\\t\\t\\tsegs.push({\\n\\t\\t\\t\\t\\trow: row,\\n\\n\\t\\t\\t\\t\\t// normalize to start of row\\n\\t\\t\\t\\t\\tfirstRowDayIndex: segFirst - rowFirst,\\n\\t\\t\\t\\t\\tlastRowDayIndex: segLast - rowFirst,\\n\\n\\t\\t\\t\\t\\t// must be matching integers to be the segment's start/end\\n\\t\\t\\t\\t\\tisStart: segFirst === rangeFirst,\\n\\t\\t\\t\\t\\tisEnd: segLast === rangeLast\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t// Slices up a date range into a segment for every day-cell it intersects with.\\n\\t// TODO: make more DRY with sliceRangeByRow somehow.\\n\\tsliceRangeByDay: function(range) {\\n\\t\\tvar daysPerRow = this.daysPerRow;\\n\\t\\tvar normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\\n\\t\\tvar rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\\n\\t\\tvar rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\\n\\t\\tvar segs = [];\\n\\t\\tvar row;\\n\\t\\tvar rowFirst, rowLast; // inclusive day-index range for current row\\n\\t\\tvar i;\\n\\t\\tvar segFirst, segLast; // inclusive day-index range for segment\\n\\n\\t\\tfor (row = 0; row < this.rowCnt; row++) {\\n\\t\\t\\trowFirst = row * daysPerRow;\\n\\t\\t\\trowLast = rowFirst + daysPerRow - 1;\\n\\n\\t\\t\\tfor (i = rowFirst; i <= rowLast; i++) {\\n\\n\\t\\t\\t\\t// intersect segment's offset range with the row's\\n\\t\\t\\t\\tsegFirst = Math.max(rangeFirst, i);\\n\\t\\t\\t\\tsegLast = Math.min(rangeLast, i);\\n\\n\\t\\t\\t\\t// deal with in-between indices\\n\\t\\t\\t\\tsegFirst = Math.ceil(segFirst); // in-between starts round to next cell\\n\\t\\t\\t\\tsegLast = Math.floor(segLast); // in-between ends round to prev cell\\n\\n\\t\\t\\t\\tif (segFirst <= segLast) { // was there any intersection with the current row?\\n\\t\\t\\t\\t\\tsegs.push({\\n\\t\\t\\t\\t\\t\\trow: row,\\n\\n\\t\\t\\t\\t\\t\\t// normalize to start of row\\n\\t\\t\\t\\t\\t\\tfirstRowDayIndex: segFirst - rowFirst,\\n\\t\\t\\t\\t\\t\\tlastRowDayIndex: segLast - rowFirst,\\n\\n\\t\\t\\t\\t\\t\\t// must be matching integers to be the segment's start/end\\n\\t\\t\\t\\t\\t\\tisStart: segFirst === rangeFirst,\\n\\t\\t\\t\\t\\t\\tisEnd: segLast === rangeLast\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t/* Header Rendering\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderHeadHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\treturn '' +\\n\\t\\t\\t'<div class=\\\"fc-row ' + view.widgetHeaderClass + '\\\">' +\\n\\t\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t\\t'<thead>' +\\n\\t\\t\\t\\t\\t\\tthis.renderHeadTrHtml() +\\n\\t\\t\\t\\t\\t'</thead>' +\\n\\t\\t\\t\\t'</table>' +\\n\\t\\t\\t'</div>';\\n\\t},\\n\\n\\n\\trenderHeadIntroHtml: function() {\\n\\t\\treturn this.renderIntroHtml(); // fall back to generic\\n\\t},\\n\\n\\n\\trenderHeadTrHtml: function() {\\n\\t\\treturn '' +\\n\\t\\t\\t'<tr>' +\\n\\t\\t\\t\\t(this.isRTL ? '' : this.renderHeadIntroHtml()) +\\n\\t\\t\\t\\tthis.renderHeadDateCellsHtml() +\\n\\t\\t\\t\\t(this.isRTL ? this.renderHeadIntroHtml() : '') +\\n\\t\\t\\t'</tr>';\\n\\t},\\n\\n\\n\\trenderHeadDateCellsHtml: function() {\\n\\t\\tvar htmls = [];\\n\\t\\tvar col, date;\\n\\n\\t\\tfor (col = 0; col < this.colCnt; col++) {\\n\\t\\t\\tdate = this.getCellDate(0, col);\\n\\t\\t\\thtmls.push(this.renderHeadDateCellHtml(date));\\n\\t\\t}\\n\\n\\t\\treturn htmls.join('');\\n\\t},\\n\\n\\n\\t// TODO: when internalApiVersion, accept an object for HTML attributes\\n\\t// (colspan should be no different)\\n\\trenderHeadDateCellHtml: function(date, colspan, otherAttrs) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.\\n\\t\\tvar classNames = [\\n\\t\\t\\t'fc-day-header',\\n\\t\\t\\tview.widgetHeaderClass\\n\\t\\t];\\n\\t\\tvar innerHtml = htmlEscape(date.format(this.colHeadFormat));\\n\\n\\t\\t// if only one row of days, the classNames on the header can represent the specific days beneath\\n\\t\\tif (this.rowCnt === 1) {\\n\\t\\t\\tclassNames = classNames.concat(\\n\\t\\t\\t\\t// includes the day-of-week class\\n\\t\\t\\t\\t// noThemeHighlight=true (don't highlight the header)\\n\\t\\t\\t\\tthis.getDayClasses(date, true)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tclassNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class\\n\\t\\t}\\n\\n\\t\\treturn '' +\\n            '<th class=\\\"' + classNames.join(' ') + '\\\"' +\\n\\t\\t\\t\\t((isDateValid && this.rowCnt) === 1 ?\\n\\t\\t\\t\\t\\t' data-date=\\\"' + date.format('YYYY-MM-DD') + '\\\"' :\\n\\t\\t\\t\\t\\t'') +\\n\\t\\t\\t\\t(colspan > 1 ?\\n\\t\\t\\t\\t\\t' colspan=\\\"' + colspan + '\\\"' :\\n\\t\\t\\t\\t\\t'') +\\n\\t\\t\\t\\t(otherAttrs ?\\n\\t\\t\\t\\t\\t' ' + otherAttrs :\\n\\t\\t\\t\\t\\t'') +\\n\\t\\t\\t\\t'>' +\\n\\t\\t\\t\\t(isDateValid ?\\n\\t\\t\\t\\t\\t// don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\\n\\t\\t\\t\\t\\tview.buildGotoAnchorHtml(\\n\\t\\t\\t\\t\\t\\t{ date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },\\n\\t\\t\\t\\t\\t\\tinnerHtml\\n\\t\\t\\t\\t\\t) :\\n\\t\\t\\t\\t\\t// if not valid, display text, but no link\\n\\t\\t\\t\\t\\tinnerHtml\\n\\t\\t\\t\\t) +\\n\\t\\t\\t'</th>';\\n\\t},\\n\\n\\n\\t/* Background Rendering\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderBgTrHtml: function(row) {\\n\\t\\treturn '' +\\n\\t\\t\\t'<tr>' +\\n\\t\\t\\t\\t(this.isRTL ? '' : this.renderBgIntroHtml(row)) +\\n\\t\\t\\t\\tthis.renderBgCellsHtml(row) +\\n\\t\\t\\t\\t(this.isRTL ? this.renderBgIntroHtml(row) : '') +\\n\\t\\t\\t'</tr>';\\n\\t},\\n\\n\\n\\trenderBgIntroHtml: function(row) {\\n\\t\\treturn this.renderIntroHtml(); // fall back to generic\\n\\t},\\n\\n\\n\\trenderBgCellsHtml: function(row) {\\n\\t\\tvar htmls = [];\\n\\t\\tvar col, date;\\n\\n\\t\\tfor (col = 0; col < this.colCnt; col++) {\\n\\t\\t\\tdate = this.getCellDate(row, col);\\n\\t\\t\\thtmls.push(this.renderBgCellHtml(date));\\n\\t\\t}\\n\\n\\t\\treturn htmls.join('');\\n\\t},\\n\\n\\n\\trenderBgCellHtml: function(date, otherAttrs) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.\\n\\t\\tvar classes = this.getDayClasses(date);\\n\\n\\t\\tclasses.unshift('fc-day', view.widgetContentClass);\\n\\n\\t\\treturn '<td class=\\\"' + classes.join(' ') + '\\\"' +\\n\\t\\t\\t(isDateValid ?\\n\\t\\t\\t\\t' data-date=\\\"' + date.format('YYYY-MM-DD') + '\\\"' : // if date has a time, won't format it\\n\\t\\t\\t\\t'') +\\n\\t\\t\\t(otherAttrs ?\\n\\t\\t\\t\\t' ' + otherAttrs :\\n\\t\\t\\t\\t'') +\\n\\t\\t\\t'></td>';\\n\\t},\\n\\n\\n\\t/* Generic\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Generates the default HTML intro for any row. User classes should override\\n\\trenderIntroHtml: function() {\\n\\t},\\n\\n\\n\\t// TODO: a generic method for dealing with <tr>, RTL, intro\\n\\t// when increment internalApiVersion\\n\\t// wrapTr (scheduler)\\n\\n\\n\\t/* Utils\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Applies the generic \\\"intro\\\" and \\\"outro\\\" HTML to the given cells.\\n\\t// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\\n\\tbookendCells: function(trEl) {\\n\\t\\tvar introHtml = this.renderIntroHtml();\\n\\n\\t\\tif (introHtml) {\\n\\t\\t\\tif (this.isRTL) {\\n\\t\\t\\t\\ttrEl.append(introHtml);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ttrEl.prepend(introHtml);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n};\\n\\n;;\\n\\n/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nvar DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {\\n\\n\\tnumbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal\\n\\tbottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid\\n\\n\\trowEls: null, // set of fake row elements\\n\\tcellEls: null, // set of whole-day elements comprising the row's background\\n\\thelperEls: null, // set of cell skeleton elements for rendering the mock event \\\"helper\\\"\\n\\n\\trowCoordCache: null,\\n\\tcolCoordCache: null,\\n\\n\\n\\t// Renders the rows and columns into the component's `this.el`, which should already be assigned.\\n\\t// isRigid determins whether the individual rows should ignore the contents and be a constant height.\\n\\t// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\\n\\trenderDates: function(isRigid) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar rowCnt = this.rowCnt;\\n\\t\\tvar colCnt = this.colCnt;\\n\\t\\tvar html = '';\\n\\t\\tvar row;\\n\\t\\tvar col;\\n\\n\\t\\tfor (row = 0; row < rowCnt; row++) {\\n\\t\\t\\thtml += this.renderDayRowHtml(row, isRigid);\\n\\t\\t}\\n\\t\\tthis.el.html(html);\\n\\n\\t\\tthis.rowEls = this.el.find('.fc-row');\\n\\t\\tthis.cellEls = this.el.find('.fc-day, .fc-disabled-day');\\n\\n\\t\\tthis.rowCoordCache = new CoordCache({\\n\\t\\t\\tels: this.rowEls,\\n\\t\\t\\tisVertical: true\\n\\t\\t});\\n\\t\\tthis.colCoordCache = new CoordCache({\\n\\t\\t\\tels: this.cellEls.slice(0, this.colCnt), // only the first row\\n\\t\\t\\tisHorizontal: true\\n\\t\\t});\\n\\n\\t\\t// trigger dayRender with each cell's element\\n\\t\\tfor (row = 0; row < rowCnt; row++) {\\n\\t\\t\\tfor (col = 0; col < colCnt; col++) {\\n\\t\\t\\t\\tview.publiclyTrigger(\\n\\t\\t\\t\\t\\t'dayRender',\\n\\t\\t\\t\\t\\tnull,\\n\\t\\t\\t\\t\\tthis.getCellDate(row, col),\\n\\t\\t\\t\\t\\tthis.getCellEl(row, col)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\tunrenderDates: function() {\\n\\t\\tthis.removeSegPopover();\\n\\t},\\n\\n\\n\\trenderBusinessHours: function() {\\n\\t\\tvar segs = this.buildBusinessHourSegs(true); // wholeDay=true\\n\\t\\tthis.renderFill('businessHours', segs, 'bgevent');\\n\\t},\\n\\n\\n\\tunrenderBusinessHours: function() {\\n\\t\\tthis.unrenderFill('businessHours');\\n\\t},\\n\\n\\n\\t// Generates the HTML for a single row, which is a div that wraps a table.\\n\\t// `row` is the row number.\\n\\trenderDayRowHtml: function(row, isRigid) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];\\n\\n\\t\\tif (isRigid) {\\n\\t\\t\\tclasses.push('fc-rigid');\\n\\t\\t}\\n\\n\\t\\treturn '' +\\n\\t\\t\\t'<div class=\\\"' + classes.join(' ') + '\\\">' +\\n\\t\\t\\t\\t'<div class=\\\"fc-bg\\\">' +\\n\\t\\t\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t\\t\\tthis.renderBgTrHtml(row) +\\n\\t\\t\\t\\t\\t'</table>' +\\n\\t\\t\\t\\t'</div>' +\\n\\t\\t\\t\\t'<div class=\\\"fc-content-skeleton\\\">' +\\n\\t\\t\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t\\t\\t(this.numbersVisible ?\\n\\t\\t\\t\\t\\t\\t\\t'<thead>' +\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.renderNumberTrHtml(row) +\\n\\t\\t\\t\\t\\t\\t\\t'</thead>' :\\n\\t\\t\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t\\t'</table>' +\\n\\t\\t\\t\\t'</div>' +\\n\\t\\t\\t'</div>';\\n\\t},\\n\\n\\n\\t/* Grid Number Rendering\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderNumberTrHtml: function(row) {\\n\\t\\treturn '' +\\n\\t\\t\\t'<tr>' +\\n\\t\\t\\t\\t(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +\\n\\t\\t\\t\\tthis.renderNumberCellsHtml(row) +\\n\\t\\t\\t\\t(this.isRTL ? this.renderNumberIntroHtml(row) : '') +\\n\\t\\t\\t'</tr>';\\n\\t},\\n\\n\\n\\trenderNumberIntroHtml: function(row) {\\n\\t\\treturn this.renderIntroHtml();\\n\\t},\\n\\n\\n\\trenderNumberCellsHtml: function(row) {\\n\\t\\tvar htmls = [];\\n\\t\\tvar col, date;\\n\\n\\t\\tfor (col = 0; col < this.colCnt; col++) {\\n\\t\\t\\tdate = this.getCellDate(row, col);\\n\\t\\t\\thtmls.push(this.renderNumberCellHtml(date));\\n\\t\\t}\\n\\n\\t\\treturn htmls.join('');\\n\\t},\\n\\n\\n\\t// Generates the HTML for the <td>s of the \\\"number\\\" row in the DayGrid's content skeleton.\\n\\t// The number row will only exist if either day numbers or week numbers are turned on.\\n\\trenderNumberCellHtml: function(date) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar html = '';\\n\\t\\tvar isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.\\n\\t\\tvar isDayNumberVisible = view.dayNumbersVisible && isDateValid;\\n\\t\\tvar classes;\\n\\t\\tvar weekCalcFirstDoW;\\n\\n\\t\\tif (!isDayNumberVisible && !view.cellWeekNumbersVisible) {\\n\\t\\t\\t// no numbers in day cell (week number must be along the side)\\n\\t\\t\\treturn '<td/>'; //  will create an empty space above events :(\\n\\t\\t}\\n\\n\\t\\tclasses = this.getDayClasses(date);\\n\\t\\tclasses.unshift('fc-day-top');\\n\\n\\t\\tif (view.cellWeekNumbersVisible) {\\n\\t\\t\\t// To determine the day of week number change under ISO, we cannot\\n\\t\\t\\t// rely on moment.js methods such as firstDayOfWeek() or weekday(),\\n\\t\\t\\t// because they rely on the locale's dow (possibly overridden by\\n\\t\\t\\t// our firstDay option), which may not be Monday. We cannot change\\n\\t\\t\\t// dow, because that would affect the calendar start day as well.\\n\\t\\t\\tif (date._locale._fullCalendar_weekCalc === 'ISO') {\\n\\t\\t\\t\\tweekCalcFirstDoW = 1;  // Monday by ISO 8601 definition\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tweekCalcFirstDoW = date._locale.firstDayOfWeek();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\thtml += '<td class=\\\"' + classes.join(' ') + '\\\"' +\\n\\t\\t\\t(isDateValid ?\\n\\t\\t\\t\\t' data-date=\\\"' + date.format() + '\\\"' :\\n\\t\\t\\t\\t''\\n\\t\\t\\t\\t) +\\n\\t\\t\\t'>';\\n\\n\\t\\tif (view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {\\n\\t\\t\\thtml += view.buildGotoAnchorHtml(\\n\\t\\t\\t\\t{ date: date, type: 'week' },\\n\\t\\t\\t\\t{ 'class': 'fc-week-number' },\\n\\t\\t\\t\\tdate.format('w') // inner HTML\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tif (isDayNumberVisible) {\\n\\t\\t\\thtml += view.buildGotoAnchorHtml(\\n\\t\\t\\t\\tdate,\\n\\t\\t\\t\\t{ 'class': 'fc-day-number' },\\n\\t\\t\\t\\tdate.date() // inner HTML\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\thtml += '</td>';\\n\\n\\t\\treturn html;\\n\\t},\\n\\n\\n\\t/* Options\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Computes a default event time formatting string if `timeFormat` is not explicitly defined\\n\\tcomputeEventTimeFormat: function() {\\n\\t\\treturn this.view.opt('extraSmallTimeFormat'); // like \\\"6p\\\" or \\\"6:30p\\\"\\n\\t},\\n\\n\\n\\t// Computes a default `displayEventEnd` value if one is not expliclty defined\\n\\tcomputeDisplayEventEnd: function() {\\n\\t\\treturn this.colCnt == 1; // we'll likely have space if there's only one day\\n\\t},\\n\\n\\n\\t/* Dates\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trangeUpdated: function() {\\n\\t\\tthis.updateDayTable();\\n\\t},\\n\\n\\n\\t// Slices up the given span (unzoned start/end with other misc data) into an array of segments\\n\\tspanToSegs: function(span) {\\n\\t\\tvar segs = this.sliceRangeByRow(span);\\n\\t\\tvar i, seg;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\t\\t\\tif (this.isRTL) {\\n\\t\\t\\t\\tseg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\\n\\t\\t\\t\\tseg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tseg.leftCol = seg.firstRowDayIndex;\\n\\t\\t\\t\\tseg.rightCol = seg.lastRowDayIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t/* Hit System\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tprepareHits: function() {\\n\\t\\tthis.colCoordCache.build();\\n\\t\\tthis.rowCoordCache.build();\\n\\t\\tthis.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\\n\\t},\\n\\n\\n\\treleaseHits: function() {\\n\\t\\tthis.colCoordCache.clear();\\n\\t\\tthis.rowCoordCache.clear();\\n\\t},\\n\\n\\n\\tqueryHit: function(leftOffset, topOffset) {\\n\\t\\tif (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {\\n\\t\\t\\tvar col = this.colCoordCache.getHorizontalIndex(leftOffset);\\n\\t\\t\\tvar row = this.rowCoordCache.getVerticalIndex(topOffset);\\n\\n\\t\\t\\tif (row != null && col != null) {\\n\\t\\t\\t\\treturn this.getCellHit(row, col);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\tgetHitSpan: function(hit) {\\n\\t\\treturn this.getCellRange(hit.row, hit.col);\\n\\t},\\n\\n\\n\\tgetHitEl: function(hit) {\\n\\t\\treturn this.getCellEl(hit.row, hit.col);\\n\\t},\\n\\n\\n\\t/* Cell System\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\t// FYI: the first column is the leftmost column, regardless of date\\n\\n\\n\\tgetCellHit: function(row, col) {\\n\\t\\treturn {\\n\\t\\t\\trow: row,\\n\\t\\t\\tcol: col,\\n\\t\\t\\tcomponent: this, // needed unfortunately :(\\n\\t\\t\\tleft: this.colCoordCache.getLeftOffset(col),\\n\\t\\t\\tright: this.colCoordCache.getRightOffset(col),\\n\\t\\t\\ttop: this.rowCoordCache.getTopOffset(row),\\n\\t\\t\\tbottom: this.rowCoordCache.getBottomOffset(row)\\n\\t\\t};\\n\\t},\\n\\n\\n\\tgetCellEl: function(row, col) {\\n\\t\\treturn this.cellEls.eq(row * this.colCnt + col);\\n\\t},\\n\\n\\n\\t/* Event Drag Visualization\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\t// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods\\n\\n\\n\\t// Renders a visual indication of an event or external element being dragged.\\n\\t// `eventLocation` has zoned start and end (optional)\\n\\trenderDrag: function(eventLocation, seg) {\\n\\t\\tvar eventSpans = this.eventToSpans(eventLocation);\\n\\t\\tvar i;\\n\\n\\t\\t// always render a highlight underneath\\n\\t\\tfor (i = 0; i < eventSpans.length; i++) {\\n\\t\\t\\tthis.renderHighlight(eventSpans[i]);\\n\\t\\t}\\n\\n\\t\\t// if a segment from the same calendar but another component is being dragged, render a helper event\\n\\t\\tif (seg && seg.component !== this) {\\n\\t\\t\\treturn this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Unrenders any visual indication of a hovering event\\n\\tunrenderDrag: function() {\\n\\t\\tthis.unrenderHighlight();\\n\\t\\tthis.unrenderHelper();\\n\\t},\\n\\n\\n\\t/* Event Resize Visualization\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of an event being resized\\n\\trenderEventResize: function(eventLocation, seg) {\\n\\t\\tvar eventSpans = this.eventToSpans(eventLocation);\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < eventSpans.length; i++) {\\n\\t\\t\\tthis.renderHighlight(eventSpans[i]);\\n\\t\\t}\\n\\n\\t\\treturn this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\\n\\t},\\n\\n\\n\\t// Unrenders a visual indication of an event being resized\\n\\tunrenderEventResize: function() {\\n\\t\\tthis.unrenderHighlight();\\n\\t\\tthis.unrenderHelper();\\n\\t},\\n\\n\\n\\t/* Event Helper\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a mock \\\"helper\\\" event. `sourceSeg` is the associated internal segment object. It can be null.\\n\\trenderHelper: function(event, sourceSeg) {\\n\\t\\tvar helperNodes = [];\\n\\t\\tvar segs = this.eventToSegs(event);\\n\\t\\tvar rowStructs;\\n\\n\\t\\tsegs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered\\n\\t\\trowStructs = this.renderSegRows(segs);\\n\\n\\t\\t// inject each new event skeleton into each associated row\\n\\t\\tthis.rowEls.each(function(row, rowNode) {\\n\\t\\t\\tvar rowEl = $(rowNode); // the .fc-row\\n\\t\\t\\tvar skeletonEl = $('<div class=\\\"fc-helper-skeleton\\\"><table/></div>'); // will be absolutely positioned\\n\\t\\t\\tvar skeletonTop;\\n\\n\\t\\t\\t// If there is an original segment, match the top position. Otherwise, put it at the row's top level\\n\\t\\t\\tif (sourceSeg && sourceSeg.row === row) {\\n\\t\\t\\t\\tskeletonTop = sourceSeg.el.position().top;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tskeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;\\n\\t\\t\\t}\\n\\n\\t\\t\\tskeletonEl.css('top', skeletonTop)\\n\\t\\t\\t\\t.find('table')\\n\\t\\t\\t\\t\\t.append(rowStructs[row].tbodyEl);\\n\\n\\t\\t\\trowEl.append(skeletonEl);\\n\\t\\t\\thelperNodes.push(skeletonEl[0]);\\n\\t\\t});\\n\\n\\t\\treturn ( // must return the elements rendered\\n\\t\\t\\tthis.helperEls = $(helperNodes) // array -> jQuery set\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Unrenders any visual indication of a mock helper event\\n\\tunrenderHelper: function() {\\n\\t\\tif (this.helperEls) {\\n\\t\\t\\tthis.helperEls.remove();\\n\\t\\t\\tthis.helperEls = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Fill System (highlight, background events, business hours)\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tfillSegTag: 'td', // override the default tag name\\n\\n\\n\\t// Renders a set of rectangles over the given segments of days.\\n\\t// Only returns segments that successfully rendered.\\n\\trenderFill: function(type, segs, className) {\\n\\t\\tvar nodes = [];\\n\\t\\tvar i, seg;\\n\\t\\tvar skeletonEl;\\n\\n\\t\\tsegs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\t\\t\\tskeletonEl = this.renderFillRow(type, seg, className);\\n\\t\\t\\tthis.rowEls.eq(seg.row).append(skeletonEl);\\n\\t\\t\\tnodes.push(skeletonEl[0]);\\n\\t\\t}\\n\\n\\t\\tthis.elsByFill[type] = $(nodes);\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\\n\\trenderFillRow: function(type, seg, className) {\\n\\t\\tvar colCnt = this.colCnt;\\n\\t\\tvar startCol = seg.leftCol;\\n\\t\\tvar endCol = seg.rightCol + 1;\\n\\t\\tvar skeletonEl;\\n\\t\\tvar trEl;\\n\\n\\t\\tclassName = className || type.toLowerCase();\\n\\n\\t\\tskeletonEl = $(\\n\\t\\t\\t'<div class=\\\"fc-' + className + '-skeleton\\\">' +\\n\\t\\t\\t\\t'<table><tr/></table>' +\\n\\t\\t\\t'</div>'\\n\\t\\t);\\n\\t\\ttrEl = skeletonEl.find('tr');\\n\\n\\t\\tif (startCol > 0) {\\n\\t\\t\\ttrEl.append('<td colspan=\\\"' + startCol + '\\\"/>');\\n\\t\\t}\\n\\n\\t\\ttrEl.append(\\n\\t\\t\\tseg.el.attr('colspan', endCol - startCol)\\n\\t\\t);\\n\\n\\t\\tif (endCol < colCnt) {\\n\\t\\t\\ttrEl.append('<td colspan=\\\"' + (colCnt - endCol) + '\\\"/>');\\n\\t\\t}\\n\\n\\t\\tthis.bookendCells(trEl);\\n\\n\\t\\treturn skeletonEl;\\n\\t}\\n\\n});\\n\\n;;\\n\\n/* Event-rendering methods for the DayGrid class\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nDayGrid.mixin({\\n\\n\\trowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering\\n\\n\\n\\t// Unrenders all events currently rendered on the grid\\n\\tunrenderEvents: function() {\\n\\t\\tthis.removeSegPopover(); // removes the \\\"more..\\\" events popover\\n\\t\\tGrid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method\\n\\t},\\n\\n\\n\\t// Retrieves all rendered segment objects currently rendered on the grid\\n\\tgetEventSegs: function() {\\n\\t\\treturn Grid.prototype.getEventSegs.call(this) // get the segments from the super-method\\n\\t\\t\\t.concat(this.popoverSegs || []); // append the segments from the \\\"more...\\\" popover\\n\\t},\\n\\n\\n\\t// Renders the given background event segments onto the grid\\n\\trenderBgSegs: function(segs) {\\n\\n\\t\\t// don't render timed background events\\n\\t\\tvar allDaySegs = $.grep(segs, function(seg) {\\n\\t\\t\\treturn seg.event.allDay;\\n\\t\\t});\\n\\n\\t\\treturn Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method\\n\\t},\\n\\n\\n\\t// Renders the given foreground event segments onto the grid\\n\\trenderFgSegs: function(segs) {\\n\\t\\tvar rowStructs;\\n\\n\\t\\t// render an `.el` on each seg\\n\\t\\t// returns a subset of the segs. segs that were actually rendered\\n\\t\\tsegs = this.renderFgSegEls(segs);\\n\\n\\t\\trowStructs = this.rowStructs = this.renderSegRows(segs);\\n\\n\\t\\t// append to each row's content skeleton\\n\\t\\tthis.rowEls.each(function(i, rowNode) {\\n\\t\\t\\t$(rowNode).find('.fc-content-skeleton > table').append(\\n\\t\\t\\t\\trowStructs[i].tbodyEl\\n\\t\\t\\t);\\n\\t\\t});\\n\\n\\t\\treturn segs; // return only the segs that were actually rendered\\n\\t},\\n\\n\\n\\t// Unrenders all currently rendered foreground event segments\\n\\tunrenderFgSegs: function() {\\n\\t\\tvar rowStructs = this.rowStructs || [];\\n\\t\\tvar rowStruct;\\n\\n\\t\\twhile ((rowStruct = rowStructs.pop())) {\\n\\t\\t\\trowStruct.tbodyEl.remove();\\n\\t\\t}\\n\\n\\t\\tthis.rowStructs = null;\\n\\t},\\n\\n\\n\\t// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\\n\\t// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\\n\\t// PRECONDITION: each segment shoud already have a rendered and assigned `.el`\\n\\trenderSegRows: function(segs) {\\n\\t\\tvar rowStructs = [];\\n\\t\\tvar segRows;\\n\\t\\tvar row;\\n\\n\\t\\tsegRows = this.groupSegRows(segs); // group into nested arrays\\n\\n\\t\\t// iterate each row of segment groupings\\n\\t\\tfor (row = 0; row < segRows.length; row++) {\\n\\t\\t\\trowStructs.push(\\n\\t\\t\\t\\tthis.renderSegRow(row, segRows[row])\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn rowStructs;\\n\\t},\\n\\n\\n\\t// Builds the HTML to be used for the default element for an individual segment\\n\\tfgSegHtml: function(seg, disableResizing) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar event = seg.event;\\n\\t\\tvar isDraggable = view.isEventDraggable(event);\\n\\t\\tvar isResizableFromStart = !disableResizing && event.allDay &&\\n\\t\\t\\tseg.isStart && view.isEventResizableFromStart(event);\\n\\t\\tvar isResizableFromEnd = !disableResizing && event.allDay &&\\n\\t\\t\\tseg.isEnd && view.isEventResizableFromEnd(event);\\n\\t\\tvar classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\\n\\t\\tvar skinCss = cssToStr(this.getSegSkinCss(seg));\\n\\t\\tvar timeHtml = '';\\n\\t\\tvar timeText;\\n\\t\\tvar titleHtml;\\n\\n\\t\\tclasses.unshift('fc-day-grid-event', 'fc-h-event');\\n\\n\\t\\t// Only display a timed events time if it is the starting segment\\n\\t\\tif (seg.isStart) {\\n\\t\\t\\ttimeText = this.getEventTimeText(event);\\n\\t\\t\\tif (timeText) {\\n\\t\\t\\t\\ttimeHtml = '<span class=\\\"fc-time\\\">' + htmlEscape(timeText) + '</span>';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttitleHtml =\\n\\t\\t\\t'<span class=\\\"fc-title\\\">' +\\n\\t\\t\\t\\t(htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height\\n\\t\\t\\t'</span>';\\n\\t\\t\\n\\t\\treturn '<a class=\\\"' + classes.join(' ') + '\\\"' +\\n\\t\\t\\t\\t(event.url ?\\n\\t\\t\\t\\t\\t' href=\\\"' + htmlEscape(event.url) + '\\\"' :\\n\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t(skinCss ?\\n\\t\\t\\t\\t\\t' style=\\\"' + skinCss + '\\\"' :\\n\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t'>' +\\n\\t\\t\\t\\t'<div class=\\\"fc-content\\\">' +\\n\\t\\t\\t\\t\\t(this.isRTL ?\\n\\t\\t\\t\\t\\t\\ttitleHtml + ' ' + timeHtml : // put a natural space in between\\n\\t\\t\\t\\t\\t\\ttimeHtml + ' ' + titleHtml   //\\n\\t\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t'</div>' +\\n\\t\\t\\t\\t(isResizableFromStart ?\\n\\t\\t\\t\\t\\t'<div class=\\\"fc-resizer fc-start-resizer\\\" />' :\\n\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t(isResizableFromEnd ?\\n\\t\\t\\t\\t\\t'<div class=\\\"fc-resizer fc-end-resizer\\\" />' :\\n\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t'</a>';\\n\\t},\\n\\n\\n\\t// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\\n\\t// the segments. Returns object with a bunch of internal data about how the render was calculated.\\n\\t// NOTE: modifies rowSegs\\n\\trenderSegRow: function(row, rowSegs) {\\n\\t\\tvar colCnt = this.colCnt;\\n\\t\\tvar segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\\n\\t\\tvar levelCnt = Math.max(1, segLevels.length); // ensure at least one level\\n\\t\\tvar tbody = $('<tbody/>');\\n\\t\\tvar segMatrix = []; // lookup for which segments are rendered into which level+col cells\\n\\t\\tvar cellMatrix = []; // lookup for all <td> elements of the level+col matrix\\n\\t\\tvar loneCellMatrix = []; // lookup for <td> elements that only take up a single column\\n\\t\\tvar i, levelSegs;\\n\\t\\tvar col;\\n\\t\\tvar tr;\\n\\t\\tvar j, seg;\\n\\t\\tvar td;\\n\\n\\t\\t// populates empty cells from the current column (`col`) to `endCol`\\n\\t\\tfunction emptyCellsUntil(endCol) {\\n\\t\\t\\twhile (col < endCol) {\\n\\t\\t\\t\\t// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\\n\\t\\t\\t\\ttd = (loneCellMatrix[i - 1] || [])[col];\\n\\t\\t\\t\\tif (td) {\\n\\t\\t\\t\\t\\ttd.attr(\\n\\t\\t\\t\\t\\t\\t'rowspan',\\n\\t\\t\\t\\t\\t\\tparseInt(td.attr('rowspan') || 1, 10) + 1\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttd = $('<td/>');\\n\\t\\t\\t\\t\\ttr.append(td);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcellMatrix[i][col] = td;\\n\\t\\t\\t\\tloneCellMatrix[i][col] = td;\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < levelCnt; i++) { // iterate through all levels\\n\\t\\t\\tlevelSegs = segLevels[i];\\n\\t\\t\\tcol = 0;\\n\\t\\t\\ttr = $('<tr/>');\\n\\n\\t\\t\\tsegMatrix.push([]);\\n\\t\\t\\tcellMatrix.push([]);\\n\\t\\t\\tloneCellMatrix.push([]);\\n\\n\\t\\t\\t// levelCnt might be 1 even though there are no actual levels. protect against this.\\n\\t\\t\\t// this single empty row is useful for styling.\\n\\t\\t\\tif (levelSegs) {\\n\\t\\t\\t\\tfor (j = 0; j < levelSegs.length; j++) { // iterate through segments in level\\n\\t\\t\\t\\t\\tseg = levelSegs[j];\\n\\n\\t\\t\\t\\t\\temptyCellsUntil(seg.leftCol);\\n\\n\\t\\t\\t\\t\\t// create a container that occupies or more columns. append the event element.\\n\\t\\t\\t\\t\\ttd = $('<td class=\\\"fc-event-container\\\"/>').append(seg.el);\\n\\t\\t\\t\\t\\tif (seg.leftCol != seg.rightCol) {\\n\\t\\t\\t\\t\\t\\ttd.attr('colspan', seg.rightCol - seg.leftCol + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse { // a single-column segment\\n\\t\\t\\t\\t\\t\\tloneCellMatrix[i][col] = td;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\twhile (col <= seg.rightCol) {\\n\\t\\t\\t\\t\\t\\tcellMatrix[i][col] = td;\\n\\t\\t\\t\\t\\t\\tsegMatrix[i][col] = seg;\\n\\t\\t\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttr.append(td);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\temptyCellsUntil(colCnt); // finish off the row\\n\\t\\t\\tthis.bookendCells(tr);\\n\\t\\t\\ttbody.append(tr);\\n\\t\\t}\\n\\n\\t\\treturn { // a \\\"rowStruct\\\"\\n\\t\\t\\trow: row, // the row number\\n\\t\\t\\ttbodyEl: tbody,\\n\\t\\t\\tcellMatrix: cellMatrix,\\n\\t\\t\\tsegMatrix: segMatrix,\\n\\t\\t\\tsegLevels: segLevels,\\n\\t\\t\\tsegs: rowSegs\\n\\t\\t};\\n\\t},\\n\\n\\n\\t// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\\n\\t// NOTE: modifies segs\\n\\tbuildSegLevels: function(segs) {\\n\\t\\tvar levels = [];\\n\\t\\tvar i, seg;\\n\\t\\tvar j;\\n\\n\\t\\t// Give preference to elements with certain criteria, so they have\\n\\t\\t// a chance to be closer to the top.\\n\\t\\tthis.sortEventSegs(segs);\\n\\t\\t\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\n\\t\\t\\t// loop through levels, starting with the topmost, until the segment doesn't collide with other segments\\n\\t\\t\\tfor (j = 0; j < levels.length; j++) {\\n\\t\\t\\t\\tif (!isDaySegCollision(seg, levels[j])) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// `j` now holds the desired subrow index\\n\\t\\t\\tseg.level = j;\\n\\n\\t\\t\\t// create new level array if needed and append segment\\n\\t\\t\\t(levels[j] || (levels[j] = [])).push(seg);\\n\\t\\t}\\n\\n\\t\\t// order segments left-to-right. very important if calendar is RTL\\n\\t\\tfor (j = 0; j < levels.length; j++) {\\n\\t\\t\\tlevels[j].sort(compareDaySegCols);\\n\\t\\t}\\n\\n\\t\\treturn levels;\\n\\t},\\n\\n\\n\\t// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\\n\\tgroupSegRows: function(segs) {\\n\\t\\tvar segRows = [];\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < this.rowCnt; i++) {\\n\\t\\t\\tsegRows.push([]);\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tsegRows[segs[i].row].push(segs[i]);\\n\\t\\t}\\n\\n\\t\\treturn segRows;\\n\\t}\\n\\n});\\n\\n\\n// Computes whether two segments' columns collide. They are assumed to be in the same row.\\nfunction isDaySegCollision(seg, otherSegs) {\\n\\tvar i, otherSeg;\\n\\n\\tfor (i = 0; i < otherSegs.length; i++) {\\n\\t\\totherSeg = otherSegs[i];\\n\\n\\t\\tif (\\n\\t\\t\\totherSeg.leftCol <= seg.rightCol &&\\n\\t\\t\\totherSeg.rightCol >= seg.leftCol\\n\\t\\t) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n\\n// A cmp function for determining the leftmost event\\nfunction compareDaySegCols(a, b) {\\n\\treturn a.leftCol - b.leftCol;\\n}\\n\\n;;\\n\\n/* Methods relate to limiting the number events for a given day on a DayGrid\\n----------------------------------------------------------------------------------------------------------------------*/\\n// NOTE: all the segs being passed around in here are foreground segs\\n\\nDayGrid.mixin({\\n\\n\\tsegPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible\\n\\tpopoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible\\n\\n\\n\\tremoveSegPopover: function() {\\n\\t\\tif (this.segPopover) {\\n\\t\\t\\tthis.segPopover.hide(); // in handler, will call segPopover's removeElement\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Limits the number of \\\"levels\\\" (vertically stacking layers of events) for each row of the grid.\\n\\t// `levelLimit` can be false (don't limit), a number, or true (should be computed).\\n\\tlimitRows: function(levelLimit) {\\n\\t\\tvar rowStructs = this.rowStructs || [];\\n\\t\\tvar row; // row #\\n\\t\\tvar rowLevelLimit;\\n\\n\\t\\tfor (row = 0; row < rowStructs.length; row++) {\\n\\t\\t\\tthis.unlimitRow(row);\\n\\n\\t\\t\\tif (!levelLimit) {\\n\\t\\t\\t\\trowLevelLimit = false;\\n\\t\\t\\t}\\n\\t\\t\\telse if (typeof levelLimit === 'number') {\\n\\t\\t\\t\\trowLevelLimit = levelLimit;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\trowLevelLimit = this.computeRowLevelLimit(row);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (rowLevelLimit !== false) {\\n\\t\\t\\t\\tthis.limitRow(row, rowLevelLimit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Computes the number of levels a row will accomodate without going outside its bounds.\\n\\t// Assumes the row is \\\"rigid\\\" (maintains a constant height regardless of what is inside).\\n\\t// `row` is the row number.\\n\\tcomputeRowLevelLimit: function(row) {\\n\\t\\tvar rowEl = this.rowEls.eq(row); // the containing \\\"fake\\\" row div\\n\\t\\tvar rowHeight = rowEl.height(); // TODO: cache somehow?\\n\\t\\tvar trEls = this.rowStructs[row].tbodyEl.children();\\n\\t\\tvar i, trEl;\\n\\t\\tvar trHeight;\\n\\n\\t\\tfunction iterInnerHeights(i, childNode) {\\n\\t\\t\\ttrHeight = Math.max(trHeight, $(childNode).outerHeight());\\n\\t\\t}\\n\\n\\t\\t// Reveal one level <tr> at a time and stop when we find one out of bounds\\n\\t\\tfor (i = 0; i < trEls.length; i++) {\\n\\t\\t\\ttrEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\\n\\n\\t\\t\\t// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\\n\\t\\t\\t// so instead, find the tallest inner content element.\\n\\t\\t\\ttrHeight = 0;\\n\\t\\t\\ttrEl.find('> td > :first-child').each(iterInnerHeights);\\n\\n\\t\\t\\tif (trEl.position().top + trHeight > rowHeight) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false; // should not limit at all\\n\\t},\\n\\n\\n\\t// Limits the given grid row to the maximum number of levels and injects \\\"more\\\" links if necessary.\\n\\t// `row` is the row number.\\n\\t// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\\n\\tlimitRow: function(row, levelLimit) {\\n\\t\\tvar _this = this;\\n\\t\\tvar rowStruct = this.rowStructs[row];\\n\\t\\tvar moreNodes = []; // array of \\\"more\\\" <a> links and <td> DOM nodes\\n\\t\\tvar col = 0; // col #, left-to-right (not chronologically)\\n\\t\\tvar levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\\n\\t\\tvar cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\\n\\t\\tvar limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\\n\\t\\tvar i, seg;\\n\\t\\tvar segsBelow; // array of segment objects below `seg` in the current `col`\\n\\t\\tvar totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\\n\\t\\tvar colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\\n\\t\\tvar td, rowspan;\\n\\t\\tvar segMoreNodes; // array of \\\"more\\\" <td> cells that will stand-in for the current seg's cell\\n\\t\\tvar j;\\n\\t\\tvar moreTd, moreWrap, moreLink;\\n\\n\\t\\t// Iterates through empty level cells and places \\\"more\\\" links inside if need be\\n\\t\\tfunction emptyCellsUntil(endCol) { // goes from current `col` to `endCol`\\n\\t\\t\\twhile (col < endCol) {\\n\\t\\t\\t\\tsegsBelow = _this.getCellSegs(row, col, levelLimit);\\n\\t\\t\\t\\tif (segsBelow.length) {\\n\\t\\t\\t\\t\\ttd = cellMatrix[levelLimit - 1][col];\\n\\t\\t\\t\\t\\tmoreLink = _this.renderMoreLink(row, col, segsBelow);\\n\\t\\t\\t\\t\\tmoreWrap = $('<div/>').append(moreLink);\\n\\t\\t\\t\\t\\ttd.append(moreWrap);\\n\\t\\t\\t\\t\\tmoreNodes.push(moreWrap[0]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?\\n\\t\\t\\tlevelSegs = rowStruct.segLevels[levelLimit - 1];\\n\\t\\t\\tcellMatrix = rowStruct.cellMatrix;\\n\\n\\t\\t\\tlimitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\\n\\t\\t\\t\\t.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\\n\\n\\t\\t\\t// iterate though segments in the last allowable level\\n\\t\\t\\tfor (i = 0; i < levelSegs.length; i++) {\\n\\t\\t\\t\\tseg = levelSegs[i];\\n\\t\\t\\t\\temptyCellsUntil(seg.leftCol); // process empty cells before the segment\\n\\n\\t\\t\\t\\t// determine *all* segments below `seg` that occupy the same columns\\n\\t\\t\\t\\tcolSegsBelow = [];\\n\\t\\t\\t\\ttotalSegsBelow = 0;\\n\\t\\t\\t\\twhile (col <= seg.rightCol) {\\n\\t\\t\\t\\t\\tsegsBelow = this.getCellSegs(row, col, levelLimit);\\n\\t\\t\\t\\t\\tcolSegsBelow.push(segsBelow);\\n\\t\\t\\t\\t\\ttotalSegsBelow += segsBelow.length;\\n\\t\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (totalSegsBelow) { // do we need to replace this segment with one or many \\\"more\\\" links?\\n\\t\\t\\t\\t\\ttd = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\\n\\t\\t\\t\\t\\trowspan = td.attr('rowspan') || 1;\\n\\t\\t\\t\\t\\tsegMoreNodes = [];\\n\\n\\t\\t\\t\\t\\t// make a replacement <td> for each column the segment occupies. will be one for each colspan\\n\\t\\t\\t\\t\\tfor (j = 0; j < colSegsBelow.length; j++) {\\n\\t\\t\\t\\t\\t\\tmoreTd = $('<td class=\\\"fc-more-cell\\\"/>').attr('rowspan', rowspan);\\n\\t\\t\\t\\t\\t\\tsegsBelow = colSegsBelow[j];\\n\\t\\t\\t\\t\\t\\tmoreLink = this.renderMoreLink(\\n\\t\\t\\t\\t\\t\\t\\trow,\\n\\t\\t\\t\\t\\t\\t\\tseg.leftCol + j,\\n\\t\\t\\t\\t\\t\\t\\t[ seg ].concat(segsBelow) // count seg as hidden too\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\tmoreWrap = $('<div/>').append(moreLink);\\n\\t\\t\\t\\t\\t\\tmoreTd.append(moreWrap);\\n\\t\\t\\t\\t\\t\\tsegMoreNodes.push(moreTd[0]);\\n\\t\\t\\t\\t\\t\\tmoreNodes.push(moreTd[0]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttd.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\\n\\t\\t\\t\\t\\tlimitedNodes.push(td[0]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\temptyCellsUntil(this.colCnt); // finish off the level\\n\\t\\t\\trowStruct.moreEls = $(moreNodes); // for easy undoing later\\n\\t\\t\\trowStruct.limitedEls = $(limitedNodes); // for easy undoing later\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Reveals all levels and removes all \\\"more\\\"-related elements for a grid's row.\\n\\t// `row` is a row number.\\n\\tunlimitRow: function(row) {\\n\\t\\tvar rowStruct = this.rowStructs[row];\\n\\n\\t\\tif (rowStruct.moreEls) {\\n\\t\\t\\trowStruct.moreEls.remove();\\n\\t\\t\\trowStruct.moreEls = null;\\n\\t\\t}\\n\\n\\t\\tif (rowStruct.limitedEls) {\\n\\t\\t\\trowStruct.limitedEls.removeClass('fc-limited');\\n\\t\\t\\trowStruct.limitedEls = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Renders an <a> element that represents hidden event element for a cell.\\n\\t// Responsible for attaching click handler as well.\\n\\trenderMoreLink: function(row, col, hiddenSegs) {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\n\\t\\treturn $('<a class=\\\"fc-more\\\"/>')\\n\\t\\t\\t.text(\\n\\t\\t\\t\\tthis.getMoreLinkText(hiddenSegs.length)\\n\\t\\t\\t)\\n\\t\\t\\t.on('click', function(ev) {\\n\\t\\t\\t\\tvar clickOption = view.opt('eventLimitClick');\\n\\t\\t\\t\\tvar date = _this.getCellDate(row, col);\\n\\t\\t\\t\\tvar moreEl = $(this);\\n\\t\\t\\t\\tvar dayEl = _this.getCellEl(row, col);\\n\\t\\t\\t\\tvar allSegs = _this.getCellSegs(row, col);\\n\\n\\t\\t\\t\\t// rescope the segments to be within the cell's date\\n\\t\\t\\t\\tvar reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\\n\\t\\t\\t\\tvar reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\\n\\n\\t\\t\\t\\tif (typeof clickOption === 'function') {\\n\\t\\t\\t\\t\\t// the returned value can be an atomic option\\n\\t\\t\\t\\t\\tclickOption = view.publiclyTrigger('eventLimitClick', null, {\\n\\t\\t\\t\\t\\t\\tdate: date,\\n\\t\\t\\t\\t\\t\\tdayEl: dayEl,\\n\\t\\t\\t\\t\\t\\tmoreEl: moreEl,\\n\\t\\t\\t\\t\\t\\tsegs: reslicedAllSegs,\\n\\t\\t\\t\\t\\t\\thiddenSegs: reslicedHiddenSegs\\n\\t\\t\\t\\t\\t}, ev);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (clickOption === 'popover') {\\n\\t\\t\\t\\t\\t_this.showSegPopover(row, col, moreEl, reslicedAllSegs);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (typeof clickOption === 'string') { // a view name\\n\\t\\t\\t\\t\\tview.calendar.zoomTo(date, clickOption);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t},\\n\\n\\n\\t// Reveals the popover that displays all events within a cell\\n\\tshowSegPopover: function(row, col, moreLink, segs) {\\n\\t\\tvar _this = this;\\n\\t\\tvar view = this.view;\\n\\t\\tvar moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\\n\\t\\tvar topEl; // the element we want to match the top coordinate of\\n\\t\\tvar options;\\n\\n\\t\\tif (this.rowCnt == 1) {\\n\\t\\t\\ttopEl = view.el; // will cause the popover to cover any sort of header\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ttopEl = this.rowEls.eq(row); // will align with top of row\\n\\t\\t}\\n\\n\\t\\toptions = {\\n\\t\\t\\tclassName: 'fc-more-popover',\\n\\t\\t\\tcontent: this.renderSegPopoverContent(row, col, segs),\\n\\t\\t\\tparentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.\\n\\t\\t\\ttop: topEl.offset().top,\\n\\t\\t\\tautoHide: true, // when the user clicks elsewhere, hide the popover\\n\\t\\t\\tviewportConstrain: view.opt('popoverViewportConstrain'),\\n\\t\\t\\thide: function() {\\n\\t\\t\\t\\t// kill everything when the popover is hidden\\n\\t\\t\\t\\t// notify events to be removed\\n\\t\\t\\t\\tif (_this.popoverSegs) {\\n\\t\\t\\t\\t\\tvar seg;\\n\\t\\t\\t\\t\\tfor (var i = 0; i < _this.popoverSegs.length; ++i) {\\n\\t\\t\\t\\t\\t\\tseg = _this.popoverSegs[i];\\n\\t\\t\\t\\t\\t\\tview.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_this.segPopover.removeElement();\\n\\t\\t\\t\\t_this.segPopover = null;\\n\\t\\t\\t\\t_this.popoverSegs = null;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Determine horizontal coordinate.\\n\\t\\t// We use the moreWrap instead of the <td> to avoid border confusion.\\n\\t\\tif (this.isRTL) {\\n\\t\\t\\toptions.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\toptions.left = moreWrap.offset().left - 1; // -1 to be over cell border\\n\\t\\t}\\n\\n\\t\\tthis.segPopover = new Popover(options);\\n\\t\\tthis.segPopover.show();\\n\\n\\t\\t// the popover doesn't live within the grid's container element, and thus won't get the event\\n\\t\\t// delegated-handlers for free. attach event-related handlers to the popover.\\n\\t\\tthis.bindSegHandlersToEl(this.segPopover.el);\\n\\t},\\n\\n\\n\\t// Builds the inner DOM contents of the segment popover\\n\\trenderSegPopoverContent: function(row, col, segs) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar isTheme = view.opt('theme');\\n\\t\\tvar title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));\\n\\t\\tvar content = $(\\n\\t\\t\\t'<div class=\\\"fc-header ' + view.widgetHeaderClass + '\\\">' +\\n\\t\\t\\t\\t'<span class=\\\"fc-close ' +\\n\\t\\t\\t\\t\\t(isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +\\n\\t\\t\\t\\t'\\\"></span>' +\\n\\t\\t\\t\\t'<span class=\\\"fc-title\\\">' +\\n\\t\\t\\t\\t\\thtmlEscape(title) +\\n\\t\\t\\t\\t'</span>' +\\n\\t\\t\\t\\t'<div class=\\\"fc-clear\\\"/>' +\\n\\t\\t\\t'</div>' +\\n\\t\\t\\t'<div class=\\\"fc-body ' + view.widgetContentClass + '\\\">' +\\n\\t\\t\\t\\t'<div class=\\\"fc-event-container\\\"></div>' +\\n\\t\\t\\t'</div>'\\n\\t\\t);\\n\\t\\tvar segContainer = content.find('.fc-event-container');\\n\\t\\tvar i;\\n\\n\\t\\t// render each seg's `el` and only return the visible segs\\n\\t\\tsegs = this.renderFgSegEls(segs, true); // disableResizing=true\\n\\t\\tthis.popoverSegs = segs;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\n\\t\\t\\t// because segments in the popover are not part of a grid coordinate system, provide a hint to any\\n\\t\\t\\t// grids that want to do drag-n-drop about which cell it came from\\n\\t\\t\\tthis.hitsNeeded();\\n\\t\\t\\tsegs[i].hit = this.getCellHit(row, col);\\n\\t\\t\\tthis.hitsNotNeeded();\\n\\n\\t\\t\\tsegContainer.append(segs[i].el);\\n\\t\\t}\\n\\n\\t\\treturn content;\\n\\t},\\n\\n\\n\\t// Given the events within an array of segment objects, reslice them to be in a single day\\n\\tresliceDaySegs: function(segs, dayDate) {\\n\\n\\t\\t// build an array of the original events\\n\\t\\tvar events = $.map(segs, function(seg) {\\n\\t\\t\\treturn seg.event;\\n\\t\\t});\\n\\n\\t\\tvar dayStart = dayDate.clone();\\n\\t\\tvar dayEnd = dayStart.clone().add(1, 'days');\\n\\t\\tvar dayRange = { start: dayStart, end: dayEnd };\\n\\n\\t\\t// slice the events with a custom slicing function\\n\\t\\tsegs = this.eventsToSegs(\\n\\t\\t\\tevents,\\n\\t\\t\\tfunction(range) {\\n\\t\\t\\t\\tvar seg = intersectRanges(range, dayRange); // undefind if no intersection\\n\\t\\t\\t\\treturn seg ? [ seg ] : []; // must return an array of segments\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\t// force an order because eventsToSegs doesn't guarantee one\\n\\t\\tthis.sortEventSegs(segs);\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t// Generates the text that should be inside a \\\"more\\\" link, given the number of events it represents\\n\\tgetMoreLinkText: function(num) {\\n\\t\\tvar opt = this.view.opt('eventLimitText');\\n\\n\\t\\tif (typeof opt === 'function') {\\n\\t\\t\\treturn opt(num);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn '+' + num + ' ' + opt;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Returns segments within a given cell.\\n\\t// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\\n\\tgetCellSegs: function(row, col, startLevel) {\\n\\t\\tvar segMatrix = this.rowStructs[row].segMatrix;\\n\\t\\tvar level = startLevel || 0;\\n\\t\\tvar segs = [];\\n\\t\\tvar seg;\\n\\n\\t\\twhile (level < segMatrix.length) {\\n\\t\\t\\tseg = segMatrix[level][col];\\n\\t\\t\\tif (seg) {\\n\\t\\t\\t\\tsegs.push(seg);\\n\\t\\t\\t}\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t}\\n\\n});\\n\\n;;\\n\\n/* A component that renders one or more columns of vertical time slots\\n----------------------------------------------------------------------------------------------------------------------*/\\n// We mixin DayTable, even though there is only a single row of days\\n\\nvar TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {\\n\\n\\tslotDuration: null, // duration of a \\\"slot\\\", a distinct time segment on given day, visualized by lines\\n\\tsnapDuration: null, // granularity of time for dragging and selecting\\n\\tsnapsPerSlot: null,\\n\\tlabelFormat: null, // formatting string for times running along vertical axis\\n\\tlabelInterval: null, // duration of how often a label should be displayed for a slot\\n\\n\\tcolEls: null, // cells elements in the day-row background\\n\\tslatContainerEl: null, // div that wraps all the slat rows\\n\\tslatEls: null, // elements running horizontally across all columns\\n\\tnowIndicatorEls: null,\\n\\n\\tcolCoordCache: null,\\n\\tslatCoordCache: null,\\n\\n\\n\\tconstructor: function() {\\n\\t\\tGrid.apply(this, arguments); // call the super-constructor\\n\\n\\t\\tthis.processOptions();\\n\\t},\\n\\n\\n\\t// Renders the time grid into `this.el`, which should already be assigned.\\n\\t// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.\\n\\trenderDates: function() {\\n\\t\\tthis.el.html(this.renderHtml());\\n\\t\\tthis.colEls = this.el.find('.fc-day, .fc-disabled-day');\\n\\t\\tthis.slatContainerEl = this.el.find('.fc-slats');\\n\\t\\tthis.slatEls = this.slatContainerEl.find('tr');\\n\\n\\t\\tthis.colCoordCache = new CoordCache({\\n\\t\\t\\tels: this.colEls,\\n\\t\\t\\tisHorizontal: true\\n\\t\\t});\\n\\t\\tthis.slatCoordCache = new CoordCache({\\n\\t\\t\\tels: this.slatEls,\\n\\t\\t\\tisVertical: true\\n\\t\\t});\\n\\n\\t\\tthis.renderContentSkeleton();\\n\\t},\\n\\n\\n\\t// Renders the basic HTML skeleton for the grid\\n\\trenderHtml: function() {\\n\\t\\treturn '' +\\n\\t\\t\\t'<div class=\\\"fc-bg\\\">' +\\n\\t\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t\\tthis.renderBgTrHtml(0) + // row=0\\n\\t\\t\\t\\t'</table>' +\\n\\t\\t\\t'</div>' +\\n\\t\\t\\t'<div class=\\\"fc-slats\\\">' +\\n\\t\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t\\tthis.renderSlatRowHtml() +\\n\\t\\t\\t\\t'</table>' +\\n\\t\\t\\t'</div>';\\n\\t},\\n\\n\\n\\t// Generates the HTML for the horizontal \\\"slats\\\" that run width-wise. Has a time axis on a side. Depends on RTL.\\n\\trenderSlatRowHtml: function() {\\n\\t\\tvar view = this.view;\\n\\t\\tvar isRTL = this.isRTL;\\n\\t\\tvar html = '';\\n\\t\\tvar slotTime = moment.duration(+this.view.minTime); // wish there was .clone() for durations\\n\\t\\tvar slotDate; // will be on the view's first day, but we only care about its time\\n\\t\\tvar isLabeled;\\n\\t\\tvar axisHtml;\\n\\n\\t\\t// Calculate the time for each slot\\n\\t\\twhile (slotTime < this.view.maxTime) {\\n\\t\\t\\tslotDate = this.start.clone().time(slotTime);\\n\\t\\t\\tisLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));\\n\\n\\t\\t\\taxisHtml =\\n\\t\\t\\t\\t'<td class=\\\"fc-axis fc-time ' + view.widgetContentClass + '\\\" ' + view.axisStyleAttr() + '>' +\\n\\t\\t\\t\\t\\t(isLabeled ?\\n\\t\\t\\t\\t\\t\\t'<span>' + // for matchCellWidths\\n\\t\\t\\t\\t\\t\\t\\thtmlEscape(slotDate.format(this.labelFormat)) +\\n\\t\\t\\t\\t\\t\\t'</span>' :\\n\\t\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t'</td>';\\n\\n\\t\\t\\thtml +=\\n\\t\\t\\t\\t'<tr data-time=\\\"' + slotDate.format('HH:mm:ss') + '\\\"' +\\n\\t\\t\\t\\t\\t(isLabeled ? '' : ' class=\\\"fc-minor\\\"') +\\n\\t\\t\\t\\t\\t'>' +\\n\\t\\t\\t\\t\\t(!isRTL ? axisHtml : '') +\\n\\t\\t\\t\\t\\t'<td class=\\\"' + view.widgetContentClass + '\\\"/>' +\\n\\t\\t\\t\\t\\t(isRTL ? axisHtml : '') +\\n\\t\\t\\t\\t\\\"</tr>\\\";\\n\\n\\t\\t\\tslotTime.add(this.slotDuration);\\n\\t\\t}\\n\\n\\t\\treturn html;\\n\\t},\\n\\n\\n\\t/* Options\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Parses various options into properties of this object\\n\\tprocessOptions: function() {\\n\\t\\tvar view = this.view;\\n\\t\\tvar slotDuration = view.opt('slotDuration');\\n\\t\\tvar snapDuration = view.opt('snapDuration');\\n\\t\\tvar input;\\n\\n\\t\\tslotDuration = moment.duration(slotDuration);\\n\\t\\tsnapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\\n\\n\\t\\tthis.slotDuration = slotDuration;\\n\\t\\tthis.snapDuration = snapDuration;\\n\\t\\tthis.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\\n\\n\\t\\tthis.minResizeDuration = snapDuration; // hack\\n\\n\\t\\t// might be an array value (for TimelineView).\\n\\t\\t// if so, getting the most granular entry (the last one probably).\\n\\t\\tinput = view.opt('slotLabelFormat');\\n\\t\\tif ($.isArray(input)) {\\n\\t\\t\\tinput = input[input.length - 1];\\n\\t\\t}\\n\\n\\t\\tthis.labelFormat =\\n\\t\\t\\tinput ||\\n\\t\\t\\tview.opt('smallTimeFormat'); // the computed default\\n\\n\\t\\tinput = view.opt('slotLabelInterval');\\n\\t\\tthis.labelInterval = input ?\\n\\t\\t\\tmoment.duration(input) :\\n\\t\\t\\tthis.computeLabelInterval(slotDuration);\\n\\t},\\n\\n\\n\\t// Computes an automatic value for slotLabelInterval\\n\\tcomputeLabelInterval: function(slotDuration) {\\n\\t\\tvar i;\\n\\t\\tvar labelInterval;\\n\\t\\tvar slotsPerLabel;\\n\\n\\t\\t// find the smallest stock label interval that results in more than one slots-per-label\\n\\t\\tfor (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\\n\\t\\t\\tlabelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\\n\\t\\t\\tslotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);\\n\\t\\t\\tif (isInt(slotsPerLabel) && slotsPerLabel > 1) {\\n\\t\\t\\t\\treturn labelInterval;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn moment.duration(slotDuration); // fall back. clone\\n\\t},\\n\\n\\n\\t// Computes a default event time formatting string if `timeFormat` is not explicitly defined\\n\\tcomputeEventTimeFormat: function() {\\n\\t\\treturn this.view.opt('noMeridiemTimeFormat'); // like \\\"6:30\\\" (no AM/PM)\\n\\t},\\n\\n\\n\\t// Computes a default `displayEventEnd` value if one is not expliclty defined\\n\\tcomputeDisplayEventEnd: function() {\\n\\t\\treturn true;\\n\\t},\\n\\n\\n\\t/* Hit System\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tprepareHits: function() {\\n\\t\\tthis.colCoordCache.build();\\n\\t\\tthis.slatCoordCache.build();\\n\\t},\\n\\n\\n\\treleaseHits: function() {\\n\\t\\tthis.colCoordCache.clear();\\n\\t\\t// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\\n\\t},\\n\\n\\n\\tqueryHit: function(leftOffset, topOffset) {\\n\\t\\tvar snapsPerSlot = this.snapsPerSlot;\\n\\t\\tvar colCoordCache = this.colCoordCache;\\n\\t\\tvar slatCoordCache = this.slatCoordCache;\\n\\n\\t\\tif (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {\\n\\t\\t\\tvar colIndex = colCoordCache.getHorizontalIndex(leftOffset);\\n\\t\\t\\tvar slatIndex = slatCoordCache.getVerticalIndex(topOffset);\\n\\n\\t\\t\\tif (colIndex != null && slatIndex != null) {\\n\\t\\t\\t\\tvar slatTop = slatCoordCache.getTopOffset(slatIndex);\\n\\t\\t\\t\\tvar slatHeight = slatCoordCache.getHeight(slatIndex);\\n\\t\\t\\t\\tvar partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\\n\\t\\t\\t\\tvar localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\\n\\t\\t\\t\\tvar snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\\n\\t\\t\\t\\tvar snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;\\n\\t\\t\\t\\tvar snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;\\n\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tcol: colIndex,\\n\\t\\t\\t\\t\\tsnap: snapIndex,\\n\\t\\t\\t\\t\\tcomponent: this, // needed unfortunately :(\\n\\t\\t\\t\\t\\tleft: colCoordCache.getLeftOffset(colIndex),\\n\\t\\t\\t\\t\\tright: colCoordCache.getRightOffset(colIndex),\\n\\t\\t\\t\\t\\ttop: snapTop,\\n\\t\\t\\t\\t\\tbottom: snapBottom\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\tgetHitSpan: function(hit) {\\n\\t\\tvar start = this.getCellDate(0, hit.col); // row=0\\n\\t\\tvar time = this.computeSnapTime(hit.snap); // pass in the snap-index\\n\\t\\tvar end;\\n\\n\\t\\tstart.time(time);\\n\\t\\tend = start.clone().add(this.snapDuration);\\n\\n\\t\\treturn { start: start, end: end };\\n\\t},\\n\\n\\n\\tgetHitEl: function(hit) {\\n\\t\\treturn this.colEls.eq(hit.col);\\n\\t},\\n\\n\\n\\t/* Dates\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trangeUpdated: function() {\\n\\t\\tthis.updateDayTable();\\n\\t},\\n\\n\\n\\t// Given a row number of the grid, representing a \\\"snap\\\", returns a time (Duration) from its start-of-day\\n\\tcomputeSnapTime: function(snapIndex) {\\n\\t\\treturn moment.duration(this.view.minTime + this.snapDuration * snapIndex);\\n\\t},\\n\\n\\n\\t// Slices up the given span (unzoned start/end with other misc data) into an array of segments\\n\\tspanToSegs: function(span) {\\n\\t\\tvar segs = this.sliceRangeByTimes(span);\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tif (this.isRTL) {\\n\\t\\t\\t\\tsegs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsegs[i].col = segs[i].dayIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\tsliceRangeByTimes: function(range) {\\n\\t\\tvar segs = [];\\n\\t\\tvar seg;\\n\\t\\tvar dayIndex;\\n\\t\\tvar dayDate;\\n\\t\\tvar dayRange;\\n\\n\\t\\tfor (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\\n\\t\\t\\tdayDate = this.dayDates[dayIndex].clone().time(0); // TODO: better API for this?\\n\\t\\t\\tdayRange = {\\n\\t\\t\\t\\tstart: dayDate.clone().add(this.view.minTime), // don't use .time() because it sux with negatives\\n\\t\\t\\t\\tend: dayDate.clone().add(this.view.maxTime)\\n\\t\\t\\t};\\n\\t\\t\\tseg = intersectRanges(range, dayRange); // both will be ambig timezone\\n\\t\\t\\tif (seg) {\\n\\t\\t\\t\\tseg.dayIndex = dayIndex;\\n\\t\\t\\t\\tsegs.push(seg);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t/* Coordinates\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tupdateSize: function(isResize) { // NOT a standard Grid method\\n\\t\\tthis.slatCoordCache.build();\\n\\n\\t\\tif (isResize) {\\n\\t\\t\\tthis.updateSegVerticals(\\n\\t\\t\\t\\t[].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])\\n\\t\\t\\t);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tgetTotalSlatHeight: function() {\\n\\t\\treturn this.slatContainerEl.outerHeight();\\n\\t},\\n\\n\\n\\t// Computes the top coordinate, relative to the bounds of the grid, of the given date.\\n\\t// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\\n\\tcomputeDateTop: function(date, startOfDayDate) {\\n\\t\\treturn this.computeTimeTop(\\n\\t\\t\\tmoment.duration(\\n\\t\\t\\t\\tdate - startOfDayDate.clone().stripTime()\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\\n\\tcomputeTimeTop: function(time) {\\n\\t\\tvar len = this.slatEls.length;\\n\\t\\tvar slatCoverage = (time - this.view.minTime) / this.slotDuration; // floating-point value of # of slots covered\\n\\t\\tvar slatIndex;\\n\\t\\tvar slatRemainder;\\n\\n\\t\\t// compute a floating-point number for how many slats should be progressed through.\\n\\t\\t// from 0 to number of slats (inclusive)\\n\\t\\t// constrained because minTime/maxTime might be customized.\\n\\t\\tslatCoverage = Math.max(0, slatCoverage);\\n\\t\\tslatCoverage = Math.min(len, slatCoverage);\\n\\n\\t\\t// an integer index of the furthest whole slat\\n\\t\\t// from 0 to number slats (*exclusive*, so len-1)\\n\\t\\tslatIndex = Math.floor(slatCoverage);\\n\\t\\tslatIndex = Math.min(slatIndex, len - 1);\\n\\n\\t\\t// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\\n\\t\\t// could be 1.0 if slatCoverage is covering *all* the slots\\n\\t\\tslatRemainder = slatCoverage - slatIndex;\\n\\n\\t\\treturn this.slatCoordCache.getTopPosition(slatIndex) +\\n\\t\\t\\tthis.slatCoordCache.getHeight(slatIndex) * slatRemainder;\\n\\t},\\n\\n\\n\\n\\t/* Event Drag Visualization\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of an event being dragged over the specified date(s).\\n\\t// A returned value of `true` signals that a mock \\\"helper\\\" event has been rendered.\\n\\trenderDrag: function(eventLocation, seg) {\\n\\t\\tvar eventSpans;\\n\\t\\tvar i;\\n\\n\\t\\tif (seg) { // if there is event information for this drag, render a helper event\\n\\n\\t\\t\\t// returns mock event elements\\n\\t\\t\\t// signal that a helper has been rendered\\n\\t\\t\\treturn this.renderEventLocationHelper(eventLocation, seg);\\n\\t\\t}\\n\\t\\telse { // otherwise, just render a highlight\\n\\t\\t\\teventSpans = this.eventToSpans(eventLocation);\\n\\n\\t\\t\\tfor (i = 0; i < eventSpans.length; i++) {\\n\\t\\t\\t\\tthis.renderHighlight(eventSpans[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Unrenders any visual indication of an event being dragged\\n\\tunrenderDrag: function() {\\n\\t\\tthis.unrenderHelper();\\n\\t\\tthis.unrenderHighlight();\\n\\t},\\n\\n\\n\\t/* Event Resize Visualization\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of an event being resized\\n\\trenderEventResize: function(eventLocation, seg) {\\n\\t\\treturn this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\\n\\t},\\n\\n\\n\\t// Unrenders any visual indication of an event being resized\\n\\tunrenderEventResize: function() {\\n\\t\\tthis.unrenderHelper();\\n\\t},\\n\\n\\n\\t/* Event Helper\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a mock \\\"helper\\\" event. `sourceSeg` is the original segment object and might be null (an external drag)\\n\\trenderHelper: function(event, sourceSeg) {\\n\\t\\treturn this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements\\n\\t},\\n\\n\\n\\t// Unrenders any mock helper event\\n\\tunrenderHelper: function() {\\n\\t\\tthis.unrenderHelperSegs();\\n\\t},\\n\\n\\n\\t/* Business Hours\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderBusinessHours: function() {\\n\\t\\tthis.renderBusinessSegs(\\n\\t\\t\\tthis.buildBusinessHourSegs()\\n\\t\\t);\\n\\t},\\n\\n\\n\\tunrenderBusinessHours: function() {\\n\\t\\tthis.unrenderBusinessSegs();\\n\\t},\\n\\n\\n\\t/* Now Indicator\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tgetNowIndicatorUnit: function() {\\n\\t\\treturn 'minute'; // will refresh on the minute\\n\\t},\\n\\n\\n\\trenderNowIndicator: function(date) {\\n\\t\\t// seg system might be overkill, but it handles scenario where line needs to be rendered\\n\\t\\t//  more than once because of columns with the same date (resources columns for example)\\n\\t\\tvar segs = this.spanToSegs({ start: date, end: date });\\n\\t\\tvar top = this.computeDateTop(date, date);\\n\\t\\tvar nodes = [];\\n\\t\\tvar i;\\n\\n\\t\\t// render lines within the columns\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tnodes.push($('<div class=\\\"fc-now-indicator fc-now-indicator-line\\\"></div>')\\n\\t\\t\\t\\t.css('top', top)\\n\\t\\t\\t\\t.appendTo(this.colContainerEls.eq(segs[i].col))[0]);\\n\\t\\t}\\n\\n\\t\\t// render an arrow over the axis\\n\\t\\tif (segs.length > 0) { // is the current time in view?\\n\\t\\t\\tnodes.push($('<div class=\\\"fc-now-indicator fc-now-indicator-arrow\\\"></div>')\\n\\t\\t\\t\\t.css('top', top)\\n\\t\\t\\t\\t.appendTo(this.el.find('.fc-content-skeleton'))[0]);\\n\\t\\t}\\n\\n\\t\\tthis.nowIndicatorEls = $(nodes);\\n\\t},\\n\\n\\n\\tunrenderNowIndicator: function() {\\n\\t\\tif (this.nowIndicatorEls) {\\n\\t\\t\\tthis.nowIndicatorEls.remove();\\n\\t\\t\\tthis.nowIndicatorEls = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Selection\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\\n\\trenderSelection: function(span) {\\n\\t\\tif (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered\\n\\n\\t\\t\\t// normally acceps an eventLocation, span has a start/end, which is good enough\\n\\t\\t\\tthis.renderEventLocationHelper(span);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.renderHighlight(span);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Unrenders any visual indication of a selection\\n\\tunrenderSelection: function() {\\n\\t\\tthis.unrenderHelper();\\n\\t\\tthis.unrenderHighlight();\\n\\t},\\n\\n\\n\\t/* Highlight\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderHighlight: function(span) {\\n\\t\\tthis.renderHighlightSegs(this.spanToSegs(span));\\n\\t},\\n\\n\\n\\tunrenderHighlight: function() {\\n\\t\\tthis.unrenderHighlightSegs();\\n\\t}\\n\\n});\\n\\n;;\\n\\n/* Methods for rendering SEGMENTS, pieces of content that live on the view\\n ( this file is no longer just for events )\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nTimeGrid.mixin({\\n\\n\\tcolContainerEls: null, // containers for each column\\n\\n\\t// inner-containers for each column where different types of segs live\\n\\tfgContainerEls: null,\\n\\tbgContainerEls: null,\\n\\thelperContainerEls: null,\\n\\thighlightContainerEls: null,\\n\\tbusinessContainerEls: null,\\n\\n\\t// arrays of different types of displayed segments\\n\\tfgSegs: null,\\n\\tbgSegs: null,\\n\\thelperSegs: null,\\n\\thighlightSegs: null,\\n\\tbusinessSegs: null,\\n\\n\\n\\t// Renders the DOM that the view's content will live in\\n\\trenderContentSkeleton: function() {\\n\\t\\tvar cellHtml = '';\\n\\t\\tvar i;\\n\\t\\tvar skeletonEl;\\n\\n\\t\\tfor (i = 0; i < this.colCnt; i++) {\\n\\t\\t\\tcellHtml +=\\n\\t\\t\\t\\t'<td>' +\\n\\t\\t\\t\\t\\t'<div class=\\\"fc-content-col\\\">' +\\n\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-event-container fc-helper-container\\\"></div>' +\\n\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-event-container\\\"></div>' +\\n\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-highlight-container\\\"></div>' +\\n\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-bgevent-container\\\"></div>' +\\n\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-business-container\\\"></div>' +\\n\\t\\t\\t\\t\\t'</div>' +\\n\\t\\t\\t\\t'</td>';\\n\\t\\t}\\n\\n\\t\\tskeletonEl = $(\\n\\t\\t\\t'<div class=\\\"fc-content-skeleton\\\">' +\\n\\t\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t\\t'<tr>' + cellHtml + '</tr>' +\\n\\t\\t\\t\\t'</table>' +\\n\\t\\t\\t'</div>'\\n\\t\\t);\\n\\n\\t\\tthis.colContainerEls = skeletonEl.find('.fc-content-col');\\n\\t\\tthis.helperContainerEls = skeletonEl.find('.fc-helper-container');\\n\\t\\tthis.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\\n\\t\\tthis.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\\n\\t\\tthis.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\\n\\t\\tthis.businessContainerEls = skeletonEl.find('.fc-business-container');\\n\\n\\t\\tthis.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\\n\\t\\tthis.el.append(skeletonEl);\\n\\t},\\n\\n\\n\\t/* Foreground Events\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderFgSegs: function(segs) {\\n\\t\\tsegs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);\\n\\t\\tthis.fgSegs = segs;\\n\\t\\treturn segs; // needed for Grid::renderEvents\\n\\t},\\n\\n\\n\\tunrenderFgSegs: function() {\\n\\t\\tthis.unrenderNamedSegs('fgSegs');\\n\\t},\\n\\n\\n\\t/* Foreground Helper Events\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderHelperSegs: function(segs, sourceSeg) {\\n\\t\\tvar helperEls = [];\\n\\t\\tvar i, seg;\\n\\t\\tvar sourceEl;\\n\\n\\t\\tsegs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);\\n\\n\\t\\t// Try to make the segment that is in the same row as sourceSeg look the same\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\t\\t\\tif (sourceSeg && sourceSeg.col === seg.col) {\\n\\t\\t\\t\\tsourceEl = sourceSeg.el;\\n\\t\\t\\t\\tseg.el.css({\\n\\t\\t\\t\\t\\tleft: sourceEl.css('left'),\\n\\t\\t\\t\\t\\tright: sourceEl.css('right'),\\n\\t\\t\\t\\t\\t'margin-left': sourceEl.css('margin-left'),\\n\\t\\t\\t\\t\\t'margin-right': sourceEl.css('margin-right')\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\thelperEls.push(seg.el[0]);\\n\\t\\t}\\n\\n\\t\\tthis.helperSegs = segs;\\n\\n\\t\\treturn $(helperEls); // must return rendered helpers\\n\\t},\\n\\n\\n\\tunrenderHelperSegs: function() {\\n\\t\\tthis.unrenderNamedSegs('helperSegs');\\n\\t},\\n\\n\\n\\t/* Background Events\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderBgSegs: function(segs) {\\n\\t\\tsegs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system\\n\\t\\tthis.updateSegVerticals(segs);\\n\\t\\tthis.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);\\n\\t\\tthis.bgSegs = segs;\\n\\t\\treturn segs; // needed for Grid::renderEvents\\n\\t},\\n\\n\\n\\tunrenderBgSegs: function() {\\n\\t\\tthis.unrenderNamedSegs('bgSegs');\\n\\t},\\n\\n\\n\\t/* Highlight\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderHighlightSegs: function(segs) {\\n\\t\\tsegs = this.renderFillSegEls('highlight', segs); // TODO: old fill system\\n\\t\\tthis.updateSegVerticals(segs);\\n\\t\\tthis.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);\\n\\t\\tthis.highlightSegs = segs;\\n\\t},\\n\\n\\n\\tunrenderHighlightSegs: function() {\\n\\t\\tthis.unrenderNamedSegs('highlightSegs');\\n\\t},\\n\\n\\n\\t/* Business Hours\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderBusinessSegs: function(segs) {\\n\\t\\tsegs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system\\n\\t\\tthis.updateSegVerticals(segs);\\n\\t\\tthis.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);\\n\\t\\tthis.businessSegs = segs;\\n\\t},\\n\\n\\n\\tunrenderBusinessSegs: function() {\\n\\t\\tthis.unrenderNamedSegs('businessSegs');\\n\\t},\\n\\n\\n\\t/* Seg Rendering Utils\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\\n\\tgroupSegsByCol: function(segs) {\\n\\t\\tvar segsByCol = [];\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < this.colCnt; i++) {\\n\\t\\t\\tsegsByCol.push([]);\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tsegsByCol[segs[i].col].push(segs[i]);\\n\\t\\t}\\n\\n\\t\\treturn segsByCol;\\n\\t},\\n\\n\\n\\t// Given segments grouped by column, insert the segments' elements into a parallel array of container\\n\\t// elements, each living within a column.\\n\\tattachSegsByCol: function(segsByCol, containerEls) {\\n\\t\\tvar col;\\n\\t\\tvar segs;\\n\\t\\tvar i;\\n\\n\\t\\tfor (col = 0; col < this.colCnt; col++) { // iterate each column grouping\\n\\t\\t\\tsegs = segsByCol[col];\\n\\n\\t\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\t\\tcontainerEls.eq(col).append(segs[i].el);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Given the name of a property of `this` object, assumed to be an array of segments,\\n\\t// loops through each segment and removes from DOM. Will null-out the property afterwards.\\n\\tunrenderNamedSegs: function(propName) {\\n\\t\\tvar segs = this[propName];\\n\\t\\tvar i;\\n\\n\\t\\tif (segs) {\\n\\t\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\t\\tsegs[i].el.remove();\\n\\t\\t\\t}\\n\\t\\t\\tthis[propName] = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\n\\t/* Foreground Event Rendering Utils\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Given an array of foreground segments, render a DOM element for each, computes position,\\n\\t// and attaches to the column inner-container elements.\\n\\trenderFgSegsIntoContainers: function(segs, containerEls) {\\n\\t\\tvar segsByCol;\\n\\t\\tvar col;\\n\\n\\t\\tsegs = this.renderFgSegEls(segs); // will call fgSegHtml\\n\\t\\tsegsByCol = this.groupSegsByCol(segs);\\n\\n\\t\\tfor (col = 0; col < this.colCnt; col++) {\\n\\t\\t\\tthis.updateFgSegCoords(segsByCol[col]);\\n\\t\\t}\\n\\n\\t\\tthis.attachSegsByCol(segsByCol, containerEls);\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\n\\t// Renders the HTML for a single event segment's default rendering\\n\\tfgSegHtml: function(seg, disableResizing) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar event = seg.event;\\n\\t\\tvar isDraggable = view.isEventDraggable(event);\\n\\t\\tvar isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);\\n\\t\\tvar isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);\\n\\t\\tvar classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\\n\\t\\tvar skinCss = cssToStr(this.getSegSkinCss(seg));\\n\\t\\tvar timeText;\\n\\t\\tvar fullTimeText; // more verbose time text. for the print stylesheet\\n\\t\\tvar startTimeText; // just the start time text\\n\\n\\t\\tclasses.unshift('fc-time-grid-event', 'fc-v-event');\\n\\n\\t\\tif (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...\\n\\t\\t\\t// Don't display time text on segments that run entirely through a day.\\n\\t\\t\\t// That would appear as midnight-midnight and would look dumb.\\n\\t\\t\\t// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\\n\\t\\t\\tif (seg.isStart || seg.isEnd) {\\n\\t\\t\\t\\ttimeText = this.getEventTimeText(seg);\\n\\t\\t\\t\\tfullTimeText = this.getEventTimeText(seg, 'LT');\\n\\t\\t\\t\\tstartTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Display the normal time text for the *event's* times\\n\\t\\t\\ttimeText = this.getEventTimeText(event);\\n\\t\\t\\tfullTimeText = this.getEventTimeText(event, 'LT');\\n\\t\\t\\tstartTimeText = this.getEventTimeText(event, null, false); // displayEnd=false\\n\\t\\t}\\n\\n\\t\\treturn '<a class=\\\"' + classes.join(' ') + '\\\"' +\\n\\t\\t\\t(event.url ?\\n\\t\\t\\t\\t' href=\\\"' + htmlEscape(event.url) + '\\\"' :\\n\\t\\t\\t\\t''\\n\\t\\t\\t\\t) +\\n\\t\\t\\t(skinCss ?\\n\\t\\t\\t\\t' style=\\\"' + skinCss + '\\\"' :\\n\\t\\t\\t\\t''\\n\\t\\t\\t\\t) +\\n\\t\\t\\t'>' +\\n\\t\\t\\t\\t'<div class=\\\"fc-content\\\">' +\\n\\t\\t\\t\\t\\t(timeText ?\\n\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-time\\\"' +\\n\\t\\t\\t\\t\\t\\t' data-start=\\\"' + htmlEscape(startTimeText) + '\\\"' +\\n\\t\\t\\t\\t\\t\\t' data-full=\\\"' + htmlEscape(fullTimeText) + '\\\"' +\\n\\t\\t\\t\\t\\t\\t'>' +\\n\\t\\t\\t\\t\\t\\t\\t'<span>' + htmlEscape(timeText) + '</span>' +\\n\\t\\t\\t\\t\\t\\t'</div>' :\\n\\t\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t\\t(event.title ?\\n\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-title\\\">' +\\n\\t\\t\\t\\t\\t\\t\\thtmlEscape(event.title) +\\n\\t\\t\\t\\t\\t\\t'</div>' :\\n\\t\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t'</div>' +\\n\\t\\t\\t\\t'<div class=\\\"fc-bg\\\"/>' +\\n\\t\\t\\t\\t/* TODO: write CSS for this\\n\\t\\t\\t\\t(isResizableFromStart ?\\n\\t\\t\\t\\t\\t'<div class=\\\"fc-resizer fc-start-resizer\\\" />' :\\n\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t*/\\n\\t\\t\\t\\t(isResizableFromEnd ?\\n\\t\\t\\t\\t\\t'<div class=\\\"fc-resizer fc-end-resizer\\\" />' :\\n\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t'</a>';\\n\\t},\\n\\n\\n\\t/* Seg Position Utils\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Refreshes the CSS top/bottom coordinates for each segment element.\\n\\t// Works when called after initial render, after a window resize/zoom for example.\\n\\tupdateSegVerticals: function(segs) {\\n\\t\\tthis.computeSegVerticals(segs);\\n\\t\\tthis.assignSegVerticals(segs);\\n\\t},\\n\\n\\n\\t// For each segment in an array, computes and assigns its top and bottom properties\\n\\tcomputeSegVerticals: function(segs) {\\n\\t\\tvar i, seg;\\n\\t\\tvar dayDate;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\t\\t\\tdayDate = this.dayDates[seg.dayIndex];\\n\\n\\t\\t\\tseg.top = this.computeDateTop(seg.start, dayDate);\\n\\t\\t\\tseg.bottom = this.computeDateTop(seg.end, dayDate);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Given segments that already have their top/bottom properties computed, applies those values to\\n\\t// the segments' elements.\\n\\tassignSegVerticals: function(segs) {\\n\\t\\tvar i, seg;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\t\\t\\tseg.el.css(this.generateSegVerticalCss(seg));\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Generates an object with CSS properties for the top/bottom coordinates of a segment element\\n\\tgenerateSegVerticalCss: function(seg) {\\n\\t\\treturn {\\n\\t\\t\\ttop: seg.top,\\n\\t\\t\\tbottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\\n\\t\\t};\\n\\t},\\n\\n\\n\\t/* Foreground Event Positioning Utils\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Given segments that are assumed to all live in the *same column*,\\n\\t// compute their verical/horizontal coordinates and assign to their elements.\\n\\tupdateFgSegCoords: function(segs) {\\n\\t\\tthis.computeSegVerticals(segs); // horizontals relies on this\\n\\t\\tthis.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\\n\\t\\tthis.assignSegVerticals(segs);\\n\\t\\tthis.assignFgSegHorizontals(segs);\\n\\t},\\n\\n\\n\\t// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\\n\\t// NOTE: Also reorders the given array by date!\\n\\tcomputeFgSegHorizontals: function(segs) {\\n\\t\\tvar levels;\\n\\t\\tvar level0;\\n\\t\\tvar i;\\n\\n\\t\\tthis.sortEventSegs(segs); // order by certain criteria\\n\\t\\tlevels = buildSlotSegLevels(segs);\\n\\t\\tcomputeForwardSlotSegs(levels);\\n\\n\\t\\tif ((level0 = levels[0])) {\\n\\n\\t\\t\\tfor (i = 0; i < level0.length; i++) {\\n\\t\\t\\t\\tcomputeSlotSegPressures(level0[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (i = 0; i < level0.length; i++) {\\n\\t\\t\\t\\tthis.computeFgSegForwardBack(level0[i], 0, 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\\n\\t// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \\\"left\\\" and\\n\\t// seg.forwardCoord maps to \\\"right\\\" (via percentage). Vice-versa if the calendar is right-to-left.\\n\\t//\\n\\t// The segment might be part of a \\\"series\\\", which means consecutive segments with the same pressure\\n\\t// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\\n\\t// segments behind this one in the current series, and `seriesBackwardCoord` is the starting\\n\\t// coordinate of the first segment in the series.\\n\\tcomputeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {\\n\\t\\tvar forwardSegs = seg.forwardSegs;\\n\\t\\tvar i;\\n\\n\\t\\tif (seg.forwardCoord === undefined) { // not already computed\\n\\n\\t\\t\\tif (!forwardSegs.length) {\\n\\n\\t\\t\\t\\t// if there are no forward segments, this segment should butt up against the edge\\n\\t\\t\\t\\tseg.forwardCoord = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\n\\t\\t\\t\\t// sort highest pressure first\\n\\t\\t\\t\\tthis.sortForwardSegs(forwardSegs);\\n\\n\\t\\t\\t\\t// this segment's forwardCoord will be calculated from the backwardCoord of the\\n\\t\\t\\t\\t// highest-pressure forward segment.\\n\\t\\t\\t\\tthis.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\\n\\t\\t\\t\\tseg.forwardCoord = forwardSegs[0].backwardCoord;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// calculate the backwardCoord from the forwardCoord. consider the series\\n\\t\\t\\tseg.backwardCoord = seg.forwardCoord -\\n\\t\\t\\t\\t(seg.forwardCoord - seriesBackwardCoord) / // available width for series\\n\\t\\t\\t\\t(seriesBackwardPressure + 1); // # of segments in the series\\n\\n\\t\\t\\t// use this segment's coordinates to computed the coordinates of the less-pressurized\\n\\t\\t\\t// forward segments\\n\\t\\t\\tfor (i=0; i<forwardSegs.length; i++) {\\n\\t\\t\\t\\tthis.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\tsortForwardSegs: function(forwardSegs) {\\n\\t\\tforwardSegs.sort(proxy(this, 'compareForwardSegs'));\\n\\t},\\n\\n\\n\\t// A cmp function for determining which forward segment to rely on more when computing coordinates.\\n\\tcompareForwardSegs: function(seg1, seg2) {\\n\\t\\t// put higher-pressure first\\n\\t\\treturn seg2.forwardPressure - seg1.forwardPressure ||\\n\\t\\t\\t// put segments that are closer to initial edge first (and favor ones with no coords yet)\\n\\t\\t\\t(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||\\n\\t\\t\\t// do normal sorting...\\n\\t\\t\\tthis.compareEventSegs(seg1, seg2);\\n\\t},\\n\\n\\n\\t// Given foreground event segments that have already had their position coordinates computed,\\n\\t// assigns position-related CSS values to their elements.\\n\\tassignFgSegHorizontals: function(segs) {\\n\\t\\tvar i, seg;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\t\\t\\tseg.el.css(this.generateFgSegHorizontalCss(seg));\\n\\n\\t\\t\\t// if the height is short, add a className for alternate styling\\n\\t\\t\\tif (seg.bottom - seg.top < 30) {\\n\\t\\t\\t\\tseg.el.addClass('fc-short');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Generates an object with CSS properties/values that should be applied to an event segment element.\\n\\t// Contains important positioning-related properties that should be applied to any event element, customized or not.\\n\\tgenerateFgSegHorizontalCss: function(seg) {\\n\\t\\tvar shouldOverlap = this.view.opt('slotEventOverlap');\\n\\t\\tvar backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\\n\\t\\tvar forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\\n\\t\\tvar props = this.generateSegVerticalCss(seg); // get top/bottom first\\n\\t\\tvar left; // amount of space from left edge, a fraction of the total width\\n\\t\\tvar right; // amount of space from right edge, a fraction of the total width\\n\\n\\t\\tif (shouldOverlap) {\\n\\t\\t\\t// double the width, but don't go beyond the maximum forward coordinate (1.0)\\n\\t\\t\\tforwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\\n\\t\\t}\\n\\n\\t\\tif (this.isRTL) {\\n\\t\\t\\tleft = 1 - forwardCoord;\\n\\t\\t\\tright = backwardCoord;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tleft = backwardCoord;\\n\\t\\t\\tright = 1 - forwardCoord;\\n\\t\\t}\\n\\n\\t\\tprops.zIndex = seg.level + 1; // convert from 0-base to 1-based\\n\\t\\tprops.left = left * 100 + '%';\\n\\t\\tprops.right = right * 100 + '%';\\n\\n\\t\\tif (shouldOverlap && seg.forwardPressure) {\\n\\t\\t\\t// add padding to the edge so that forward stacked events don't cover the resizer's icon\\n\\t\\t\\tprops[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\\n\\t\\t}\\n\\n\\t\\treturn props;\\n\\t}\\n\\n});\\n\\n\\n// Builds an array of segments \\\"levels\\\". The first level will be the leftmost tier of segments if the calendar is\\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\\nfunction buildSlotSegLevels(segs) {\\n\\tvar levels = [];\\n\\tvar i, seg;\\n\\tvar j;\\n\\n\\tfor (i=0; i<segs.length; i++) {\\n\\t\\tseg = segs[i];\\n\\n\\t\\t// go through all the levels and stop on the first level where there are no collisions\\n\\t\\tfor (j=0; j<levels.length; j++) {\\n\\t\\t\\tif (!computeSlotSegCollisions(seg, levels[j]).length) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tseg.level = j;\\n\\n\\t\\t(levels[j] || (levels[j] = [])).push(seg);\\n\\t}\\n\\n\\treturn levels;\\n}\\n\\n\\n// For every segment, figure out the other segments that are in subsequent\\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\\nfunction computeForwardSlotSegs(levels) {\\n\\tvar i, level;\\n\\tvar j, seg;\\n\\tvar k;\\n\\n\\tfor (i=0; i<levels.length; i++) {\\n\\t\\tlevel = levels[i];\\n\\n\\t\\tfor (j=0; j<level.length; j++) {\\n\\t\\t\\tseg = level[j];\\n\\n\\t\\t\\tseg.forwardSegs = [];\\n\\t\\t\\tfor (k=i+1; k<levels.length; k++) {\\n\\t\\t\\t\\tcomputeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n\\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\\nfunction computeSlotSegPressures(seg) {\\n\\tvar forwardSegs = seg.forwardSegs;\\n\\tvar forwardPressure = 0;\\n\\tvar i, forwardSeg;\\n\\n\\tif (seg.forwardPressure === undefined) { // not already computed\\n\\n\\t\\tfor (i=0; i<forwardSegs.length; i++) {\\n\\t\\t\\tforwardSeg = forwardSegs[i];\\n\\n\\t\\t\\t// figure out the child's maximum forward path\\n\\t\\t\\tcomputeSlotSegPressures(forwardSeg);\\n\\n\\t\\t\\t// either use the existing maximum, or use the child's forward pressure\\n\\t\\t\\t// plus one (for the forwardSeg itself)\\n\\t\\t\\tforwardPressure = Math.max(\\n\\t\\t\\t\\tforwardPressure,\\n\\t\\t\\t\\t1 + forwardSeg.forwardPressure\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tseg.forwardPressure = forwardPressure;\\n\\t}\\n}\\n\\n\\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\\n// Append into an optionally-supplied `results` array and return.\\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\\n\\tresults = results || [];\\n\\n\\tfor (var i=0; i<otherSegs.length; i++) {\\n\\t\\tif (isSlotSegCollision(seg, otherSegs[i])) {\\n\\t\\t\\tresults.push(otherSegs[i]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn results;\\n}\\n\\n\\n// Do these segments occupy the same vertical space?\\nfunction isSlotSegCollision(seg1, seg2) {\\n\\treturn seg1.bottom > seg2.top && seg1.top < seg2.bottom;\\n}\\n\\n;;\\n\\n/* An abstract class from which other views inherit from\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nvar View = FC.View = Model.extend({\\n\\n\\ttype: null, // subclass' view name (string)\\n\\tname: null, // deprecated. use `type` instead\\n\\ttitle: null, // the text that will be displayed in the header's title\\n\\n\\tcalendar: null, // owner Calendar object\\n\\tviewSpec: null,\\n\\toptions: null, // hash containing all options. already merged with view-specific-options\\n\\tel: null, // the view's containing element. set by Calendar\\n\\n\\trenderQueue: null,\\n\\tbatchRenderDepth: 0,\\n\\tisDatesRendered: false,\\n\\tisEventsRendered: false,\\n\\tisBaseRendered: false, // related to viewRender/viewDestroy triggers\\n\\n\\tqueuedScroll: null,\\n\\n\\tisRTL: false,\\n\\tisSelected: false, // boolean whether a range of time is user-selected or not\\n\\tselectedEvent: null,\\n\\n\\teventOrderSpecs: null, // criteria for ordering events when they have same date/time\\n\\n\\t// classNames styled by jqui themes\\n\\twidgetHeaderClass: null,\\n\\twidgetContentClass: null,\\n\\thighlightStateClass: null,\\n\\n\\t// for date utils, computed from options\\n\\tnextDayThreshold: null,\\n\\tisHiddenDayHash: null,\\n\\n\\t// now indicator\\n\\tisNowIndicatorRendered: null,\\n\\tinitialNowDate: null, // result first getNow call\\n\\tinitialNowQueriedMs: null, // ms time the getNow was called\\n\\tnowIndicatorTimeoutID: null, // for refresh timing of now indicator\\n\\tnowIndicatorIntervalID: null, // \\\"\\n\\n\\n\\tconstructor: function(calendar, viewSpec) {\\n\\t\\tModel.prototype.constructor.call(this);\\n\\n\\t\\tthis.calendar = calendar;\\n\\t\\tthis.viewSpec = viewSpec;\\n\\n\\t\\t// shortcuts\\n\\t\\tthis.type = viewSpec.type;\\n\\t\\tthis.options = viewSpec.options;\\n\\n\\t\\t// .name is deprecated\\n\\t\\tthis.name = this.type;\\n\\n\\t\\tthis.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));\\n\\t\\tthis.initThemingProps();\\n\\t\\tthis.initHiddenDays();\\n\\t\\tthis.isRTL = this.opt('isRTL');\\n\\n\\t\\tthis.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));\\n\\n\\t\\tthis.renderQueue = this.buildRenderQueue();\\n\\t\\tthis.initAutoBatchRender();\\n\\n\\t\\tthis.initialize();\\n\\t},\\n\\n\\n\\tbuildRenderQueue: function() {\\n\\t\\tvar _this = this;\\n\\t\\tvar renderQueue = new RenderQueue({\\n\\t\\t\\tevent: this.opt('eventRenderWait')\\n\\t\\t});\\n\\n\\t\\trenderQueue.on('start', function() {\\n\\t\\t\\t_this.freezeHeight();\\n\\t\\t\\t_this.addScroll(_this.queryScroll());\\n\\t\\t});\\n\\n\\t\\trenderQueue.on('stop', function() {\\n\\t\\t\\t_this.thawHeight();\\n\\t\\t\\t_this.popScroll();\\n\\t\\t});\\n\\n\\t\\treturn renderQueue;\\n\\t},\\n\\n\\n\\tinitAutoBatchRender: function() {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.on('before:change', function() {\\n\\t\\t\\t_this.startBatchRender();\\n\\t\\t});\\n\\n\\t\\tthis.on('change', function() {\\n\\t\\t\\t_this.stopBatchRender();\\n\\t\\t});\\n\\t},\\n\\n\\n\\tstartBatchRender: function() {\\n\\t\\tif (!(this.batchRenderDepth++)) {\\n\\t\\t\\tthis.renderQueue.pause();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tstopBatchRender: function() {\\n\\t\\tif (!(--this.batchRenderDepth)) {\\n\\t\\t\\tthis.renderQueue.resume();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// A good place for subclasses to initialize member variables\\n\\tinitialize: function() {\\n\\t\\t// subclasses can implement\\n\\t},\\n\\n\\n\\t// Retrieves an option with the given name\\n\\topt: function(name) {\\n\\t\\treturn this.options[name];\\n\\t},\\n\\n\\n\\t// Triggers handlers that are view-related. Modifies args before passing to calendar.\\n\\tpubliclyTrigger: function(name, thisObj) { // arguments beyond thisObj are passed along\\n\\t\\tvar calendar = this.calendar;\\n\\n\\t\\treturn calendar.publiclyTrigger.apply(\\n\\t\\t\\tcalendar,\\n\\t\\t\\t[name, thisObj || this].concat(\\n\\t\\t\\t\\tArray.prototype.slice.call(arguments, 2), // arguments beyond thisObj\\n\\t\\t\\t\\t[ this ] // always make the last argument a reference to the view. TODO: deprecate\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\n\\t/* Title and Date Formatting\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Sets the view's title property to the most updated computed value\\n\\tupdateTitle: function() {\\n\\t\\tthis.title = this.computeTitle();\\n\\t\\tthis.calendar.setToolbarsTitle(this.title);\\n\\t},\\n\\n\\n\\t// Computes what the title at the top of the calendar should be for this view\\n\\tcomputeTitle: function() {\\n\\t\\tvar range;\\n\\n\\t\\t// for views that span a large unit of time, show the proper interval, ignoring stray days before and after\\n\\t\\tif (/^(year|month)$/.test(this.currentRangeUnit)) {\\n\\t\\t\\trange = this.currentRange;\\n\\t\\t}\\n\\t\\telse { // for day units or smaller, use the actual day range\\n\\t\\t\\trange = this.activeRange;\\n\\t\\t}\\n\\n\\t\\treturn this.formatRange(\\n\\t\\t\\t{\\n\\t\\t\\t\\t// in case currentRange has a time, make sure timezone is correct\\n\\t\\t\\t\\tstart: this.calendar.applyTimezone(range.start),\\n\\t\\t\\t\\tend: this.calendar.applyTimezone(range.end)\\n\\t\\t\\t},\\n\\t\\t\\tthis.opt('titleFormat') || this.computeTitleFormat(),\\n\\t\\t\\tthis.opt('titleRangeSeparator')\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Generates the format string that should be used to generate the title for the current date range.\\n\\t// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\\n\\tcomputeTitleFormat: function() {\\n\\t\\tif (this.currentRangeUnit == 'year') {\\n\\t\\t\\treturn 'YYYY';\\n\\t\\t}\\n\\t\\telse if (this.currentRangeUnit == 'month') {\\n\\t\\t\\treturn this.opt('monthYearFormat'); // like \\\"September 2014\\\"\\n\\t\\t}\\n\\t\\telse if (this.currentRangeAs('days') > 1) {\\n\\t\\t\\treturn 'll'; // multi-day range. shorter, like \\\"Sep 9 - 10 2014\\\"\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn 'LL'; // one day. longer, like \\\"September 9 2014\\\"\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\\n\\t// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\\n\\t// The timezones of the dates within `range` will be respected.\\n\\tformatRange: function(range, formatStr, separator) {\\n\\t\\tvar end = range.end;\\n\\n\\t\\tif (!end.hasTime()) { // all-day?\\n\\t\\t\\tend = end.clone().subtract(1); // convert to inclusive. last ms of previous day\\n\\t\\t}\\n\\n\\t\\treturn formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));\\n\\t},\\n\\n\\n\\tgetAllDayHtml: function() {\\n\\t\\treturn this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));\\n\\t},\\n\\n\\n\\t/* Navigation\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Generates HTML for an anchor to another view into the calendar.\\n\\t// Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\\n\\t// `gotoOptions` can either be a moment input, or an object with the form:\\n\\t// { date, type, forceOff }\\n\\t// `type` is a view-type like \\\"day\\\" or \\\"week\\\". default value is \\\"day\\\".\\n\\t// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\\n\\tbuildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {\\n\\t\\tvar date, type, forceOff;\\n\\t\\tvar finalOptions;\\n\\n\\t\\tif ($.isPlainObject(gotoOptions)) {\\n\\t\\t\\tdate = gotoOptions.date;\\n\\t\\t\\ttype = gotoOptions.type;\\n\\t\\t\\tforceOff = gotoOptions.forceOff;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdate = gotoOptions; // a single moment input\\n\\t\\t}\\n\\t\\tdate = FC.moment(date); // if a string, parse it\\n\\n\\t\\tfinalOptions = { // for serialization into the link\\n\\t\\t\\tdate: date.format('YYYY-MM-DD'),\\n\\t\\t\\ttype: type || 'day'\\n\\t\\t};\\n\\n\\t\\tif (typeof attrs === 'string') {\\n\\t\\t\\tinnerHtml = attrs;\\n\\t\\t\\tattrs = null;\\n\\t\\t}\\n\\n\\t\\tattrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space\\n\\t\\tinnerHtml = innerHtml || '';\\n\\n\\t\\tif (!forceOff && this.opt('navLinks')) {\\n\\t\\t\\treturn '<a' + attrs +\\n\\t\\t\\t\\t' data-goto=\\\"' + htmlEscape(JSON.stringify(finalOptions)) + '\\\">' +\\n\\t\\t\\t\\tinnerHtml +\\n\\t\\t\\t\\t'</a>';\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn '<span' + attrs + '>' +\\n\\t\\t\\t\\tinnerHtml +\\n\\t\\t\\t\\t'</span>';\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Rendering Non-date-related Content\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Sets the container element that the view should render inside of, does global DOM-related initializations,\\n\\t// and renders all the non-date-related content inside.\\n\\tsetElement: function(el) {\\n\\t\\tthis.el = el;\\n\\t\\tthis.bindGlobalHandlers();\\n\\t\\tthis.bindBaseRenderHandlers();\\n\\t\\tthis.renderSkeleton();\\n\\t},\\n\\n\\n\\t// Removes the view's container element from the DOM, clearing any content beforehand.\\n\\t// Undoes any other DOM-related attachments.\\n\\tremoveElement: function() {\\n\\t\\tthis.unsetDate();\\n\\t\\tthis.unrenderSkeleton();\\n\\n\\t\\tthis.unbindGlobalHandlers();\\n\\t\\tthis.unbindBaseRenderHandlers();\\n\\n\\t\\tthis.el.remove();\\n\\t\\t// NOTE: don't null-out this.el in case the View was destroyed within an API callback.\\n\\t\\t// We don't null-out the View's other jQuery element references upon destroy,\\n\\t\\t//  so we shouldn't kill this.el either.\\n\\t},\\n\\n\\n\\t// Renders the basic structure of the view before any content is rendered\\n\\trenderSkeleton: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Unrenders the basic structure of the view\\n\\tunrenderSkeleton: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Date Setting/Unsetting\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tsetDate: function(date) {\\n\\t\\tvar currentDateProfile = this.get('dateProfile');\\n\\t\\tvar newDateProfile = this.buildDateProfile(date, null, true); // forceToValid=true\\n\\n\\t\\tif (\\n\\t\\t\\t!currentDateProfile ||\\n\\t\\t\\t!isRangesEqual(currentDateProfile.activeRange, newDateProfile.activeRange)\\n\\t\\t) {\\n\\t\\t\\tthis.set('dateProfile', newDateProfile);\\n\\t\\t}\\n\\n\\t\\treturn newDateProfile.date;\\n\\t},\\n\\n\\n\\tunsetDate: function() {\\n\\t\\tthis.unset('dateProfile');\\n\\t},\\n\\n\\n\\t// Date Rendering\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\trequestDateRender: function(dateProfile) {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.renderQueue.queue(function() {\\n\\t\\t\\t_this.executeDateRender(dateProfile);\\n\\t\\t}, 'date', 'init');\\n\\t},\\n\\n\\n\\trequestDateUnrender: function() {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.renderQueue.queue(function() {\\n\\t\\t\\t_this.executeDateUnrender();\\n\\t\\t}, 'date', 'destroy');\\n\\t},\\n\\n\\n\\t// Event Data\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tfetchInitialEvents: function(dateProfile) {\\n\\t\\treturn this.calendar.requestEvents(\\n\\t\\t\\tdateProfile.activeRange.start,\\n\\t\\t\\tdateProfile.activeRange.end\\n\\t\\t);\\n\\t},\\n\\n\\n\\tbindEventChanges: function() {\\n\\t\\tthis.listenTo(this.calendar, 'eventsReset', this.resetEvents);\\n\\t},\\n\\n\\n\\tunbindEventChanges: function() {\\n\\t\\tthis.stopListeningTo(this.calendar, 'eventsReset');\\n\\t},\\n\\n\\n\\tsetEvents: function(events) {\\n\\t\\tthis.set('currentEvents', events);\\n\\t\\tthis.set('hasEvents', true);\\n\\t},\\n\\n\\n\\tunsetEvents: function() {\\n\\t\\tthis.unset('currentEvents');\\n\\t\\tthis.unset('hasEvents');\\n\\t},\\n\\n\\n\\tresetEvents: function(events) {\\n\\t\\tthis.startBatchRender();\\n\\t\\tthis.unsetEvents();\\n\\t\\tthis.setEvents(events);\\n\\t\\tthis.stopBatchRender();\\n\\t},\\n\\n\\n\\t// Event Rendering\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\trequestEventsRender: function(events) {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.renderQueue.queue(function() {\\n\\t\\t\\t_this.executeEventsRender(events);\\n\\t\\t}, 'event', 'init');\\n\\t},\\n\\n\\n\\trequestEventsUnrender: function() {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.renderQueue.queue(function() {\\n\\t\\t\\t_this.executeEventsUnrender();\\n\\t\\t}, 'event', 'destroy');\\n\\t},\\n\\n\\n\\t// Date High-level Rendering\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// if dateProfile not specified, uses current\\n\\texecuteDateRender: function(dateProfile, skipScroll) {\\n\\n\\t\\tthis.setDateProfileForRendering(dateProfile);\\n\\t\\tthis.updateTitle();\\n\\t\\tthis.calendar.updateToolbarButtons();\\n\\n\\t\\tif (this.render) {\\n\\t\\t\\tthis.render(); // TODO: deprecate\\n\\t\\t}\\n\\n\\t\\tthis.renderDates();\\n\\t\\tthis.updateSize();\\n\\t\\tthis.renderBusinessHours(); // might need coordinates, so should go after updateSize()\\n\\t\\tthis.startNowIndicator();\\n\\n\\t\\tif (!skipScroll) {\\n\\t\\t\\tthis.addScroll(this.computeInitialDateScroll());\\n\\t\\t}\\n\\n\\t\\tthis.isDatesRendered = true;\\n\\t\\tthis.trigger('datesRendered');\\n\\t},\\n\\n\\n\\texecuteDateUnrender: function() {\\n\\n\\t\\tthis.unselect();\\n\\t\\tthis.stopNowIndicator();\\n\\n\\t\\tthis.trigger('before:datesUnrendered');\\n\\n\\t\\tthis.unrenderBusinessHours();\\n\\t\\tthis.unrenderDates();\\n\\n\\t\\tif (this.destroy) {\\n\\t\\t\\tthis.destroy(); // TODO: deprecate\\n\\t\\t}\\n\\n\\t\\tthis.isDatesRendered = false;\\n\\t},\\n\\n\\n\\t// Date Low-level Rendering\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// date-cell content only\\n\\trenderDates: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// date-cell content only\\n\\tunrenderDates: function() {\\n\\t\\t// subclasses should override\\n\\t},\\n\\n\\n\\t// Determing when the \\\"meat\\\" of the view is rendered (aka the base)\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tbindBaseRenderHandlers: function() {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.on('datesRendered.baseHandler', function() {\\n\\t\\t\\t_this.onBaseRender();\\n\\t\\t});\\n\\n\\t\\tthis.on('before:datesUnrendered.baseHandler', function() {\\n\\t\\t\\t_this.onBeforeBaseUnrender();\\n\\t\\t});\\n\\t},\\n\\n\\n\\tunbindBaseRenderHandlers: function() {\\n\\t\\tthis.off('.baseHandler');\\n\\t},\\n\\n\\n\\tonBaseRender: function() {\\n\\t\\tthis.applyScreenState();\\n\\t\\tthis.publiclyTrigger('viewRender', this, this, this.el);\\n\\t},\\n\\n\\n\\tonBeforeBaseUnrender: function() {\\n\\t\\tthis.applyScreenState();\\n\\t\\tthis.publiclyTrigger('viewDestroy', this, this, this.el);\\n\\t},\\n\\n\\n\\t// Misc view rendering utils\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Binds DOM handlers to elements that reside outside the view container, such as the document\\n\\tbindGlobalHandlers: function() {\\n\\t\\tthis.listenTo(GlobalEmitter.get(), {\\n\\t\\t\\ttouchstart: this.processUnselect,\\n\\t\\t\\tmousedown: this.handleDocumentMousedown\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Unbinds DOM handlers from elements that reside outside the view container\\n\\tunbindGlobalHandlers: function() {\\n\\t\\tthis.stopListeningTo(GlobalEmitter.get());\\n\\t},\\n\\n\\n\\t// Initializes internal variables related to theming\\n\\tinitThemingProps: function() {\\n\\t\\tvar tm = this.opt('theme') ? 'ui' : 'fc';\\n\\n\\t\\tthis.widgetHeaderClass = tm + '-widget-header';\\n\\t\\tthis.widgetContentClass = tm + '-widget-content';\\n\\t\\tthis.highlightStateClass = tm + '-state-highlight';\\n\\t},\\n\\n\\n\\t/* Business Hours\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders business-hours onto the view. Assumes updateSize has already been called.\\n\\trenderBusinessHours: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Unrenders previously-rendered business-hours\\n\\tunrenderBusinessHours: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t/* Now Indicator\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Immediately render the current time indicator and begins re-rendering it at an interval,\\n\\t// which is defined by this.getNowIndicatorUnit().\\n\\t// TODO: somehow do this for the current whole day's background too\\n\\tstartNowIndicator: function() {\\n\\t\\tvar _this = this;\\n\\t\\tvar unit;\\n\\t\\tvar update;\\n\\t\\tvar delay; // ms wait value\\n\\n\\t\\tif (this.opt('nowIndicator')) {\\n\\t\\t\\tunit = this.getNowIndicatorUnit();\\n\\t\\t\\tif (unit) {\\n\\t\\t\\t\\tupdate = proxy(this, 'updateNowIndicator'); // bind to `this`\\n\\n\\t\\t\\t\\tthis.initialNowDate = this.calendar.getNow();\\n\\t\\t\\t\\tthis.initialNowQueriedMs = +new Date();\\n\\t\\t\\t\\tthis.renderNowIndicator(this.initialNowDate);\\n\\t\\t\\t\\tthis.isNowIndicatorRendered = true;\\n\\n\\t\\t\\t\\t// wait until the beginning of the next interval\\n\\t\\t\\t\\tdelay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;\\n\\t\\t\\t\\tthis.nowIndicatorTimeoutID = setTimeout(function() {\\n\\t\\t\\t\\t\\t_this.nowIndicatorTimeoutID = null;\\n\\t\\t\\t\\t\\tupdate();\\n\\t\\t\\t\\t\\tdelay = +moment.duration(1, unit);\\n\\t\\t\\t\\t\\tdelay = Math.max(100, delay); // prevent too frequent\\n\\t\\t\\t\\t\\t_this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\\n\\t\\t\\t\\t}, delay);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// rerenders the now indicator, computing the new current time from the amount of time that has passed\\n\\t// since the initial getNow call.\\n\\tupdateNowIndicator: function() {\\n\\t\\tif (this.isNowIndicatorRendered) {\\n\\t\\t\\tthis.unrenderNowIndicator();\\n\\t\\t\\tthis.renderNowIndicator(\\n\\t\\t\\t\\tthis.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms\\n\\t\\t\\t);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Immediately unrenders the view's current time indicator and stops any re-rendering timers.\\n\\t// Won't cause side effects if indicator isn't rendered.\\n\\tstopNowIndicator: function() {\\n\\t\\tif (this.isNowIndicatorRendered) {\\n\\n\\t\\t\\tif (this.nowIndicatorTimeoutID) {\\n\\t\\t\\t\\tclearTimeout(this.nowIndicatorTimeoutID);\\n\\t\\t\\t\\tthis.nowIndicatorTimeoutID = null;\\n\\t\\t\\t}\\n\\t\\t\\tif (this.nowIndicatorIntervalID) {\\n\\t\\t\\t\\tclearTimeout(this.nowIndicatorIntervalID);\\n\\t\\t\\t\\tthis.nowIndicatorIntervalID = null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.unrenderNowIndicator();\\n\\t\\t\\tthis.isNowIndicatorRendered = false;\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\\n\\t// should be refreshed. If something falsy is returned, no time indicator is rendered at all.\\n\\tgetNowIndicatorUnit: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Renders a current time indicator at the given datetime\\n\\trenderNowIndicator: function(date) {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Undoes the rendering actions from renderNowIndicator\\n\\tunrenderNowIndicator: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t/* Dimensions\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Refreshes anything dependant upon sizing of the container element of the grid\\n\\tupdateSize: function(isResize) {\\n\\t\\tvar scroll;\\n\\n\\t\\tif (isResize) {\\n\\t\\t\\tscroll = this.queryScroll();\\n\\t\\t}\\n\\n\\t\\tthis.updateHeight(isResize);\\n\\t\\tthis.updateWidth(isResize);\\n\\t\\tthis.updateNowIndicator();\\n\\n\\t\\tif (isResize) {\\n\\t\\t\\tthis.applyScroll(scroll);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Refreshes the horizontal dimensions of the calendar\\n\\tupdateWidth: function(isResize) {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Refreshes the vertical dimensions of the calendar\\n\\tupdateHeight: function(isResize) {\\n\\t\\tvar calendar = this.calendar; // we poll the calendar for height information\\n\\n\\t\\tthis.setHeight(\\n\\t\\t\\tcalendar.getSuggestedViewHeight(),\\n\\t\\t\\tcalendar.isHeightAuto()\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Updates the vertical dimensions of the calendar to the specified height.\\n\\t// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its \\\"natural\\\" height.\\n\\tsetHeight: function(height, isAuto) {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t/* Scroller\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\taddForcedScroll: function(scroll) {\\n\\t\\tthis.addScroll(\\n\\t\\t\\t$.extend(scroll, { isForced: true })\\n\\t\\t);\\n\\t},\\n\\n\\n\\taddScroll: function(scroll) {\\n\\t\\tvar queuedScroll = this.queuedScroll || (this.queuedScroll = {});\\n\\n\\t\\tif (!queuedScroll.isForced) {\\n\\t\\t\\t$.extend(queuedScroll, scroll);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tpopScroll: function() {\\n\\t\\tthis.applyQueuedScroll();\\n\\t\\tthis.queuedScroll = null;\\n\\t},\\n\\n\\n\\tapplyQueuedScroll: function() {\\n\\t\\tif (this.queuedScroll) {\\n\\t\\t\\tthis.applyScroll(this.queuedScroll);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tqueryScroll: function() {\\n\\t\\tvar scroll = {};\\n\\n\\t\\tif (this.isDatesRendered) {\\n\\t\\t\\t$.extend(scroll, this.queryDateScroll());\\n\\t\\t}\\n\\n\\t\\treturn scroll;\\n\\t},\\n\\n\\n\\tapplyScroll: function(scroll) {\\n\\t\\tif (this.isDatesRendered) {\\n\\t\\t\\tthis.applyDateScroll(scroll);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tcomputeInitialDateScroll: function() {\\n\\t\\treturn {}; // subclasses must implement\\n\\t},\\n\\n\\n\\tqueryDateScroll: function() {\\n\\t\\treturn {}; // subclasses must implement\\n\\t},\\n\\n\\n\\tapplyDateScroll: function(scroll) {\\n\\t\\t; // subclasses must implement\\n\\t},\\n\\n\\n\\t/* Height Freezing\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tfreezeHeight: function() {\\n\\t\\tthis.calendar.freezeContentHeight();\\n\\t},\\n\\n\\n\\tthawHeight: function() {\\n\\t\\tthis.calendar.thawContentHeight();\\n\\t},\\n\\n\\n\\t// Event High-level Rendering\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\texecuteEventsRender: function(events) {\\n\\t\\tthis.renderEvents(events);\\n\\t\\tthis.isEventsRendered = true;\\n\\n\\t\\tthis.onEventsRender();\\n\\t},\\n\\n\\n\\texecuteEventsUnrender: function() {\\n\\t\\tthis.onBeforeEventsUnrender();\\n\\n\\t\\tif (this.destroyEvents) {\\n\\t\\t\\tthis.destroyEvents(); // TODO: deprecate\\n\\t\\t}\\n\\n\\t\\tthis.unrenderEvents();\\n\\t\\tthis.isEventsRendered = false;\\n\\t},\\n\\n\\n\\t// Event Rendering Triggers\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Signals that all events have been rendered\\n\\tonEventsRender: function() {\\n\\t\\tthis.applyScreenState();\\n\\n\\t\\tthis.renderedEventSegEach(function(seg) {\\n\\t\\t\\tthis.publiclyTrigger('eventAfterRender', seg.event, seg.event, seg.el);\\n\\t\\t});\\n\\t\\tthis.publiclyTrigger('eventAfterAllRender');\\n\\t},\\n\\n\\n\\t// Signals that all event elements are about to be removed\\n\\tonBeforeEventsUnrender: function() {\\n\\t\\tthis.applyScreenState();\\n\\n\\t\\tthis.renderedEventSegEach(function(seg) {\\n\\t\\t\\tthis.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);\\n\\t\\t});\\n\\t},\\n\\n\\n\\tapplyScreenState: function() {\\n\\t\\tthis.thawHeight();\\n\\t\\tthis.freezeHeight();\\n\\t\\tthis.applyQueuedScroll();\\n\\t},\\n\\n\\n\\t// Event Low-level Rendering\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Renders the events onto the view.\\n\\trenderEvents: function(events) {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Removes event elements from the view.\\n\\tunrenderEvents: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Event Rendering Utils\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Given an event and the default element used for rendering, returns the element that should actually be used.\\n\\t// Basically runs events and elements through the eventRender hook.\\n\\tresolveEventEl: function(event, el) {\\n\\t\\tvar custom = this.publiclyTrigger('eventRender', event, event, el);\\n\\n\\t\\tif (custom === false) { // means don't render at all\\n\\t\\t\\tel = null;\\n\\t\\t}\\n\\t\\telse if (custom && custom !== true) {\\n\\t\\t\\tel = $(custom);\\n\\t\\t}\\n\\n\\t\\treturn el;\\n\\t},\\n\\n\\n\\t// Hides all rendered event segments linked to the given event\\n\\tshowEvent: function(event) {\\n\\t\\tthis.renderedEventSegEach(function(seg) {\\n\\t\\t\\tseg.el.css('visibility', '');\\n\\t\\t}, event);\\n\\t},\\n\\n\\n\\t// Shows all rendered event segments linked to the given event\\n\\thideEvent: function(event) {\\n\\t\\tthis.renderedEventSegEach(function(seg) {\\n\\t\\t\\tseg.el.css('visibility', 'hidden');\\n\\t\\t}, event);\\n\\t},\\n\\n\\n\\t// Iterates through event segments that have been rendered (have an el). Goes through all by default.\\n\\t// If the optional `event` argument is specified, only iterates through segments linked to that event.\\n\\t// The `this` value of the callback function will be the view.\\n\\trenderedEventSegEach: function(func, event) {\\n\\t\\tvar segs = this.getEventSegs();\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tif (!event || segs[i].event._id === event._id) {\\n\\t\\t\\t\\tif (segs[i].el) {\\n\\t\\t\\t\\t\\tfunc.call(this, segs[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Retrieves all the rendered segment objects for the view\\n\\tgetEventSegs: function() {\\n\\t\\t// subclasses must implement\\n\\t\\treturn [];\\n\\t},\\n\\n\\n\\t/* Event Drag-n-Drop\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Computes if the given event is allowed to be dragged by the user\\n\\tisEventDraggable: function(event) {\\n\\t\\treturn this.isEventStartEditable(event);\\n\\t},\\n\\n\\n\\tisEventStartEditable: function(event) {\\n\\t\\treturn firstDefined(\\n\\t\\t\\tevent.startEditable,\\n\\t\\t\\t(event.source || {}).startEditable,\\n\\t\\t\\tthis.opt('eventStartEditable'),\\n\\t\\t\\tthis.isEventGenerallyEditable(event)\\n\\t\\t);\\n\\t},\\n\\n\\n\\tisEventGenerallyEditable: function(event) {\\n\\t\\treturn firstDefined(\\n\\t\\t\\tevent.editable,\\n\\t\\t\\t(event.source || {}).editable,\\n\\t\\t\\tthis.opt('editable')\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Must be called when an event in the view is dropped onto new location.\\n\\t// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\\n\\treportSegDrop: function(seg, dropLocation, largeUnit, el, ev) {\\n\\t\\tvar calendar = this.calendar;\\n\\t\\tvar mutateResult = calendar.mutateSeg(seg, dropLocation, largeUnit);\\n\\t\\tvar undoFunc = function() {\\n\\t\\t\\tmutateResult.undo();\\n\\t\\t\\tcalendar.reportEventChange();\\n\\t\\t};\\n\\n\\t\\tthis.triggerEventDrop(seg.event, mutateResult.dateDelta, undoFunc, el, ev);\\n\\t\\tcalendar.reportEventChange(); // will rerender events\\n\\t},\\n\\n\\n\\t// Triggers event-drop handlers that have subscribed via the API\\n\\ttriggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {\\n\\t\\tthis.publiclyTrigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy\\n\\t},\\n\\n\\n\\t/* External Element Drag-n-Drop\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\\n\\t// `meta` is the parsed data that has been embedded into the dragging event.\\n\\t// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\\n\\treportExternalDrop: function(meta, dropLocation, el, ev, ui) {\\n\\t\\tvar eventProps = meta.eventProps;\\n\\t\\tvar eventInput;\\n\\t\\tvar event;\\n\\n\\t\\t// Try to build an event object and render it. TODO: decouple the two\\n\\t\\tif (eventProps) {\\n\\t\\t\\teventInput = $.extend({}, eventProps, dropLocation);\\n\\t\\t\\tevent = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array\\n\\t\\t}\\n\\n\\t\\tthis.triggerExternalDrop(event, dropLocation, el, ev, ui);\\n\\t},\\n\\n\\n\\t// Triggers external-drop handlers that have subscribed via the API\\n\\ttriggerExternalDrop: function(event, dropLocation, el, ev, ui) {\\n\\n\\t\\t// trigger 'drop' regardless of whether element represents an event\\n\\t\\tthis.publiclyTrigger('drop', el[0], dropLocation.start, ev, ui);\\n\\n\\t\\tif (event) {\\n\\t\\t\\tthis.publiclyTrigger('eventReceive', null, event); // signal an external event landed\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Drag-n-Drop Rendering (for both events and external elements)\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of a event or external-element drag over the given drop zone.\\n\\t// If an external-element, seg will be `null`.\\n\\t// Must return elements used for any mock events.\\n\\trenderDrag: function(dropLocation, seg) {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t// Unrenders a visual indication of an event or external-element being dragged.\\n\\tunrenderDrag: function() {\\n\\t\\t// subclasses must implement\\n\\t},\\n\\n\\n\\t/* Event Resizing\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Computes if the given event is allowed to be resized from its starting edge\\n\\tisEventResizableFromStart: function(event) {\\n\\t\\treturn this.opt('eventResizableFromStart') && this.isEventResizable(event);\\n\\t},\\n\\n\\n\\t// Computes if the given event is allowed to be resized from its ending edge\\n\\tisEventResizableFromEnd: function(event) {\\n\\t\\treturn this.isEventResizable(event);\\n\\t},\\n\\n\\n\\t// Computes if the given event is allowed to be resized by the user at all\\n\\tisEventResizable: function(event) {\\n\\t\\tvar source = event.source || {};\\n\\n\\t\\treturn firstDefined(\\n\\t\\t\\tevent.durationEditable,\\n\\t\\t\\tsource.durationEditable,\\n\\t\\t\\tthis.opt('eventDurationEditable'),\\n\\t\\t\\tevent.editable,\\n\\t\\t\\tsource.editable,\\n\\t\\t\\tthis.opt('editable')\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Must be called when an event in the view has been resized to a new length\\n\\treportSegResize: function(seg, resizeLocation, largeUnit, el, ev) {\\n\\t\\tvar calendar = this.calendar;\\n\\t\\tvar mutateResult = calendar.mutateSeg(seg, resizeLocation, largeUnit);\\n\\t\\tvar undoFunc = function() {\\n\\t\\t\\tmutateResult.undo();\\n\\t\\t\\tcalendar.reportEventChange();\\n\\t\\t};\\n\\n\\t\\tthis.triggerEventResize(seg.event, mutateResult.durationDelta, undoFunc, el, ev);\\n\\t\\tcalendar.reportEventChange(); // will rerender events\\n\\t},\\n\\n\\n\\t// Triggers event-resize handlers that have subscribed via the API\\n\\ttriggerEventResize: function(event, durationDelta, undoFunc, el, ev) {\\n\\t\\tthis.publiclyTrigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy\\n\\t},\\n\\n\\n\\t/* Selection (time range)\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Selects a date span on the view. `start` and `end` are both Moments.\\n\\t// `ev` is the native mouse event that begin the interaction.\\n\\tselect: function(span, ev) {\\n\\t\\tthis.unselect(ev);\\n\\t\\tthis.renderSelection(span);\\n\\t\\tthis.reportSelection(span, ev);\\n\\t},\\n\\n\\n\\t// Renders a visual indication of the selection\\n\\trenderSelection: function(span) {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t// Called when a new selection is made. Updates internal state and triggers handlers.\\n\\treportSelection: function(span, ev) {\\n\\t\\tthis.isSelected = true;\\n\\t\\tthis.triggerSelect(span, ev);\\n\\t},\\n\\n\\n\\t// Triggers handlers to 'select'\\n\\ttriggerSelect: function(span, ev) {\\n\\t\\tthis.publiclyTrigger(\\n\\t\\t\\t'select',\\n\\t\\t\\tnull,\\n\\t\\t\\tthis.calendar.applyTimezone(span.start), // convert to calendar's tz for external API\\n\\t\\t\\tthis.calendar.applyTimezone(span.end), // \\\"\\n\\t\\t\\tev\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Undoes a selection. updates in the internal state and triggers handlers.\\n\\t// `ev` is the native mouse event that began the interaction.\\n\\tunselect: function(ev) {\\n\\t\\tif (this.isSelected) {\\n\\t\\t\\tthis.isSelected = false;\\n\\t\\t\\tif (this.destroySelection) {\\n\\t\\t\\t\\tthis.destroySelection(); // TODO: deprecate\\n\\t\\t\\t}\\n\\t\\t\\tthis.unrenderSelection();\\n\\t\\t\\tthis.publiclyTrigger('unselect', null, ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Unrenders a visual indication of selection\\n\\tunrenderSelection: function() {\\n\\t\\t// subclasses should implement\\n\\t},\\n\\n\\n\\t/* Event Selection\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tselectEvent: function(event) {\\n\\t\\tif (!this.selectedEvent || this.selectedEvent !== event) {\\n\\t\\t\\tthis.unselectEvent();\\n\\t\\t\\tthis.renderedEventSegEach(function(seg) {\\n\\t\\t\\t\\tseg.el.addClass('fc-selected');\\n\\t\\t\\t}, event);\\n\\t\\t\\tthis.selectedEvent = event;\\n\\t\\t}\\n\\t},\\n\\n\\n\\tunselectEvent: function() {\\n\\t\\tif (this.selectedEvent) {\\n\\t\\t\\tthis.renderedEventSegEach(function(seg) {\\n\\t\\t\\t\\tseg.el.removeClass('fc-selected');\\n\\t\\t\\t}, this.selectedEvent);\\n\\t\\t\\tthis.selectedEvent = null;\\n\\t\\t}\\n\\t},\\n\\n\\n\\tisEventSelected: function(event) {\\n\\t\\t// event references might change on refetchEvents(), while selectedEvent doesn't,\\n\\t\\t// so compare IDs\\n\\t\\treturn this.selectedEvent && this.selectedEvent._id === event._id;\\n\\t},\\n\\n\\n\\t/* Mouse / Touch Unselecting (time range & event unselection)\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\t// TODO: move consistently to down/start or up/end?\\n\\t// TODO: don't kill previous selection if touch scrolling\\n\\n\\n\\thandleDocumentMousedown: function(ev) {\\n\\t\\tif (isPrimaryMouseButton(ev)) {\\n\\t\\t\\tthis.processUnselect(ev);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tprocessUnselect: function(ev) {\\n\\t\\tthis.processRangeUnselect(ev);\\n\\t\\tthis.processEventUnselect(ev);\\n\\t},\\n\\n\\n\\tprocessRangeUnselect: function(ev) {\\n\\t\\tvar ignore;\\n\\n\\t\\t// is there a time-range selection?\\n\\t\\tif (this.isSelected && this.opt('unselectAuto')) {\\n\\t\\t\\t// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\\n\\t\\t\\tignore = this.opt('unselectCancel');\\n\\t\\t\\tif (!ignore || !$(ev.target).closest(ignore).length) {\\n\\t\\t\\t\\tthis.unselect(ev);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\tprocessEventUnselect: function(ev) {\\n\\t\\tif (this.selectedEvent) {\\n\\t\\t\\tif (!$(ev.target).closest('.fc-selected').length) {\\n\\t\\t\\t\\tthis.unselectEvent();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Day Click\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Triggers handlers to 'dayClick'\\n\\t// Span has start/end of the clicked area. Only the start is useful.\\n\\ttriggerDayClick: function(span, dayEl, ev) {\\n\\t\\tthis.publiclyTrigger(\\n\\t\\t\\t'dayClick',\\n\\t\\t\\tdayEl,\\n\\t\\t\\tthis.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API\\n\\t\\t\\tev\\n\\t\\t);\\n\\t},\\n\\n\\n\\t/* Date Utils\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Returns the date range of the full days the given range visually appears to occupy.\\n\\t// Returns a new range object.\\n\\tcomputeDayRange: function(range) {\\n\\t\\tvar startDay = range.start.clone().stripTime(); // the beginning of the day the range starts\\n\\t\\tvar end = range.end;\\n\\t\\tvar endDay = null;\\n\\t\\tvar endTimeMS;\\n\\n\\t\\tif (end) {\\n\\t\\t\\tendDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\\n\\t\\t\\tendTimeMS = +end.time(); // # of milliseconds into `endDay`\\n\\n\\t\\t\\t// If the end time is actually inclusively part of the next day and is equal to or\\n\\t\\t\\t// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\\n\\t\\t\\t// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\\n\\t\\t\\tif (endTimeMS && endTimeMS >= this.nextDayThreshold) {\\n\\t\\t\\t\\tendDay.add(1, 'days');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,\\n\\t\\t// assign the default duration of one day.\\n\\t\\tif (!end || endDay <= startDay) {\\n\\t\\t\\tendDay = startDay.clone().add(1, 'days');\\n\\t\\t}\\n\\n\\t\\treturn { start: startDay, end: endDay };\\n\\t},\\n\\n\\n\\t// Does the given event visually appear to occupy more than one day?\\n\\tisMultiDayEvent: function(event) {\\n\\t\\tvar range = this.computeDayRange(event); // event is range-ish\\n\\n\\t\\treturn range.end.diff(range.start, 'days') > 1;\\n\\t}\\n\\n});\\n\\n\\nView.watch('displayingDates', [ 'dateProfile' ], function(deps) {\\n\\tthis.requestDateRender(deps.dateProfile);\\n}, function() {\\n\\tthis.requestDateUnrender();\\n});\\n\\n\\nView.watch('initialEvents', [ 'dateProfile' ], function(deps) {\\n\\treturn this.fetchInitialEvents(deps.dateProfile);\\n});\\n\\n\\nView.watch('bindingEvents', [ 'initialEvents' ], function(deps) {\\n\\tthis.setEvents(deps.initialEvents);\\n\\tthis.bindEventChanges();\\n}, function() {\\n\\tthis.unbindEventChanges();\\n\\tthis.unsetEvents();\\n});\\n\\n\\nView.watch('displayingEvents', [ 'displayingDates', 'hasEvents' ], function() {\\n\\tthis.requestEventsRender(this.get('currentEvents')); // if there were event mutations after initialEvents\\n}, function() {\\n\\tthis.requestEventsUnrender();\\n});\\n\\n;;\\n\\nView.mixin({\\n\\n\\t// range the view is formally responsible for.\\n\\t// for example, a month view might have 1st-31st, excluding padded dates\\n\\tcurrentRange: null,\\n\\tcurrentRangeUnit: null, // name of largest unit being displayed, like \\\"month\\\" or \\\"week\\\"\\n\\n\\t// date range with a rendered skeleton\\n\\t// includes not-active days that need some sort of DOM\\n\\trenderRange: null,\\n\\n\\t// dates that display events and accept drag-n-drop\\n\\tactiveRange: null,\\n\\n\\t// constraint for where prev/next operations can go and where events can be dragged/resized to.\\n\\t// an object with optional start and end properties.\\n\\tvalidRange: null,\\n\\n\\t// how far the current date will move for a prev/next operation\\n\\tdateIncrement: null,\\n\\n\\tminTime: null, // Duration object that denotes the first visible time of any given day\\n\\tmaxTime: null, // Duration object that denotes the exclusive visible end time of any given day\\n\\tusesMinMaxTime: false, // whether minTime/maxTime will affect the activeRange. Views must opt-in.\\n\\n\\t// DEPRECATED\\n\\tstart: null, // use activeRange.start\\n\\tend: null, // use activeRange.end\\n\\tintervalStart: null, // use currentRange.start\\n\\tintervalEnd: null, // use currentRange.end\\n\\n\\n\\t/* Date Range Computation\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tsetDateProfileForRendering: function(dateProfile) {\\n\\t\\tthis.currentRange = dateProfile.currentRange;\\n\\t\\tthis.currentRangeUnit = dateProfile.currentRangeUnit;\\n\\t\\tthis.renderRange = dateProfile.renderRange;\\n\\t\\tthis.activeRange = dateProfile.activeRange;\\n\\t\\tthis.validRange = dateProfile.validRange;\\n\\t\\tthis.dateIncrement = dateProfile.dateIncrement;\\n\\t\\tthis.minTime = dateProfile.minTime;\\n\\t\\tthis.maxTime = dateProfile.maxTime;\\n\\n\\t\\t// DEPRECATED, but we need to keep it updated\\n\\t\\tthis.start = dateProfile.activeRange.start;\\n\\t\\tthis.end = dateProfile.activeRange.end;\\n\\t\\tthis.intervalStart = dateProfile.currentRange.start;\\n\\t\\tthis.intervalEnd = dateProfile.currentRange.end;\\n\\t},\\n\\n\\n\\t// Builds a structure with info about what the dates/ranges will be for the \\\"prev\\\" view.\\n\\tbuildPrevDateProfile: function(date) {\\n\\t\\tvar prevDate = date.clone().startOf(this.currentRangeUnit).subtract(this.dateIncrement);\\n\\n\\t\\treturn this.buildDateProfile(prevDate, -1);\\n\\t},\\n\\n\\n\\t// Builds a structure with info about what the dates/ranges will be for the \\\"next\\\" view.\\n\\tbuildNextDateProfile: function(date) {\\n\\t\\tvar nextDate = date.clone().startOf(this.currentRangeUnit).add(this.dateIncrement);\\n\\n\\t\\treturn this.buildDateProfile(nextDate, 1);\\n\\t},\\n\\n\\n\\t// Builds a structure holding dates/ranges for rendering around the given date.\\n\\t// Optional direction param indicates whether the date is being incremented/decremented\\n\\t// from its previous value. decremented = -1, incremented = 1 (default).\\n\\tbuildDateProfile: function(date, direction, forceToValid) {\\n\\t\\tvar validRange = this.buildValidRange();\\n\\t\\tvar minTime = null;\\n\\t\\tvar maxTime = null;\\n\\t\\tvar currentInfo;\\n\\t\\tvar renderRange;\\n\\t\\tvar activeRange;\\n\\t\\tvar isValid;\\n\\n\\t\\tif (forceToValid) {\\n\\t\\t\\tdate = constrainDate(date, validRange);\\n\\t\\t}\\n\\n\\t\\tcurrentInfo = this.buildCurrentRangeInfo(date, direction);\\n\\t\\trenderRange = this.buildRenderRange(currentInfo.range, currentInfo.unit);\\n\\t\\tactiveRange = cloneRange(renderRange);\\n\\n\\t\\tif (!this.opt('showNonCurrentDates')) {\\n\\t\\t\\tactiveRange = constrainRange(activeRange, currentInfo.range);\\n\\t\\t}\\n\\n\\t\\tminTime = moment.duration(this.opt('minTime'));\\n\\t\\tmaxTime = moment.duration(this.opt('maxTime'));\\n\\t\\tthis.adjustActiveRange(activeRange, minTime, maxTime);\\n\\n\\t\\tactiveRange = constrainRange(activeRange, validRange);\\n\\t\\tdate = constrainDate(date, activeRange);\\n\\n\\t\\t// it's invalid if the originally requested date is not contained,\\n\\t\\t// or if the range is completely outside of the valid range.\\n\\t\\tisValid = doRangesIntersect(currentInfo.range, validRange);\\n\\n\\t\\treturn {\\n\\t\\t\\tvalidRange: validRange,\\n\\t\\t\\tcurrentRange: currentInfo.range,\\n\\t\\t\\tcurrentRangeUnit: currentInfo.unit,\\n\\t\\t\\tactiveRange: activeRange,\\n\\t\\t\\trenderRange: renderRange,\\n\\t\\t\\tminTime: minTime,\\n\\t\\t\\tmaxTime: maxTime,\\n\\t\\t\\tisValid: isValid,\\n\\t\\t\\tdate: date,\\n\\t\\t\\tdateIncrement: this.buildDateIncrement(currentInfo.duration)\\n\\t\\t\\t\\t// pass a fallback (might be null) ^\\n\\t\\t};\\n\\t},\\n\\n\\n\\t// Builds an object with optional start/end properties.\\n\\t// Indicates the minimum/maximum dates to display.\\n\\tbuildValidRange: function() {\\n\\t\\treturn this.getRangeOption('validRange', this.calendar.getNow()) || {};\\n\\t},\\n\\n\\n\\t// Builds a structure with info about the \\\"current\\\" range, the range that is\\n\\t// highlighted as being the current month for example.\\n\\t// See buildDateProfile for a description of `direction`.\\n\\t// Guaranteed to have `range` and `unit` properties. `duration` is optional.\\n\\tbuildCurrentRangeInfo: function(date, direction) {\\n\\t\\tvar duration = null;\\n\\t\\tvar unit = null;\\n\\t\\tvar range = null;\\n\\t\\tvar dayCount;\\n\\n\\t\\tif (this.viewSpec.duration) {\\n\\t\\t\\tduration = this.viewSpec.duration;\\n\\t\\t\\tunit = this.viewSpec.durationUnit;\\n\\t\\t\\trange = this.buildRangeFromDuration(date, direction, duration, unit);\\n\\t\\t}\\n\\t\\telse if ((dayCount = this.opt('dayCount'))) {\\n\\t\\t\\tunit = 'day';\\n\\t\\t\\trange = this.buildRangeFromDayCount(date, direction, dayCount);\\n\\t\\t}\\n\\t\\telse if ((range = this.buildCustomVisibleRange(date))) {\\n\\t\\t\\tunit = computeGreatestUnit(range.start, range.end);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tduration = this.getFallbackDuration();\\n\\t\\t\\tunit = computeGreatestUnit(duration);\\n\\t\\t\\trange = this.buildRangeFromDuration(date, direction, duration, unit);\\n\\t\\t}\\n\\n\\t\\tthis.normalizeCurrentRange(range, unit); // modifies in-place\\n\\n\\t\\treturn { duration: duration, unit: unit, range: range };\\n\\t},\\n\\n\\n\\tgetFallbackDuration: function() {\\n\\t\\treturn moment.duration({ days: 1 });\\n\\t},\\n\\n\\n\\t// If the range has day units or larger, remove times. Otherwise, ensure times.\\n\\tnormalizeCurrentRange: function(range, unit) {\\n\\n\\t\\tif (/^(year|month|week|day)$/.test(unit)) { // whole-days?\\n\\t\\t\\trange.start.stripTime();\\n\\t\\t\\trange.end.stripTime();\\n\\t\\t}\\n\\t\\telse { // needs to have a time?\\n\\t\\t\\tif (!range.start.hasTime()) {\\n\\t\\t\\t\\trange.start.time(0); // give 00:00 time\\n\\t\\t\\t}\\n\\t\\t\\tif (!range.end.hasTime()) {\\n\\t\\t\\t\\trange.end.time(0); // give 00:00 time\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Mutates the given activeRange to have time values (un-ambiguate)\\n\\t// if the minTime or maxTime causes the range to expand.\\n\\t// TODO: eventually activeRange should *always* have times.\\n\\tadjustActiveRange: function(range, minTime, maxTime) {\\n\\t\\tvar hasSpecialTimes = false;\\n\\n\\t\\tif (this.usesMinMaxTime) {\\n\\n\\t\\t\\tif (minTime < 0) {\\n\\t\\t\\t\\trange.start.time(0).add(minTime);\\n\\t\\t\\t\\thasSpecialTimes = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?\\n\\t\\t\\t\\trange.end.time(maxTime - (24 * 60 * 60 * 1000));\\n\\t\\t\\t\\thasSpecialTimes = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (hasSpecialTimes) {\\n\\t\\t\\t\\tif (!range.start.hasTime()) {\\n\\t\\t\\t\\t\\trange.start.time(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!range.end.hasTime()) {\\n\\t\\t\\t\\t\\trange.end.time(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Builds the \\\"current\\\" range when it is specified as an explicit duration.\\n\\t// `unit` is the already-computed computeGreatestUnit value of duration.\\n\\tbuildRangeFromDuration: function(date, direction, duration, unit) {\\n\\t\\tvar alignment = this.opt('dateAlignment');\\n\\t\\tvar start = date.clone();\\n\\t\\tvar end;\\n\\t\\tvar dateIncrementInput;\\n\\t\\tvar dateIncrementDuration;\\n\\n\\t\\t// if the view displays a single day or smaller\\n\\t\\tif (duration.as('days') <= 1) {\\n\\t\\t\\tif (this.isHiddenDay(start)) {\\n\\t\\t\\t\\tstart = this.skipHiddenDays(start, direction);\\n\\t\\t\\t\\tstart.startOf('day');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// compute what the alignment should be\\n\\t\\tif (!alignment) {\\n\\t\\t\\tdateIncrementInput = this.opt('dateIncrement');\\n\\n\\t\\t\\tif (dateIncrementInput) {\\n\\t\\t\\t\\tdateIncrementDuration = moment.duration(dateIncrementInput);\\n\\n\\t\\t\\t\\t// use the smaller of the two units\\n\\t\\t\\t\\tif (dateIncrementDuration < duration) {\\n\\t\\t\\t\\t\\talignment = computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\talignment = unit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\talignment = unit;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstart.startOf(alignment);\\n\\t\\tend = start.clone().add(duration);\\n\\n\\t\\treturn { start: start, end: end };\\n\\t},\\n\\n\\n\\t// Builds the \\\"current\\\" range when a dayCount is specified.\\n\\tbuildRangeFromDayCount: function(date, direction, dayCount) {\\n\\t\\tvar customAlignment = this.opt('dateAlignment');\\n\\t\\tvar runningCount = 0;\\n\\t\\tvar start = date.clone();\\n\\t\\tvar end;\\n\\n\\t\\tif (customAlignment) {\\n\\t\\t\\tstart.startOf(customAlignment);\\n\\t\\t}\\n\\n\\t\\tstart.startOf('day');\\n\\t\\tstart = this.skipHiddenDays(start, direction);\\n\\n\\t\\tend = start.clone();\\n\\t\\tdo {\\n\\t\\t\\tend.add(1, 'day');\\n\\t\\t\\tif (!this.isHiddenDay(end)) {\\n\\t\\t\\t\\trunningCount++;\\n\\t\\t\\t}\\n\\t\\t} while (runningCount < dayCount);\\n\\n\\t\\treturn { start: start, end: end };\\n\\t},\\n\\n\\n\\t// Builds a normalized range object for the \\\"visible\\\" range,\\n\\t// which is a way to define the currentRange and activeRange at the same time.\\n\\tbuildCustomVisibleRange: function(date) {\\n\\t\\tvar visibleRange = this.getRangeOption(\\n\\t\\t\\t'visibleRange',\\n\\t\\t\\tthis.calendar.moment(date) // correct zone. also generates new obj that avoids mutations\\n\\t\\t);\\n\\n\\t\\tif (visibleRange && (!visibleRange.start || !visibleRange.end)) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn visibleRange;\\n\\t},\\n\\n\\n\\t// Computes the range that will represent the element/cells for *rendering*,\\n\\t// but which may have voided days/times.\\n\\tbuildRenderRange: function(currentRange, currentRangeUnit) {\\n\\t\\t// cut off days in the currentRange that are hidden\\n\\t\\treturn this.trimHiddenDays(currentRange);\\n\\t},\\n\\n\\n\\t// Compute the duration value that should be added/substracted to the current date\\n\\t// when a prev/next operation happens.\\n\\tbuildDateIncrement: function(fallback) {\\n\\t\\tvar dateIncrementInput = this.opt('dateIncrement');\\n\\t\\tvar customAlignment;\\n\\n\\t\\tif (dateIncrementInput) {\\n\\t\\t\\treturn moment.duration(dateIncrementInput);\\n\\t\\t}\\n\\t\\telse if ((customAlignment = this.opt('dateAlignment'))) {\\n\\t\\t\\treturn moment.duration(1, customAlignment);\\n\\t\\t}\\n\\t\\telse if (fallback) {\\n\\t\\t\\treturn fallback;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn moment.duration({ days: 1 });\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Remove days from the beginning and end of the range that are computed as hidden.\\n\\ttrimHiddenDays: function(inputRange) {\\n\\t\\treturn {\\n\\t\\t\\tstart: this.skipHiddenDays(inputRange.start),\\n\\t\\t\\tend: this.skipHiddenDays(inputRange.end, -1, true) // exclusively move backwards\\n\\t\\t};\\n\\t},\\n\\n\\n\\t// Compute the number of the give units in the \\\"current\\\" range.\\n\\t// Will return a floating-point number. Won't round.\\n\\tcurrentRangeAs: function(unit) {\\n\\t\\tvar currentRange = this.currentRange;\\n\\t\\treturn currentRange.end.diff(currentRange.start, unit, true);\\n\\t},\\n\\n\\n\\t// Arguments after name will be forwarded to a hypothetical function value\\n\\t// WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.\\n\\t// Always clone your objects if you fear mutation.\\n\\tgetRangeOption: function(name) {\\n\\t\\tvar val = this.opt(name);\\n\\n\\t\\tif (typeof val === 'function') {\\n\\t\\t\\tval = val.apply(\\n\\t\\t\\t\\tnull,\\n\\t\\t\\t\\tArray.prototype.slice.call(arguments, 1)\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tif (val) {\\n\\t\\t\\treturn this.calendar.parseRange(val);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Hidden Days\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Initializes internal variables related to calculating hidden days-of-week\\n\\tinitHiddenDays: function() {\\n\\t\\tvar hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\\n\\t\\tvar isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\\n\\t\\tvar dayCnt = 0;\\n\\t\\tvar i;\\n\\n\\t\\tif (this.opt('weekends') === false) {\\n\\t\\t\\thiddenDays.push(0, 6); // 0=sunday, 6=saturday\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < 7; i++) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tdayCnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!dayCnt) {\\n\\t\\t\\tthrow 'invalid hiddenDays'; // all days were hidden? bad.\\n\\t\\t}\\n\\n\\t\\tthis.isHiddenDayHash = isHiddenDayHash;\\n\\t},\\n\\n\\n\\t// Is the current day hidden?\\n\\t// `day` is a day-of-week index (0-6), or a Moment\\n\\tisHiddenDay: function(day) {\\n\\t\\tif (moment.isMoment(day)) {\\n\\t\\t\\tday = day.day();\\n\\t\\t}\\n\\t\\treturn this.isHiddenDayHash[day];\\n\\t},\\n\\n\\n\\t// Incrementing the current day until it is no longer a hidden day, returning a copy.\\n\\t// DOES NOT CONSIDER validRange!\\n\\t// If the initial value of `date` is not a hidden day, don't do anything.\\n\\t// Pass `isExclusive` as `true` if you are dealing with an end date.\\n\\t// `inc` defaults to `1` (increment one day forward each time)\\n\\tskipHiddenDays: function(date, inc, isExclusive) {\\n\\t\\tvar out = date.clone();\\n\\t\\tinc = inc || 1;\\n\\t\\twhile (\\n\\t\\t\\tthis.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]\\n\\t\\t) {\\n\\t\\t\\tout.add(inc, 'days');\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\n});\\n\\n;;\\n\\n/*\\nEmbodies a div that has potential scrollbars\\n*/\\nvar Scroller = FC.Scroller = Class.extend({\\n\\n\\tel: null, // the guaranteed outer element\\n\\tscrollEl: null, // the element with the scrollbars\\n\\toverflowX: null,\\n\\toverflowY: null,\\n\\n\\n\\tconstructor: function(options) {\\n\\t\\toptions = options || {};\\n\\t\\tthis.overflowX = options.overflowX || options.overflow || 'auto';\\n\\t\\tthis.overflowY = options.overflowY || options.overflow || 'auto';\\n\\t},\\n\\n\\n\\trender: function() {\\n\\t\\tthis.el = this.renderEl();\\n\\t\\tthis.applyOverflow();\\n\\t},\\n\\n\\n\\trenderEl: function() {\\n\\t\\treturn (this.scrollEl = $('<div class=\\\"fc-scroller\\\"></div>'));\\n\\t},\\n\\n\\n\\t// sets to natural height, unlocks overflow\\n\\tclear: function() {\\n\\t\\tthis.setHeight('auto');\\n\\t\\tthis.applyOverflow();\\n\\t},\\n\\n\\n\\tdestroy: function() {\\n\\t\\tthis.el.remove();\\n\\t},\\n\\n\\n\\t// Overflow\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tapplyOverflow: function() {\\n\\t\\tthis.scrollEl.css({\\n\\t\\t\\t'overflow-x': this.overflowX,\\n\\t\\t\\t'overflow-y': this.overflowY\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\\n\\t// Useful for preserving scrollbar widths regardless of future resizes.\\n\\t// Can pass in scrollbarWidths for optimization.\\n\\tlockOverflow: function(scrollbarWidths) {\\n\\t\\tvar overflowX = this.overflowX;\\n\\t\\tvar overflowY = this.overflowY;\\n\\n\\t\\tscrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\\n\\n\\t\\tif (overflowX === 'auto') {\\n\\t\\t\\toverflowX = (\\n\\t\\t\\t\\t\\tscrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\\n\\t\\t\\t\\t\\t// OR scrolling pane with massless scrollbars?\\n\\t\\t\\t\\t\\tthis.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth\\n\\t\\t\\t\\t\\t\\t// subtract 1 because of IE off-by-one issue\\n\\t\\t\\t\\t) ? 'scroll' : 'hidden';\\n\\t\\t}\\n\\n\\t\\tif (overflowY === 'auto') {\\n\\t\\t\\toverflowY = (\\n\\t\\t\\t\\t\\tscrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\\n\\t\\t\\t\\t\\t// OR scrolling pane with massless scrollbars?\\n\\t\\t\\t\\t\\tthis.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight\\n\\t\\t\\t\\t\\t\\t// subtract 1 because of IE off-by-one issue\\n\\t\\t\\t\\t) ? 'scroll' : 'hidden';\\n\\t\\t}\\n\\n\\t\\tthis.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });\\n\\t},\\n\\n\\n\\t// Getters / Setters\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tsetHeight: function(height) {\\n\\t\\tthis.scrollEl.height(height);\\n\\t},\\n\\n\\n\\tgetScrollTop: function() {\\n\\t\\treturn this.scrollEl.scrollTop();\\n\\t},\\n\\n\\n\\tsetScrollTop: function(top) {\\n\\t\\tthis.scrollEl.scrollTop(top);\\n\\t},\\n\\n\\n\\tgetClientWidth: function() {\\n\\t\\treturn this.scrollEl[0].clientWidth;\\n\\t},\\n\\n\\n\\tgetClientHeight: function() {\\n\\t\\treturn this.scrollEl[0].clientHeight;\\n\\t},\\n\\n\\n\\tgetScrollbarWidths: function() {\\n\\t\\treturn getScrollbarWidths(this.scrollEl);\\n\\t}\\n\\n});\\n\\n;;\\nfunction Iterator(items) {\\n    this.items = items || [];\\n}\\n\\n\\n/* Calls a method on every item passing the arguments through */\\nIterator.prototype.proxyCall = function(methodName) {\\n    var args = Array.prototype.slice.call(arguments, 1);\\n    var results = [];\\n\\n    this.items.forEach(function(item) {\\n        results.push(item[methodName].apply(item, args));\\n    });\\n\\n    return results;\\n};\\n\\n;;\\n\\n/* Toolbar with buttons and title\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nfunction Toolbar(calendar, toolbarOptions) {\\n\\tvar t = this;\\n\\n\\t// exports\\n\\tt.setToolbarOptions = setToolbarOptions;\\n\\tt.render = render;\\n\\tt.removeElement = removeElement;\\n\\tt.updateTitle = updateTitle;\\n\\tt.activateButton = activateButton;\\n\\tt.deactivateButton = deactivateButton;\\n\\tt.disableButton = disableButton;\\n\\tt.enableButton = enableButton;\\n\\tt.getViewsWithButtons = getViewsWithButtons;\\n\\tt.el = null; // mirrors local `el`\\n\\n\\t// locals\\n\\tvar el;\\n\\tvar viewsWithButtons = [];\\n\\tvar tm;\\n\\n\\t// method to update toolbar-specific options, not calendar-wide options\\n\\tfunction setToolbarOptions(newToolbarOptions) {\\n\\t\\ttoolbarOptions = newToolbarOptions;\\n\\t}\\n\\n\\t// can be called repeatedly and will rerender\\n\\tfunction render() {\\n\\t\\tvar sections = toolbarOptions.layout;\\n\\n\\t\\ttm = calendar.opt('theme') ? 'ui' : 'fc';\\n\\n\\t\\tif (sections) {\\n\\t\\t\\tif (!el) {\\n\\t\\t\\t\\tel = this.el = $(\\\"<div class='fc-toolbar \\\"+ toolbarOptions.extraClasses + \\\"'/>\\\");\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tel.empty();\\n\\t\\t\\t}\\n\\t\\t\\tel.append(renderSection('left'))\\n\\t\\t\\t\\t.append(renderSection('right'))\\n\\t\\t\\t\\t.append(renderSection('center'))\\n\\t\\t\\t\\t.append('<div class=\\\"fc-clear\\\"/>');\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tremoveElement();\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction removeElement() {\\n\\t\\tif (el) {\\n\\t\\t\\tel.remove();\\n\\t\\t\\tel = t.el = null;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction renderSection(position) {\\n\\t\\tvar sectionEl = $('<div class=\\\"fc-' + position + '\\\"/>');\\n\\t\\tvar buttonStr = toolbarOptions.layout[position];\\n\\t\\tvar calendarCustomButtons = calendar.opt('customButtons') || {};\\n\\t\\tvar calendarButtonText = calendar.opt('buttonText') || {};\\n\\n\\t\\tif (buttonStr) {\\n\\t\\t\\t$.each(buttonStr.split(' '), function(i) {\\n\\t\\t\\t\\tvar groupChildren = $();\\n\\t\\t\\t\\tvar isOnlyButtons = true;\\n\\t\\t\\t\\tvar groupEl;\\n\\n\\t\\t\\t\\t$.each(this.split(','), function(j, buttonName) {\\n\\t\\t\\t\\t\\tvar customButtonProps;\\n\\t\\t\\t\\t\\tvar viewSpec;\\n\\t\\t\\t\\t\\tvar buttonClick;\\n\\t\\t\\t\\t\\tvar overrideText; // text explicitly set by calendar's constructor options. overcomes icons\\n\\t\\t\\t\\t\\tvar defaultText;\\n\\t\\t\\t\\t\\tvar themeIcon;\\n\\t\\t\\t\\t\\tvar normalIcon;\\n\\t\\t\\t\\t\\tvar innerHtml;\\n\\t\\t\\t\\t\\tvar classes;\\n\\t\\t\\t\\t\\tvar button; // the element\\n\\n\\t\\t\\t\\t\\tif (buttonName == 'title') {\\n\\t\\t\\t\\t\\t\\tgroupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\\n\\t\\t\\t\\t\\t\\tisOnlyButtons = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tif ((customButtonProps = calendarCustomButtons[buttonName])) {\\n\\t\\t\\t\\t\\t\\t\\tbuttonClick = function(ev) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (customButtonProps.click) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcustomButtonProps.click.call(button[0], ev);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\toverrideText = ''; // icons will override text\\n\\t\\t\\t\\t\\t\\t\\tdefaultText = customButtonProps.text;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if ((viewSpec = calendar.getViewSpec(buttonName))) {\\n\\t\\t\\t\\t\\t\\t\\tbuttonClick = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tcalendar.changeView(buttonName);\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\tviewsWithButtons.push(buttonName);\\n\\t\\t\\t\\t\\t\\t\\toverrideText = viewSpec.buttonTextOverride;\\n\\t\\t\\t\\t\\t\\t\\tdefaultText = viewSpec.buttonTextDefault;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (calendar[buttonName]) { // a calendar method\\n\\t\\t\\t\\t\\t\\t\\tbuttonClick = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tcalendar[buttonName]();\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\toverrideText = (calendar.overrides.buttonText || {})[buttonName];\\n\\t\\t\\t\\t\\t\\t\\tdefaultText = calendarButtonText[buttonName]; // everything else is considered default\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (buttonClick) {\\n\\n\\t\\t\\t\\t\\t\\t\\tthemeIcon =\\n\\t\\t\\t\\t\\t\\t\\t\\tcustomButtonProps ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcustomButtonProps.themeIcon :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcalendar.opt('themeButtonIcons')[buttonName];\\n\\n\\t\\t\\t\\t\\t\\t\\tnormalIcon =\\n\\t\\t\\t\\t\\t\\t\\t\\tcustomButtonProps ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcustomButtonProps.icon :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcalendar.opt('buttonIcons')[buttonName];\\n\\n\\t\\t\\t\\t\\t\\t\\tif (overrideText) {\\n\\t\\t\\t\\t\\t\\t\\t\\tinnerHtml = htmlEscape(overrideText);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if (themeIcon && calendar.opt('theme')) {\\n\\t\\t\\t\\t\\t\\t\\t\\tinnerHtml = \\\"<span class='ui-icon ui-icon-\\\" + themeIcon + \\\"'></span>\\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if (normalIcon && !calendar.opt('theme')) {\\n\\t\\t\\t\\t\\t\\t\\t\\tinnerHtml = \\\"<span class='fc-icon fc-icon-\\\" + normalIcon + \\\"'></span>\\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\t\\tinnerHtml = htmlEscape(defaultText);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tclasses = [\\n\\t\\t\\t\\t\\t\\t\\t\\t'fc-' + buttonName + '-button',\\n\\t\\t\\t\\t\\t\\t\\t\\ttm + '-button',\\n\\t\\t\\t\\t\\t\\t\\t\\ttm + '-state-default'\\n\\t\\t\\t\\t\\t\\t\\t];\\n\\n\\t\\t\\t\\t\\t\\t\\tbutton = $( // type=\\\"button\\\" so that it doesn't submit a form\\n\\t\\t\\t\\t\\t\\t\\t\\t'<button type=\\\"button\\\" class=\\\"' + classes.join(' ') + '\\\">' +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tinnerHtml +\\n\\t\\t\\t\\t\\t\\t\\t\\t'</button>'\\n\\t\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t\\t\\t.click(function(ev) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// don't process clicks for disabled buttons\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (!button.hasClass(tm + '-state-disabled')) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbuttonClick(ev);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// after the click action, if the button becomes the \\\"active\\\" tab, or disabled,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// it should never have a hover class, so remove it now.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbutton.hasClass(tm + '-state-active') ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbutton.hasClass(tm + '-state-disabled')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbutton.removeClass(tm + '-state-hover');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\\t\\t\\t\\t.mousedown(function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// the *down* effect (mouse pressed in).\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// only on buttons that are not the \\\"active\\\" tab, or disabled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbutton\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.not('.' + tm + '-state-active')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.not('.' + tm + '-state-disabled')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.addClass(tm + '-state-down');\\n\\t\\t\\t\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\\t\\t\\t\\t.mouseup(function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// undo the *down* effect\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbutton.removeClass(tm + '-state-down');\\n\\t\\t\\t\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\\t\\t\\t\\t.hover(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// the *hover* effect.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// only on buttons that are not the \\\"active\\\" tab, or disabled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbutton\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.not('.' + tm + '-state-active')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.not('.' + tm + '-state-disabled')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.addClass(tm + '-state-hover');\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// undo the *hover* effect\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbutton\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.removeClass(tm + '-state-hover')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tgroupChildren = groupChildren.add(button);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (isOnlyButtons) {\\n\\t\\t\\t\\t\\tgroupChildren\\n\\t\\t\\t\\t\\t\\t.first().addClass(tm + '-corner-left').end()\\n\\t\\t\\t\\t\\t\\t.last().addClass(tm + '-corner-right').end();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (groupChildren.length > 1) {\\n\\t\\t\\t\\t\\tgroupEl = $('<div/>');\\n\\t\\t\\t\\t\\tif (isOnlyButtons) {\\n\\t\\t\\t\\t\\t\\tgroupEl.addClass('fc-button-group');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgroupEl.append(groupChildren);\\n\\t\\t\\t\\t\\tsectionEl.append(groupEl);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tsectionEl.append(groupChildren); // 1 or 0 children\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn sectionEl;\\n\\t}\\n\\n\\n\\tfunction updateTitle(text) {\\n\\t\\tif (el) {\\n\\t\\t\\tel.find('h2').text(text);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction activateButton(buttonName) {\\n\\t\\tif (el) {\\n\\t\\t\\tel.find('.fc-' + buttonName + '-button')\\n\\t\\t\\t\\t.addClass(tm + '-state-active');\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction deactivateButton(buttonName) {\\n\\t\\tif (el) {\\n\\t\\t\\tel.find('.fc-' + buttonName + '-button')\\n\\t\\t\\t\\t.removeClass(tm + '-state-active');\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction disableButton(buttonName) {\\n\\t\\tif (el) {\\n\\t\\t\\tel.find('.fc-' + buttonName + '-button')\\n\\t\\t\\t\\t.prop('disabled', true)\\n\\t\\t\\t\\t.addClass(tm + '-state-disabled');\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction enableButton(buttonName) {\\n\\t\\tif (el) {\\n\\t\\t\\tel.find('.fc-' + buttonName + '-button')\\n\\t\\t\\t\\t.prop('disabled', false)\\n\\t\\t\\t\\t.removeClass(tm + '-state-disabled');\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction getViewsWithButtons() {\\n\\t\\treturn viewsWithButtons;\\n\\t}\\n\\n}\\n\\n;;\\n\\nvar Calendar = FC.Calendar = Class.extend(EmitterMixin, {\\n\\n\\tview: null, // current View object\\n\\tviewsByType: null, // holds all instantiated view instances, current or not\\n\\tcurrentDate: null, // unzoned moment. private (public API should use getDate instead)\\n\\tloadingLevel: 0, // number of simultaneous loading tasks\\n\\n\\n\\tconstructor: function(el, overrides) {\\n\\n\\t\\t// declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.\\n\\t\\t// unneeded() is called in destroy.\\n\\t\\tGlobalEmitter.needed();\\n\\n\\t\\tthis.el = el;\\n\\t\\tthis.viewsByType = {};\\n\\t\\tthis.viewSpecCache = {};\\n\\n\\t\\tthis.initOptionsInternals(overrides);\\n\\t\\tthis.initMomentInternals(); // needs to happen after options hash initialized\\n\\t\\tthis.initCurrentDate();\\n\\n\\t\\tEventManager.call(this); // needs options immediately\\n\\t\\tthis.initialize();\\n\\t},\\n\\n\\n\\t// Subclasses can override this for initialization logic after the constructor has been called\\n\\tinitialize: function() {\\n\\t},\\n\\n\\n\\t// Public API\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tgetCalendar: function() {\\n\\t\\treturn this;\\n\\t},\\n\\n\\n\\tgetView: function() {\\n\\t\\treturn this.view;\\n\\t},\\n\\n\\n\\tpubliclyTrigger: function(name, thisObj) {\\n\\t\\tvar args = Array.prototype.slice.call(arguments, 2);\\n\\t\\tvar optHandler = this.opt(name);\\n\\n\\t\\tthisObj = thisObj || this.el[0];\\n\\t\\tthis.triggerWith(name, thisObj, args); // Emitter's method\\n\\n\\t\\tif (optHandler) {\\n\\t\\t\\treturn optHandler.apply(thisObj, args);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// View\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Given a view name for a custom view or a standard view, creates a ready-to-go View object\\n\\tinstantiateView: function(viewType) {\\n\\t\\tvar spec = this.getViewSpec(viewType);\\n\\n\\t\\treturn new spec['class'](this, spec);\\n\\t},\\n\\n\\n\\t// Returns a boolean about whether the view is okay to instantiate at some point\\n\\tisValidViewType: function(viewType) {\\n\\t\\treturn Boolean(this.getViewSpec(viewType));\\n\\t},\\n\\n\\n\\tchangeView: function(viewName, dateOrRange) {\\n\\n\\t\\tif (dateOrRange) {\\n\\n\\t\\t\\tif (dateOrRange.start && dateOrRange.end) { // a range\\n\\t\\t\\t\\tthis.recordOptionOverrides({ // will not rerender\\n\\t\\t\\t\\t\\tvisibleRange: dateOrRange\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\telse { // a date\\n\\t\\t\\t\\tthis.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.renderView(viewName);\\n\\t},\\n\\n\\n\\t// Forces navigation to a view for the given date.\\n\\t// `viewType` can be a specific view name or a generic one like \\\"week\\\" or \\\"day\\\".\\n\\tzoomTo: function(newDate, viewType) {\\n\\t\\tvar spec;\\n\\n\\t\\tviewType = viewType || 'day'; // day is default zoom\\n\\t\\tspec = this.getViewSpec(viewType) || this.getUnitViewSpec(viewType);\\n\\n\\t\\tthis.currentDate = newDate.clone();\\n\\t\\tthis.renderView(spec ? spec.type : null);\\n\\t},\\n\\n\\n\\t// Current Date\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\tinitCurrentDate: function() {\\n\\t\\tvar defaultDateInput = this.opt('defaultDate');\\n\\n\\t\\t// compute the initial ambig-timezone date\\n\\t\\tif (defaultDateInput != null) {\\n\\t\\t\\tthis.currentDate = this.moment(defaultDateInput).stripZone();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.currentDate = this.getNow(); // getNow already returns unzoned\\n\\t\\t}\\n\\t},\\n\\n\\n\\tprev: function() {\\n\\t\\tvar prevInfo = this.view.buildPrevDateProfile(this.currentDate);\\n\\n\\t\\tif (prevInfo.isValid) {\\n\\t\\t\\tthis.currentDate = prevInfo.date;\\n\\t\\t\\tthis.renderView();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tnext: function() {\\n\\t\\tvar nextInfo = this.view.buildNextDateProfile(this.currentDate);\\n\\n\\t\\tif (nextInfo.isValid) {\\n\\t\\t\\tthis.currentDate = nextInfo.date;\\n\\t\\t\\tthis.renderView();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tprevYear: function() {\\n\\t\\tthis.currentDate.add(-1, 'years');\\n\\t\\tthis.renderView();\\n\\t},\\n\\n\\n\\tnextYear: function() {\\n\\t\\tthis.currentDate.add(1, 'years');\\n\\t\\tthis.renderView();\\n\\t},\\n\\n\\n\\ttoday: function() {\\n\\t\\tthis.currentDate = this.getNow(); // should deny like prev/next?\\n\\t\\tthis.renderView();\\n\\t},\\n\\n\\n\\tgotoDate: function(zonedDateInput) {\\n\\t\\tthis.currentDate = this.moment(zonedDateInput).stripZone();\\n\\t\\tthis.renderView();\\n\\t},\\n\\n\\n\\tincrementDate: function(delta) {\\n\\t\\tthis.currentDate.add(moment.duration(delta));\\n\\t\\tthis.renderView();\\n\\t},\\n\\n\\n\\t// for external API\\n\\tgetDate: function() {\\n\\t\\treturn this.applyTimezone(this.currentDate); // infuse the calendar's timezone\\n\\t},\\n\\n\\n\\t// Loading Triggering\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Should be called when any type of async data fetching begins\\n\\tpushLoading: function() {\\n\\t\\tif (!(this.loadingLevel++)) {\\n\\t\\t\\tthis.publiclyTrigger('loading', null, true, this.view);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Should be called when any type of async data fetching completes\\n\\tpopLoading: function() {\\n\\t\\tif (!(--this.loadingLevel)) {\\n\\t\\t\\tthis.publiclyTrigger('loading', null, false, this.view);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Selection\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// this public method receives start/end dates in any format, with any timezone\\n\\tselect: function(zonedStartInput, zonedEndInput) {\\n\\t\\tthis.view.select(\\n\\t\\t\\tthis.buildSelectSpan.apply(this, arguments)\\n\\t\\t);\\n\\t},\\n\\n\\n\\tunselect: function() { // safe to be called before renderView\\n\\t\\tif (this.view) {\\n\\t\\t\\tthis.view.unselect();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\\n\\tbuildSelectSpan: function(zonedStartInput, zonedEndInput) {\\n\\t\\tvar start = this.moment(zonedStartInput).stripZone();\\n\\t\\tvar end;\\n\\n\\t\\tif (zonedEndInput) {\\n\\t\\t\\tend = this.moment(zonedEndInput).stripZone();\\n\\t\\t}\\n\\t\\telse if (start.hasTime()) {\\n\\t\\t\\tend = start.clone().add(this.defaultTimedEventDuration);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tend = start.clone().add(this.defaultAllDayEventDuration);\\n\\t\\t}\\n\\n\\t\\treturn { start: start, end: end };\\n\\t},\\n\\n\\n\\t// Misc\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// will return `null` if invalid range\\n\\tparseRange: function(rangeInput) {\\n\\t\\tvar start = null;\\n\\t\\tvar end = null;\\n\\n\\t\\tif (rangeInput.start) {\\n\\t\\t\\tstart = this.moment(rangeInput.start).stripZone();\\n\\t\\t}\\n\\n\\t\\tif (rangeInput.end) {\\n\\t\\t\\tend = this.moment(rangeInput.end).stripZone();\\n\\t\\t}\\n\\n\\t\\tif (!start && !end) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif (start && end && end.isBefore(start)) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\treturn { start: start, end: end };\\n\\t},\\n\\n\\n\\trerenderEvents: function() { // API method. destroys old events if previously rendered.\\n\\t\\tif (this.elementVisible()) {\\n\\t\\t\\tthis.reportEventChange(); // will re-trasmit events to the view, causing a rerender\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n;;\\n/*\\nOptions binding/triggering system.\\n*/\\nCalendar.mixin({\\n\\n\\tdirDefaults: null, // option defaults related to LTR or RTL\\n\\tlocaleDefaults: null, // option defaults related to current locale\\n\\toverrides: null, // option overrides given to the fullCalendar constructor\\n\\tdynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.\\n\\toptionsModel: null, // all defaults combined with overrides\\n\\n\\n\\tinitOptionsInternals: function(overrides) {\\n\\t\\tthis.overrides = $.extend({}, overrides); // make a copy\\n\\t\\tthis.dynamicOverrides = {};\\n\\t\\tthis.optionsModel = new Model();\\n\\n\\t\\tthis.populateOptionsHash();\\n\\t},\\n\\n\\n\\t// public getter/setter\\n\\toption: function(name, value) {\\n\\t\\tvar newOptionHash;\\n\\n\\t\\tif (typeof name === 'string') {\\n\\t\\t\\tif (value === undefined) { // getter\\n\\t\\t\\t\\treturn this.optionsModel.get(name);\\n\\t\\t\\t}\\n\\t\\t\\telse { // setter for individual option\\n\\t\\t\\t\\tnewOptionHash = {};\\n\\t\\t\\t\\tnewOptionHash[name] = value;\\n\\t\\t\\t\\tthis.setOptions(newOptionHash);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (typeof name === 'object') { // compound setter with object input\\n\\t\\t\\tthis.setOptions(name);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// private getter\\n\\topt: function(name) {\\n\\t\\treturn this.optionsModel.get(name);\\n\\t},\\n\\n\\n\\tsetOptions: function(newOptionHash) {\\n\\t\\tvar optionCnt = 0;\\n\\t\\tvar optionName;\\n\\n\\t\\tthis.recordOptionOverrides(newOptionHash);\\n\\n\\t\\tfor (optionName in newOptionHash) {\\n\\t\\t\\toptionCnt++;\\n\\t\\t}\\n\\n\\t\\t// special-case handling of single option change.\\n\\t\\t// if only one option change, `optionName` will be its name.\\n\\t\\tif (optionCnt === 1) {\\n\\t\\t\\tif (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\\n\\t\\t\\t\\tthis.updateSize(true); // true = allow recalculation of height\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse if (optionName === 'defaultDate') {\\n\\t\\t\\t\\treturn; // can't change date this way. use gotoDate instead\\n\\t\\t\\t}\\n\\t\\t\\telse if (optionName === 'businessHours') {\\n\\t\\t\\t\\tif (this.view) {\\n\\t\\t\\t\\t\\tthis.view.unrenderBusinessHours();\\n\\t\\t\\t\\t\\tthis.view.renderBusinessHours();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse if (optionName === 'timezone') {\\n\\t\\t\\t\\tthis.rezoneArrayEventSources();\\n\\t\\t\\t\\tthis.refetchEvents();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// catch-all. rerender the header and footer and rebuild/rerender the current view\\n\\t\\tthis.renderHeader();\\n\\t\\tthis.renderFooter();\\n\\n\\t\\t// even non-current views will be affected by this option change. do before rerender\\n\\t\\t// TODO: detangle\\n\\t\\tthis.viewsByType = {};\\n\\n\\t\\tthis.reinitView();\\n\\t},\\n\\n\\n\\t// Computes the flattened options hash for the calendar and assigns to `this.options`.\\n\\t// Assumes this.overrides and this.dynamicOverrides have already been initialized.\\n\\tpopulateOptionsHash: function() {\\n\\t\\tvar locale, localeDefaults;\\n\\t\\tvar isRTL, dirDefaults;\\n\\t\\tvar rawOptions;\\n\\n\\t\\tlocale = firstDefined( // explicit locale option given?\\n\\t\\t\\tthis.dynamicOverrides.locale,\\n\\t\\t\\tthis.overrides.locale\\n\\t\\t);\\n\\t\\tlocaleDefaults = localeOptionHash[locale];\\n\\t\\tif (!localeDefaults) { // explicit locale option not given or invalid?\\n\\t\\t\\tlocale = Calendar.defaults.locale;\\n\\t\\t\\tlocaleDefaults = localeOptionHash[locale] || {};\\n\\t\\t}\\n\\n\\t\\tisRTL = firstDefined( // based on options computed so far, is direction RTL?\\n\\t\\t\\tthis.dynamicOverrides.isRTL,\\n\\t\\t\\tthis.overrides.isRTL,\\n\\t\\t\\tlocaleDefaults.isRTL,\\n\\t\\t\\tCalendar.defaults.isRTL\\n\\t\\t);\\n\\t\\tdirDefaults = isRTL ? Calendar.rtlDefaults : {};\\n\\n\\t\\tthis.dirDefaults = dirDefaults;\\n\\t\\tthis.localeDefaults = localeDefaults;\\n\\n\\t\\trawOptions = mergeOptions([ // merge defaults and overrides. lowest to highest precedence\\n\\t\\t\\tCalendar.defaults, // global defaults\\n\\t\\t\\tdirDefaults,\\n\\t\\t\\tlocaleDefaults,\\n\\t\\t\\tthis.overrides,\\n\\t\\t\\tthis.dynamicOverrides\\n\\t\\t]);\\n\\t\\tpopulateInstanceComputableOptions(rawOptions); // fill in gaps with computed options\\n\\n\\t\\tthis.optionsModel.reset(rawOptions);\\n\\t},\\n\\n\\n\\t// stores the new options internally, but does not rerender anything.\\n\\trecordOptionOverrides: function(newOptionHash) {\\n\\t\\tvar optionName;\\n\\n\\t\\tfor (optionName in newOptionHash) {\\n\\t\\t\\tthis.dynamicOverrides[optionName] = newOptionHash[optionName];\\n\\t\\t}\\n\\n\\t\\tthis.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it\\n\\t\\tthis.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override\\n\\t}\\n\\n});\\n\\n;;\\n\\nCalendar.mixin({\\n\\n\\tdefaultAllDayEventDuration: null,\\n\\tdefaultTimedEventDuration: null,\\n\\tlocaleData: null,\\n\\n\\n\\tinitMomentInternals: function() {\\n\\t\\tvar _this = this;\\n\\n\\t\\tthis.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));\\n\\t\\tthis.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));\\n\\n\\t\\t// Called immediately, and when any of the options change.\\n\\t\\t// Happens before any internal objects rebuild or rerender, because this is very core.\\n\\t\\tthis.optionsModel.watch('buildingMomentLocale', [\\n\\t\\t\\t'?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',\\n\\t\\t\\t'?firstDay', '?weekNumberCalculation'\\n\\t\\t], function(opts) {\\n\\t\\t\\tvar weekNumberCalculation = opts.weekNumberCalculation;\\n\\t\\t\\tvar firstDay = opts.firstDay;\\n\\t\\t\\tvar _week;\\n\\n\\t\\t\\t// normalize\\n\\t\\t\\tif (weekNumberCalculation === 'iso') {\\n\\t\\t\\t\\tweekNumberCalculation = 'ISO'; // normalize\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar localeData = createObject( // make a cheap copy\\n\\t\\t\\t\\tgetMomentLocaleData(opts.locale) // will fall back to en\\n\\t\\t\\t);\\n\\n\\t\\t\\tif (opts.monthNames) {\\n\\t\\t\\t\\tlocaleData._months = opts.monthNames;\\n\\t\\t\\t}\\n\\t\\t\\tif (opts.monthNamesShort) {\\n\\t\\t\\t\\tlocaleData._monthsShort = opts.monthNamesShort;\\n\\t\\t\\t}\\n\\t\\t\\tif (opts.dayNames) {\\n\\t\\t\\t\\tlocaleData._weekdays = opts.dayNames;\\n\\t\\t\\t}\\n\\t\\t\\tif (opts.dayNamesShort) {\\n\\t\\t\\t\\tlocaleData._weekdaysShort = opts.dayNamesShort;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (firstDay == null && weekNumberCalculation === 'ISO') {\\n\\t\\t\\t\\tfirstDay = 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (firstDay != null) {\\n\\t\\t\\t\\t_week = createObject(localeData._week); // _week: { dow: # }\\n\\t\\t\\t\\t_week.dow = firstDay;\\n\\t\\t\\t\\tlocaleData._week = _week;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( // whitelist certain kinds of input\\n\\t\\t\\t\\tweekNumberCalculation === 'ISO' ||\\n\\t\\t\\t\\tweekNumberCalculation === 'local' ||\\n\\t\\t\\t\\ttypeof weekNumberCalculation === 'function'\\n\\t\\t\\t) {\\n\\t\\t\\t\\tlocaleData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\\n\\t\\t\\t}\\n\\n\\t\\t\\t_this.localeData = localeData;\\n\\n\\t\\t\\t// If the internal current date object already exists, move to new locale.\\n\\t\\t\\t// We do NOT need to do this technique for event dates, because this happens when converting to \\\"segments\\\".\\n\\t\\t\\tif (_this.currentDate) {\\n\\t\\t\\t\\t_this.localizeMoment(_this.currentDate); // sets to localeData\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Builds a moment using the settings of the current calendar: timezone and locale.\\n\\t// Accepts anything the vanilla moment() constructor accepts.\\n\\tmoment: function() {\\n\\t\\tvar mom;\\n\\n\\t\\tif (this.opt('timezone') === 'local') {\\n\\t\\t\\tmom = FC.moment.apply(null, arguments);\\n\\n\\t\\t\\t// Force the moment to be local, because FC.moment doesn't guarantee it.\\n\\t\\t\\tif (mom.hasTime()) { // don't give ambiguously-timed moments a local zone\\n\\t\\t\\t\\tmom.local();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (this.opt('timezone') === 'UTC') {\\n\\t\\t\\tmom = FC.moment.utc.apply(null, arguments); // process as UTC\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone\\n\\t\\t}\\n\\n\\t\\tthis.localizeMoment(mom); // TODO\\n\\n\\t\\treturn mom;\\n\\t},\\n\\n\\n\\t// Updates the given moment's locale settings to the current calendar locale settings.\\n\\tlocalizeMoment: function(mom) {\\n\\t\\tmom._locale = this.localeData;\\n\\t},\\n\\n\\n\\t// Returns a boolean about whether or not the calendar knows how to calculate\\n\\t// the timezone offset of arbitrary dates in the current timezone.\\n\\tgetIsAmbigTimezone: function() {\\n\\t\\treturn this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';\\n\\t},\\n\\n\\n\\t// Returns a copy of the given date in the current timezone. Has no effect on dates without times.\\n\\tapplyTimezone: function(date) {\\n\\t\\tif (!date.hasTime()) {\\n\\t\\t\\treturn date.clone();\\n\\t\\t}\\n\\n\\t\\tvar zonedDate = this.moment(date.toArray());\\n\\t\\tvar timeAdjust = date.time() - zonedDate.time();\\n\\t\\tvar adjustedZonedDate;\\n\\n\\t\\t// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\\n\\t\\tif (timeAdjust) { // is the time result different than expected?\\n\\t\\t\\tadjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\\n\\t\\t\\tif (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?\\n\\t\\t\\t\\tzonedDate = adjustedZonedDate;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn zonedDate;\\n\\t},\\n\\n\\n\\t// Returns a moment for the current date, as defined by the client's computer or from the `now` option.\\n\\t// Will return an moment with an ambiguous timezone.\\n\\tgetNow: function() {\\n\\t\\tvar now = this.opt('now');\\n\\t\\tif (typeof now === 'function') {\\n\\t\\t\\tnow = now();\\n\\t\\t}\\n\\t\\treturn this.moment(now).stripZone();\\n\\t},\\n\\n\\n\\t// Produces a human-readable string for the given duration.\\n\\t// Side-effect: changes the locale of the given duration.\\n\\thumanizeDuration: function(duration) {\\n\\t\\treturn duration.locale(this.opt('locale')).humanize();\\n\\t},\\n\\n\\n\\n\\t// Event-Specific Date Utilities. TODO: move\\n\\t// -----------------------------------------------------------------------------------------------------------------\\n\\n\\n\\t// Get an event's normalized end date. If not present, calculate it from the defaults.\\n\\tgetEventEnd: function(event) {\\n\\t\\tif (event.end) {\\n\\t\\t\\treturn event.end.clone();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn this.getDefaultEventEnd(event.allDay, event.start);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Given an event's allDay status and start date, return what its fallback end date should be.\\n\\t// TODO: rename to computeDefaultEventEnd\\n\\tgetDefaultEventEnd: function(allDay, zonedStart) {\\n\\t\\tvar end = zonedStart.clone();\\n\\n\\t\\tif (allDay) {\\n\\t\\t\\tend.stripTime().add(this.defaultAllDayEventDuration);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tend.add(this.defaultTimedEventDuration);\\n\\t\\t}\\n\\n\\t\\tif (this.getIsAmbigTimezone()) {\\n\\t\\t\\tend.stripZone(); // we don't know what the tzo should be\\n\\t\\t}\\n\\n\\t\\treturn end;\\n\\t}\\n\\n});\\n\\n;;\\n\\nCalendar.mixin({\\n\\n\\tviewSpecCache: null, // cache of view definitions (initialized in Calendar.js)\\n\\n\\n\\t// Gets information about how to create a view. Will use a cache.\\n\\tgetViewSpec: function(viewType) {\\n\\t\\tvar cache = this.viewSpecCache;\\n\\n\\t\\treturn cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\\n\\t},\\n\\n\\n\\t// Given a duration singular unit, like \\\"week\\\" or \\\"day\\\", finds a matching view spec.\\n\\t// Preference is given to views that have corresponding buttons.\\n\\tgetUnitViewSpec: function(unit) {\\n\\t\\tvar viewTypes;\\n\\t\\tvar i;\\n\\t\\tvar spec;\\n\\n\\t\\tif ($.inArray(unit, unitsDesc) != -1) {\\n\\n\\t\\t\\t// put views that have buttons first. there will be duplicates, but oh well\\n\\t\\t\\tviewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?\\n\\t\\t\\t$.each(FC.views, function(viewType) { // all views\\n\\t\\t\\t\\tviewTypes.push(viewType);\\n\\t\\t\\t});\\n\\n\\t\\t\\tfor (i = 0; i < viewTypes.length; i++) {\\n\\t\\t\\t\\tspec = this.getViewSpec(viewTypes[i]);\\n\\t\\t\\t\\tif (spec) {\\n\\t\\t\\t\\t\\tif (spec.singleUnit == unit) {\\n\\t\\t\\t\\t\\t\\treturn spec;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Builds an object with information on how to create a given view\\n\\tbuildViewSpec: function(requestedViewType) {\\n\\t\\tvar viewOverrides = this.overrides.views || {};\\n\\t\\tvar specChain = []; // for the view. lowest to highest priority\\n\\t\\tvar defaultsChain = []; // for the view. lowest to highest priority\\n\\t\\tvar overridesChain = []; // for the view. lowest to highest priority\\n\\t\\tvar viewType = requestedViewType;\\n\\t\\tvar spec; // for the view\\n\\t\\tvar overrides; // for the view\\n\\t\\tvar durationInput;\\n\\t\\tvar duration;\\n\\t\\tvar unit;\\n\\n\\t\\t// iterate from the specific view definition to a more general one until we hit an actual View class\\n\\t\\twhile (viewType) {\\n\\t\\t\\tspec = fcViews[viewType];\\n\\t\\t\\toverrides = viewOverrides[viewType];\\n\\t\\t\\tviewType = null; // clear. might repopulate for another iteration\\n\\n\\t\\t\\tif (typeof spec === 'function') { // TODO: deprecate\\n\\t\\t\\t\\tspec = { 'class': spec };\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (spec) {\\n\\t\\t\\t\\tspecChain.unshift(spec);\\n\\t\\t\\t\\tdefaultsChain.unshift(spec.defaults || {});\\n\\t\\t\\t\\tdurationInput = durationInput || spec.duration;\\n\\t\\t\\t\\tviewType = viewType || spec.type;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (overrides) {\\n\\t\\t\\t\\toverridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\\n\\t\\t\\t\\tdurationInput = durationInput || overrides.duration;\\n\\t\\t\\t\\tviewType = viewType || overrides.type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tspec = mergeProps(specChain);\\n\\t\\tspec.type = requestedViewType;\\n\\t\\tif (!spec['class']) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// fall back to top-level `duration` option\\n\\t\\tdurationInput = durationInput ||\\n\\t\\t\\tthis.dynamicOverrides.duration ||\\n\\t\\t\\tthis.overrides.duration;\\n\\n\\t\\tif (durationInput) {\\n\\t\\t\\tduration = moment.duration(durationInput);\\n\\n\\t\\t\\tif (duration.valueOf()) { // valid?\\n\\n\\t\\t\\t\\tunit = computeDurationGreatestUnit(duration, durationInput);\\n\\n\\t\\t\\t\\tspec.duration = duration;\\n\\t\\t\\t\\tspec.durationUnit = unit;\\n\\n\\t\\t\\t\\t// view is a single-unit duration, like \\\"week\\\" or \\\"day\\\"\\n\\t\\t\\t\\t// incorporate options for this. lowest priority\\n\\t\\t\\t\\tif (duration.as(unit) === 1) {\\n\\t\\t\\t\\t\\tspec.singleUnit = unit;\\n\\t\\t\\t\\t\\toverridesChain.unshift(viewOverrides[unit] || {});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tspec.defaults = mergeOptions(defaultsChain);\\n\\t\\tspec.overrides = mergeOptions(overridesChain);\\n\\n\\t\\tthis.buildViewSpecOptions(spec);\\n\\t\\tthis.buildViewSpecButtonText(spec, requestedViewType);\\n\\n\\t\\treturn spec;\\n\\t},\\n\\n\\n\\t// Builds and assigns a view spec's options object from its already-assigned defaults and overrides\\n\\tbuildViewSpecOptions: function(spec) {\\n\\t\\tspec.options = mergeOptions([ // lowest to highest priority\\n\\t\\t\\tCalendar.defaults, // global defaults\\n\\t\\t\\tspec.defaults, // view's defaults (from ViewSubclass.defaults)\\n\\t\\t\\tthis.dirDefaults,\\n\\t\\t\\tthis.localeDefaults, // locale and dir take precedence over view's defaults!\\n\\t\\t\\tthis.overrides, // calendar's overrides (options given to constructor)\\n\\t\\t\\tspec.overrides, // view's overrides (view-specific options)\\n\\t\\t\\tthis.dynamicOverrides // dynamically set via setter. highest precedence\\n\\t\\t]);\\n\\t\\tpopulateInstanceComputableOptions(spec.options);\\n\\t},\\n\\n\\n\\t// Computes and assigns a view spec's buttonText-related options\\n\\tbuildViewSpecButtonText: function(spec, requestedViewType) {\\n\\n\\t\\t// given an options object with a possible `buttonText` hash, lookup the buttonText for the\\n\\t\\t// requested view, falling back to a generic unit entry like \\\"week\\\" or \\\"day\\\"\\n\\t\\tfunction queryButtonText(options) {\\n\\t\\t\\tvar buttonText = options.buttonText || {};\\n\\t\\t\\treturn buttonText[requestedViewType] ||\\n\\t\\t\\t\\t// view can decide to look up a certain key\\n\\t\\t\\t\\t(spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||\\n\\t\\t\\t\\t// a key like \\\"month\\\"\\n\\t\\t\\t\\t(spec.singleUnit ? buttonText[spec.singleUnit] : null);\\n\\t\\t}\\n\\n\\t\\t// highest to lowest priority\\n\\t\\tspec.buttonTextOverride =\\n\\t\\t\\tqueryButtonText(this.dynamicOverrides) ||\\n\\t\\t\\tqueryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence\\n\\t\\t\\tspec.overrides.buttonText; // `buttonText` for view-specific options is a string\\n\\n\\t\\t// highest to lowest priority. mirrors buildViewSpecOptions\\n\\t\\tspec.buttonTextDefault =\\n\\t\\t\\tqueryButtonText(this.localeDefaults) ||\\n\\t\\t\\tqueryButtonText(this.dirDefaults) ||\\n\\t\\t\\tspec.defaults.buttonText || // a single string. from ViewSubclass.defaults\\n\\t\\t\\tqueryButtonText(Calendar.defaults) ||\\n\\t\\t\\t(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like \\\"3 days\\\"\\n\\t\\t\\trequestedViewType; // fall back to given view name\\n\\t}\\n\\n});\\n\\n;;\\n\\nCalendar.mixin({\\n\\n\\tel: null,\\n\\tcontentEl: null,\\n\\tsuggestedViewHeight: null,\\n\\twindowResizeProxy: null,\\n\\tignoreWindowResize: 0,\\n\\n\\n\\trender: function() {\\n\\t\\tif (!this.contentEl) {\\n\\t\\t\\tthis.initialRender();\\n\\t\\t}\\n\\t\\telse if (this.elementVisible()) {\\n\\t\\t\\t// mainly for the public API\\n\\t\\t\\tthis.calcSize();\\n\\t\\t\\tthis.renderView();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tinitialRender: function() {\\n\\t\\tvar _this = this;\\n\\t\\tvar el = this.el;\\n\\n\\t\\tel.addClass('fc');\\n\\n\\t\\t// event delegation for nav links\\n\\t\\tel.on('click.fc', 'a[data-goto]', function(ev) {\\n\\t\\t\\tvar anchorEl = $(this);\\n\\t\\t\\tvar gotoOptions = anchorEl.data('goto'); // will automatically parse JSON\\n\\t\\t\\tvar date = _this.moment(gotoOptions.date);\\n\\t\\t\\tvar viewType = gotoOptions.type;\\n\\n\\t\\t\\t// property like \\\"navLinkDayClick\\\". might be a string or a function\\n\\t\\t\\tvar customAction = _this.view.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');\\n\\n\\t\\t\\tif (typeof customAction === 'function') {\\n\\t\\t\\t\\tcustomAction(date, ev);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif (typeof customAction === 'string') {\\n\\t\\t\\t\\t\\tviewType = customAction;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_this.zoomTo(date, viewType);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// called immediately, and upon option change\\n\\t\\tthis.optionsModel.watch('applyingThemeClasses', [ '?theme' ], function(opts) {\\n\\t\\t\\tel.toggleClass('ui-widget', opts.theme);\\n\\t\\t\\tel.toggleClass('fc-unthemed', !opts.theme);\\n\\t\\t});\\n\\n\\t\\t// called immediately, and upon option change.\\n\\t\\t// HACK: locale often affects isRTL, so we explicitly listen to that too.\\n\\t\\tthis.optionsModel.watch('applyingDirClasses', [ '?isRTL', '?locale' ], function(opts) {\\n\\t\\t\\tel.toggleClass('fc-ltr', !opts.isRTL);\\n\\t\\t\\tel.toggleClass('fc-rtl', opts.isRTL);\\n\\t\\t});\\n\\n\\t\\tthis.contentEl = $(\\\"<div class='fc-view-container'/>\\\").prependTo(el);\\n\\n\\t\\tthis.initToolbars();\\n\\t\\tthis.renderHeader();\\n\\t\\tthis.renderFooter();\\n\\t\\tthis.renderView(this.opt('defaultView'));\\n\\n\\t\\tif (this.opt('handleWindowResize')) {\\n\\t\\t\\t$(window).resize(\\n\\t\\t\\t\\tthis.windowResizeProxy = debounce( // prevents rapid calls\\n\\t\\t\\t\\t\\tthis.windowResize.bind(this),\\n\\t\\t\\t\\t\\tthis.opt('windowResizeDelay')\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tdestroy: function() {\\n\\n\\t\\tif (this.view) {\\n\\t\\t\\tthis.view.removeElement();\\n\\n\\t\\t\\t// NOTE: don't null-out this.view in case API methods are called after destroy.\\n\\t\\t\\t// It is still the \\\"current\\\" view, just not rendered.\\n\\t\\t}\\n\\n\\t\\tthis.toolbarsManager.proxyCall('removeElement');\\n\\t\\tthis.contentEl.remove();\\n\\t\\tthis.el.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');\\n\\n\\t\\tthis.el.off('.fc'); // unbind nav link handlers\\n\\n\\t\\tif (this.windowResizeProxy) {\\n\\t\\t\\t$(window).unbind('resize', this.windowResizeProxy);\\n\\t\\t\\tthis.windowResizeProxy = null;\\n\\t\\t}\\n\\n\\t\\tGlobalEmitter.unneeded();\\n\\t},\\n\\n\\n\\telementVisible: function() {\\n\\t\\treturn this.el.is(':visible');\\n\\t},\\n\\n\\n\\n\\t// View Rendering\\n\\t// -----------------------------------------------------------------------------------\\n\\n\\n\\t// Renders a view because of a date change, view-type change, or for the first time.\\n\\t// If not given a viewType, keep the current view but render different dates.\\n\\t// Accepts an optional scroll state to restore to.\\n\\trenderView: function(viewType, forcedScroll) {\\n\\n\\t\\tthis.ignoreWindowResize++;\\n\\n\\t\\tvar needsClearView = this.view && viewType && this.view.type !== viewType;\\n\\n\\t\\t// if viewType is changing, remove the old view's rendering\\n\\t\\tif (needsClearView) {\\n\\t\\t\\tthis.freezeContentHeight(); // prevent a scroll jump when view element is removed\\n\\t\\t\\tthis.clearView();\\n\\t\\t}\\n\\n\\t\\t// if viewType changed, or the view was never created, create a fresh view\\n\\t\\tif (!this.view && viewType) {\\n\\t\\t\\tthis.view =\\n\\t\\t\\t\\tthis.viewsByType[viewType] ||\\n\\t\\t\\t\\t(this.viewsByType[viewType] = this.instantiateView(viewType));\\n\\n\\t\\t\\tthis.view.setElement(\\n\\t\\t\\t\\t$(\\\"<div class='fc-view fc-\\\" + viewType + \\\"-view' />\\\").appendTo(this.contentEl)\\n\\t\\t\\t);\\n\\t\\t\\tthis.toolbarsManager.proxyCall('activateButton', viewType);\\n\\t\\t}\\n\\n\\t\\tif (this.view) {\\n\\n\\t\\t\\tif (forcedScroll) {\\n\\t\\t\\t\\tthis.view.addForcedScroll(forcedScroll);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (this.elementVisible()) {\\n\\t\\t\\t\\tthis.currentDate = this.view.setDate(this.currentDate);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (needsClearView) {\\n\\t\\t\\tthis.thawContentHeight();\\n\\t\\t}\\n\\n\\t\\tthis.ignoreWindowResize--;\\n\\t},\\n\\n\\n\\t// Unrenders the current view and reflects this change in the Header.\\n\\t// Unregsiters the `view`, but does not remove from viewByType hash.\\n\\tclearView: function() {\\n\\t\\tthis.toolbarsManager.proxyCall('deactivateButton', this.view.type);\\n\\t\\tthis.view.removeElement();\\n\\t\\tthis.view = null;\\n\\t},\\n\\n\\n\\t// Destroys the view, including the view object. Then, re-instantiates it and renders it.\\n\\t// Maintains the same scroll state.\\n\\t// TODO: maintain any other user-manipulated state.\\n\\treinitView: function() {\\n\\t\\tthis.ignoreWindowResize++;\\n\\t\\tthis.freezeContentHeight();\\n\\n\\t\\tvar viewType = this.view.type;\\n\\t\\tvar scrollState = this.view.queryScroll();\\n\\t\\tthis.clearView();\\n\\t\\tthis.calcSize();\\n\\t\\tthis.renderView(viewType, scrollState);\\n\\n\\t\\tthis.thawContentHeight();\\n\\t\\tthis.ignoreWindowResize--;\\n\\t},\\n\\n\\n\\t// Resizing\\n\\t// -----------------------------------------------------------------------------------\\n\\n\\n\\tgetSuggestedViewHeight: function() {\\n\\t\\tif (this.suggestedViewHeight === null) {\\n\\t\\t\\tthis.calcSize();\\n\\t\\t}\\n\\t\\treturn this.suggestedViewHeight;\\n\\t},\\n\\n\\n\\tisHeightAuto: function() {\\n\\t\\treturn this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';\\n\\t},\\n\\n\\n\\tupdateSize: function(shouldRecalc) {\\n\\t\\tif (this.elementVisible()) {\\n\\n\\t\\t\\tif (shouldRecalc) {\\n\\t\\t\\t\\tthis._calcSize();\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.ignoreWindowResize++;\\n\\t\\t\\tthis.view.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()\\n\\t\\t\\tthis.ignoreWindowResize--;\\n\\n\\t\\t\\treturn true; // signal success\\n\\t\\t}\\n\\t},\\n\\n\\n\\tcalcSize: function() {\\n\\t\\tif (this.elementVisible()) {\\n\\t\\t\\tthis._calcSize();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t_calcSize: function() { // assumes elementVisible\\n\\t\\tvar contentHeightInput = this.opt('contentHeight');\\n\\t\\tvar heightInput = this.opt('height');\\n\\n\\t\\tif (typeof contentHeightInput === 'number') { // exists and not 'auto'\\n\\t\\t\\tthis.suggestedViewHeight = contentHeightInput;\\n\\t\\t}\\n\\t\\telse if (typeof contentHeightInput === 'function') { // exists and is a function\\n\\t\\t\\tthis.suggestedViewHeight = contentHeightInput();\\n\\t\\t}\\n\\t\\telse if (typeof heightInput === 'number') { // exists and not 'auto'\\n\\t\\t\\tthis.suggestedViewHeight = heightInput - this.queryToolbarsHeight();\\n\\t\\t}\\n\\t\\telse if (typeof heightInput === 'function') { // exists and is a function\\n\\t\\t\\tthis.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();\\n\\t\\t}\\n\\t\\telse if (heightInput === 'parent') { // set to height of parent element\\n\\t\\t\\tthis.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.suggestedViewHeight = Math.round(\\n\\t\\t\\t\\tthis.contentEl.width() /\\n\\t\\t\\t\\tMath.max(this.opt('aspectRatio'), .5)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t},\\n\\n\\n\\twindowResize: function(ev) {\\n\\t\\tif (\\n\\t\\t\\t!this.ignoreWindowResize &&\\n\\t\\t\\tev.target === window && // so we don't process jqui \\\"resize\\\" events that have bubbled up\\n\\t\\t\\tthis.view.renderRange // view has already been rendered\\n\\t\\t) {\\n\\t\\t\\tif (this.updateSize(true)) {\\n\\t\\t\\t\\tthis.view.publiclyTrigger('windowResize', this.el[0]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Height \\\"Freezing\\\"\\n\\t-----------------------------------------------------------------------------*/\\n\\n\\n\\tfreezeContentHeight: function() {\\n\\t\\tthis.contentEl.css({\\n\\t\\t\\twidth: '100%',\\n\\t\\t\\theight: this.contentEl.height(),\\n\\t\\t\\toverflow: 'hidden'\\n\\t\\t});\\n\\t},\\n\\n\\n\\tthawContentHeight: function() {\\n\\t\\tthis.contentEl.css({\\n\\t\\t\\twidth: '',\\n\\t\\t\\theight: '',\\n\\t\\t\\toverflow: ''\\n\\t\\t});\\n\\t}\\n\\n});\\n\\n;;\\n\\nCalendar.mixin({\\n\\n\\theader: null,\\n\\tfooter: null,\\n\\ttoolbarsManager: null,\\n\\n\\n\\tinitToolbars: function() {\\n\\t\\tthis.header = new Toolbar(this, this.computeHeaderOptions());\\n\\t\\tthis.footer = new Toolbar(this, this.computeFooterOptions());\\n\\t\\tthis.toolbarsManager = new Iterator([ this.header, this.footer ]);\\n\\t},\\n\\n\\n\\tcomputeHeaderOptions: function() {\\n\\t\\treturn {\\n\\t\\t\\textraClasses: 'fc-header-toolbar',\\n\\t\\t\\tlayout: this.opt('header')\\n\\t\\t};\\n\\t},\\n\\n\\n\\tcomputeFooterOptions: function() {\\n\\t\\treturn {\\n\\t\\t\\textraClasses: 'fc-footer-toolbar',\\n\\t\\t\\tlayout: this.opt('footer')\\n\\t\\t};\\n\\t},\\n\\n\\n\\t// can be called repeatedly and Header will rerender\\n\\trenderHeader: function() {\\n\\t\\tvar header = this.header;\\n\\n\\t\\theader.setToolbarOptions(this.computeHeaderOptions());\\n\\t\\theader.render();\\n\\n\\t\\tif (header.el) {\\n\\t\\t\\tthis.el.prepend(header.el);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// can be called repeatedly and Footer will rerender\\n\\trenderFooter: function() {\\n\\t\\tvar footer = this.footer;\\n\\n\\t\\tfooter.setToolbarOptions(this.computeFooterOptions());\\n\\t\\tfooter.render();\\n\\n\\t\\tif (footer.el) {\\n\\t\\t\\tthis.el.append(footer.el);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tsetToolbarsTitle: function(title) {\\n\\t\\tthis.toolbarsManager.proxyCall('updateTitle', title);\\n\\t},\\n\\n\\n\\tupdateToolbarButtons: function() {\\n\\t\\tvar now = this.getNow();\\n\\t\\tvar view = this.view;\\n\\t\\tvar todayInfo = view.buildDateProfile(now);\\n\\t\\tvar prevInfo = view.buildPrevDateProfile(this.currentDate);\\n\\t\\tvar nextInfo = view.buildNextDateProfile(this.currentDate);\\n\\n\\t\\tthis.toolbarsManager.proxyCall(\\n\\t\\t\\t(todayInfo.isValid && !isDateWithinRange(now, view.currentRange)) ?\\n\\t\\t\\t\\t'enableButton' :\\n\\t\\t\\t\\t'disableButton',\\n\\t\\t\\t'today'\\n\\t\\t);\\n\\n\\t\\tthis.toolbarsManager.proxyCall(\\n\\t\\t\\tprevInfo.isValid ?\\n\\t\\t\\t\\t'enableButton' :\\n\\t\\t\\t\\t'disableButton',\\n\\t\\t\\t'prev'\\n\\t\\t);\\n\\n\\t\\tthis.toolbarsManager.proxyCall(\\n\\t\\t\\tnextInfo.isValid ?\\n\\t\\t\\t\\t'enableButton' :\\n\\t\\t\\t\\t'disableButton',\\n\\t\\t\\t'next'\\n\\t\\t);\\n\\t},\\n\\n\\n\\tqueryToolbarsHeight: function() {\\n\\t\\treturn this.toolbarsManager.items.reduce(function(accumulator, toolbar) {\\n\\t\\t\\tvar toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin\\n\\t\\t\\treturn accumulator + toolbarHeight;\\n\\t\\t}, 0);\\n\\t}\\n\\n});\\n\\n;;\\n\\nCalendar.defaults = {\\n\\n\\ttitleRangeSeparator: ' \\\\u2013 ', // en dash\\n\\tmonthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option\\n\\n\\tdefaultTimedEventDuration: '02:00:00',\\n\\tdefaultAllDayEventDuration: { days: 1 },\\n\\tforceEventDuration: false,\\n\\tnextDayThreshold: '09:00:00', // 9am\\n\\n\\t// display\\n\\tdefaultView: 'month',\\n\\taspectRatio: 1.35,\\n\\theader: {\\n\\t\\tleft: 'title',\\n\\t\\tcenter: '',\\n\\t\\tright: 'today prev,next'\\n\\t},\\n\\tweekends: true,\\n\\tweekNumbers: false,\\n\\n\\tweekNumberTitle: 'W',\\n\\tweekNumberCalculation: 'local',\\n\\t\\n\\t//editable: false,\\n\\n\\t//nowIndicator: false,\\n\\n\\tscrollTime: '06:00:00',\\n\\tminTime: '00:00:00',\\n\\tmaxTime: '24:00:00',\\n\\tshowNonCurrentDates: true,\\n\\t\\n\\t// event ajax\\n\\tlazyFetching: true,\\n\\tstartParam: 'start',\\n\\tendParam: 'end',\\n\\ttimezoneParam: 'timezone',\\n\\n\\ttimezone: false,\\n\\n\\t//allDayDefault: undefined,\\n\\n\\t// locale\\n\\tisRTL: false,\\n\\tbuttonText: {\\n\\t\\tprev: \\\"prev\\\",\\n\\t\\tnext: \\\"next\\\",\\n\\t\\tprevYear: \\\"prev year\\\",\\n\\t\\tnextYear: \\\"next year\\\",\\n\\t\\tyear: 'year', // TODO: locale files need to specify this\\n\\t\\ttoday: 'today',\\n\\t\\tmonth: 'month',\\n\\t\\tweek: 'week',\\n\\t\\tday: 'day'\\n\\t},\\n\\n\\tbuttonIcons: {\\n\\t\\tprev: 'left-single-arrow',\\n\\t\\tnext: 'right-single-arrow',\\n\\t\\tprevYear: 'left-double-arrow',\\n\\t\\tnextYear: 'right-double-arrow'\\n\\t},\\n\\n\\tallDayText: 'all-day',\\n\\t\\n\\t// jquery-ui theming\\n\\ttheme: false,\\n\\tthemeButtonIcons: {\\n\\t\\tprev: 'circle-triangle-w',\\n\\t\\tnext: 'circle-triangle-e',\\n\\t\\tprevYear: 'seek-prev',\\n\\t\\tnextYear: 'seek-next'\\n\\t},\\n\\n\\t//eventResizableFromStart: false,\\n\\tdragOpacity: .75,\\n\\tdragRevertDuration: 500,\\n\\tdragScroll: true,\\n\\t\\n\\t//selectable: false,\\n\\tunselectAuto: true,\\n\\t//selectMinDistance: 0,\\n\\t\\n\\tdropAccept: '*',\\n\\n\\teventOrder: 'title',\\n\\t//eventRenderWait: null,\\n\\n\\teventLimit: false,\\n\\teventLimitText: 'more',\\n\\teventLimitClick: 'popover',\\n\\tdayPopoverFormat: 'LL',\\n\\t\\n\\thandleWindowResize: true,\\n\\twindowResizeDelay: 100, // milliseconds before an updateSize happens\\n\\n\\tlongPressDelay: 1000\\n\\t\\n};\\n\\n\\nCalendar.englishDefaults = { // used by locale.js\\n\\tdayPopoverFormat: 'dddd, MMMM D'\\n};\\n\\n\\nCalendar.rtlDefaults = { // right-to-left defaults\\n\\theader: { // TODO: smarter solution (first/center/last ?)\\n\\t\\tleft: 'next,prev today',\\n\\t\\tcenter: '',\\n\\t\\tright: 'title'\\n\\t},\\n\\tbuttonIcons: {\\n\\t\\tprev: 'right-single-arrow',\\n\\t\\tnext: 'left-single-arrow',\\n\\t\\tprevYear: 'right-double-arrow',\\n\\t\\tnextYear: 'left-double-arrow'\\n\\t},\\n\\tthemeButtonIcons: {\\n\\t\\tprev: 'circle-triangle-e',\\n\\t\\tnext: 'circle-triangle-w',\\n\\t\\tnextYear: 'seek-prev',\\n\\t\\tprevYear: 'seek-next'\\n\\t}\\n};\\n\\n;;\\n\\nvar localeOptionHash = FC.locales = {}; // initialize and expose\\n\\n\\n// TODO: document the structure and ordering of a FullCalendar locale file\\n\\n\\n// Initialize jQuery UI datepicker translations while using some of the translations\\n// Will set this as the default locales for datepicker.\\nFC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {\\n\\n\\t// get the FullCalendar internal option hash for this locale. create if necessary\\n\\tvar fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\\n\\n\\t// transfer some simple options from datepicker to fc\\n\\tfcOptions.isRTL = dpOptions.isRTL;\\n\\tfcOptions.weekNumberTitle = dpOptions.weekHeader;\\n\\n\\t// compute some more complex options from datepicker\\n\\t$.each(dpComputableOptions, function(name, func) {\\n\\t\\tfcOptions[name] = func(dpOptions);\\n\\t});\\n\\n\\t// is jQuery UI Datepicker is on the page?\\n\\tif ($.datepicker) {\\n\\n\\t\\t// Register the locale data.\\n\\t\\t// FullCalendar and MomentJS use locale codes like \\\"pt-br\\\" but Datepicker\\n\\t\\t// does it like \\\"pt-BR\\\" or if it doesn't have the locale, maybe just \\\"pt\\\".\\n\\t\\t// Make an alias so the locale can be referenced either way.\\n\\t\\t$.datepicker.regional[dpLocaleCode] =\\n\\t\\t\\t$.datepicker.regional[localeCode] = // alias\\n\\t\\t\\t\\tdpOptions;\\n\\n\\t\\t// Alias 'en' to the default locale data. Do this every time.\\n\\t\\t$.datepicker.regional.en = $.datepicker.regional[''];\\n\\n\\t\\t// Set as Datepicker's global defaults.\\n\\t\\t$.datepicker.setDefaults(dpOptions);\\n\\t}\\n};\\n\\n\\n// Sets FullCalendar-specific translations. Will set the locales as the global default.\\nFC.locale = function(localeCode, newFcOptions) {\\n\\tvar fcOptions;\\n\\tvar momOptions;\\n\\n\\t// get the FullCalendar internal option hash for this locale. create if necessary\\n\\tfcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\\n\\n\\t// provided new options for this locales? merge them in\\n\\tif (newFcOptions) {\\n\\t\\tfcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);\\n\\t}\\n\\n\\t// compute locale options that weren't defined.\\n\\t// always do this. newFcOptions can be undefined when initializing from i18n file,\\n\\t// so no way to tell if this is an initialization or a default-setting.\\n\\tmomOptions = getMomentLocaleData(localeCode); // will fall back to en\\n\\t$.each(momComputableOptions, function(name, func) {\\n\\t\\tif (fcOptions[name] == null) {\\n\\t\\t\\tfcOptions[name] = func(momOptions, fcOptions);\\n\\t\\t}\\n\\t});\\n\\n\\t// set it as the default locale for FullCalendar\\n\\tCalendar.defaults.locale = localeCode;\\n};\\n\\n\\n// NOTE: can't guarantee any of these computations will run because not every locale has datepicker\\n// configs, so make sure there are English fallbacks for these in the defaults file.\\nvar dpComputableOptions = {\\n\\n\\tbuttonText: function(dpOptions) {\\n\\t\\treturn {\\n\\t\\t\\t// the translations sometimes wrongly contain HTML entities\\n\\t\\t\\tprev: stripHtmlEntities(dpOptions.prevText),\\n\\t\\t\\tnext: stripHtmlEntities(dpOptions.nextText),\\n\\t\\t\\ttoday: stripHtmlEntities(dpOptions.currentText)\\n\\t\\t};\\n\\t},\\n\\n\\t// Produces format strings like \\\"MMMM YYYY\\\" -> \\\"September 2014\\\"\\n\\tmonthYearFormat: function(dpOptions) {\\n\\t\\treturn dpOptions.showMonthAfterYear ?\\n\\t\\t\\t'YYYY[' + dpOptions.yearSuffix + '] MMMM' :\\n\\t\\t\\t'MMMM YYYY[' + dpOptions.yearSuffix + ']';\\n\\t}\\n\\n};\\n\\nvar momComputableOptions = {\\n\\n\\t// Produces format strings like \\\"ddd M/D\\\" -> \\\"Fri 9/15\\\"\\n\\tdayOfMonthFormat: function(momOptions, fcOptions) {\\n\\t\\tvar format = momOptions.longDateFormat('l'); // for the format like \\\"M/D/YYYY\\\"\\n\\n\\t\\t// strip the year off the edge, as well as other misc non-whitespace chars\\n\\t\\tformat = format.replace(/^Y+[^\\\\w\\\\s]*|[^\\\\w\\\\s]*Y+$/g, '');\\n\\n\\t\\tif (fcOptions.isRTL) {\\n\\t\\t\\tformat += ' ddd'; // for RTL, add day-of-week to end\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tformat = 'ddd ' + format; // for LTR, add day-of-week to beginning\\n\\t\\t}\\n\\t\\treturn format;\\n\\t},\\n\\n\\t// Produces format strings like \\\"h:mma\\\" -> \\\"6:00pm\\\"\\n\\tmediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option\\n\\t\\treturn momOptions.longDateFormat('LT')\\n\\t\\t\\t.replace(/\\\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\\n\\t},\\n\\n\\t// Produces format strings like \\\"h(:mm)a\\\" -> \\\"6pm\\\" / \\\"6:30pm\\\"\\n\\tsmallTimeFormat: function(momOptions) {\\n\\t\\treturn momOptions.longDateFormat('LT')\\n\\t\\t\\t.replace(':mm', '(:mm)')\\n\\t\\t\\t.replace(/(\\\\Wmm)$/, '($1)') // like above, but for foreign locales\\n\\t\\t\\t.replace(/\\\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\\n\\t},\\n\\n\\t// Produces format strings like \\\"h(:mm)t\\\" -> \\\"6p\\\" / \\\"6:30p\\\"\\n\\textraSmallTimeFormat: function(momOptions) {\\n\\t\\treturn momOptions.longDateFormat('LT')\\n\\t\\t\\t.replace(':mm', '(:mm)')\\n\\t\\t\\t.replace(/(\\\\Wmm)$/, '($1)') // like above, but for foreign locales\\n\\t\\t\\t.replace(/\\\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\\n\\t},\\n\\n\\t// Produces format strings like \\\"ha\\\" / \\\"H\\\" -> \\\"6pm\\\" / \\\"18\\\"\\n\\thourFormat: function(momOptions) {\\n\\t\\treturn momOptions.longDateFormat('LT')\\n\\t\\t\\t.replace(':mm', '')\\n\\t\\t\\t.replace(/(\\\\Wmm)$/, '') // like above, but for foreign locales\\n\\t\\t\\t.replace(/\\\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\\n\\t},\\n\\n\\t// Produces format strings like \\\"h:mm\\\" -> \\\"6:30\\\" (with no AM/PM)\\n\\tnoMeridiemTimeFormat: function(momOptions) {\\n\\t\\treturn momOptions.longDateFormat('LT')\\n\\t\\t\\t.replace(/\\\\s*a$/i, ''); // remove trailing AM/PM\\n\\t}\\n\\n};\\n\\n\\n// options that should be computed off live calendar options (considers override options)\\n// TODO: best place for this? related to locale?\\n// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\\nvar instanceComputableOptions = {\\n\\n\\t// Produces format strings for results like \\\"Mo 16\\\"\\n\\tsmallDayDateFormat: function(options) {\\n\\t\\treturn options.isRTL ?\\n\\t\\t\\t'D dd' :\\n\\t\\t\\t'dd D';\\n\\t},\\n\\n\\t// Produces format strings for results like \\\"Wk 5\\\"\\n\\tweekFormat: function(options) {\\n\\t\\treturn options.isRTL ?\\n\\t\\t\\t'w[ ' + options.weekNumberTitle + ']' :\\n\\t\\t\\t'[' + options.weekNumberTitle + ' ]w';\\n\\t},\\n\\n\\t// Produces format strings for results like \\\"Wk5\\\"\\n\\tsmallWeekFormat: function(options) {\\n\\t\\treturn options.isRTL ?\\n\\t\\t\\t'w[' + options.weekNumberTitle + ']' :\\n\\t\\t\\t'[' + options.weekNumberTitle + ']w';\\n\\t}\\n\\n};\\n\\n// TODO: make these computable properties in optionsModel\\nfunction populateInstanceComputableOptions(options) {\\n\\t$.each(instanceComputableOptions, function(name, func) {\\n\\t\\tif (options[name] == null) {\\n\\t\\t\\toptions[name] = func(options);\\n\\t\\t}\\n\\t});\\n}\\n\\n\\n// Returns moment's internal locale data. If doesn't exist, returns English.\\nfunction getMomentLocaleData(localeCode) {\\n\\treturn moment.localeData(localeCode) || moment.localeData('en');\\n}\\n\\n\\n// Initialize English by forcing computation of moment-derived options.\\n// Also, sets it as the default.\\nFC.locale('en', Calendar.englishDefaults);\\n\\n;;\\n\\nFC.sourceNormalizers = [];\\nFC.sourceFetchers = [];\\n\\nvar ajaxDefaults = {\\n\\tdataType: 'json',\\n\\tcache: false\\n};\\n\\nvar eventGUID = 1;\\n\\n\\nfunction EventManager() { // assumed to be a calendar\\n\\tvar t = this;\\n\\n\\n\\t// exports\\n\\tt.requestEvents = requestEvents;\\n\\tt.reportEventChange = reportEventChange;\\n\\tt.isFetchNeeded = isFetchNeeded;\\n\\tt.fetchEvents = fetchEvents;\\n\\tt.fetchEventSources = fetchEventSources;\\n\\tt.refetchEvents = refetchEvents;\\n\\tt.refetchEventSources = refetchEventSources;\\n\\tt.getEventSources = getEventSources;\\n\\tt.getEventSourceById = getEventSourceById;\\n\\tt.addEventSource = addEventSource;\\n\\tt.removeEventSource = removeEventSource;\\n\\tt.removeEventSources = removeEventSources;\\n\\tt.updateEvent = updateEvent;\\n\\tt.updateEvents = updateEvents;\\n\\tt.renderEvent = renderEvent;\\n\\tt.renderEvents = renderEvents;\\n\\tt.removeEvents = removeEvents;\\n\\tt.clientEvents = clientEvents;\\n\\tt.mutateEvent = mutateEvent;\\n\\tt.normalizeEventDates = normalizeEventDates;\\n\\tt.normalizeEventTimes = normalizeEventTimes;\\n\\n\\n\\t// locals\\n\\tvar stickySource = { events: [] };\\n\\tvar sources = [ stickySource ];\\n\\tvar rangeStart, rangeEnd;\\n\\tvar pendingSourceCnt = 0; // outstanding fetch requests, max one per source\\n\\tvar cache = []; // holds events that have already been expanded\\n\\tvar prunedCache; // like cache, but only events that intersect with rangeStart/rangeEnd\\n\\n\\n\\t$.each(\\n\\t\\t(t.opt('events') ? [ t.opt('events') ] : []).concat(t.opt('eventSources') || []),\\n\\t\\tfunction(i, sourceInput) {\\n\\t\\t\\tvar source = buildEventSource(sourceInput);\\n\\t\\t\\tif (source) {\\n\\t\\t\\t\\tsources.push(source);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n\\n\\n\\n\\tfunction requestEvents(start, end) {\\n\\t\\tif (!t.opt('lazyFetching') || isFetchNeeded(start, end)) {\\n\\t\\t\\treturn fetchEvents(start, end);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn Promise.resolve(prunedCache);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction reportEventChange() {\\n\\t\\tprunedCache = filterEventsWithinRange(cache);\\n\\t\\tt.trigger('eventsReset', prunedCache);\\n\\t}\\n\\n\\n\\tfunction filterEventsWithinRange(events) {\\n\\t\\tvar filteredEvents = [];\\n\\t\\tvar i, event;\\n\\n\\t\\tfor (i = 0; i < events.length; i++) {\\n\\t\\t\\tevent = events[i];\\n\\n\\t\\t\\tif (\\n\\t\\t\\t\\tevent.start.clone().stripZone() < rangeEnd &&\\n\\t\\t\\t\\tt.getEventEnd(event).stripZone() > rangeStart\\n\\t\\t\\t) {\\n\\t\\t\\t\\tfilteredEvents.push(event);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn filteredEvents;\\n\\t}\\n\\n\\n\\tt.getEventCache = function() {\\n\\t\\treturn cache;\\n\\t};\\n\\n\\n\\n\\t/* Fetching\\n\\t-----------------------------------------------------------------------------*/\\n\\n\\n\\t// start and end are assumed to be unzoned\\n\\tfunction isFetchNeeded(start, end) {\\n\\t\\treturn !rangeStart || // nothing has been fetched yet?\\n\\t\\t\\tstart < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?\\n\\t}\\n\\n\\n\\tfunction fetchEvents(start, end) {\\n\\t\\trangeStart = start;\\n\\t\\trangeEnd = end;\\n\\t\\treturn refetchEvents();\\n\\t}\\n\\n\\n\\t// poorly named. fetches all sources with current `rangeStart` and `rangeEnd`.\\n\\tfunction refetchEvents() {\\n\\t\\treturn fetchEventSources(sources, 'reset');\\n\\t}\\n\\n\\n\\t// poorly named. fetches a subset of event sources.\\n\\tfunction refetchEventSources(matchInputs) {\\n\\t\\treturn fetchEventSources(getEventSourcesByMatchArray(matchInputs));\\n\\t}\\n\\n\\n\\t// expects an array of event source objects (the originals, not copies)\\n\\t// `specialFetchType` is an optimization parameter that affects purging of the event cache.\\n\\tfunction fetchEventSources(specificSources, specialFetchType) {\\n\\t\\tvar i, source;\\n\\n\\t\\tif (specialFetchType === 'reset') {\\n\\t\\t\\tcache = [];\\n\\t\\t}\\n\\t\\telse if (specialFetchType !== 'add') {\\n\\t\\t\\tcache = excludeEventsBySources(cache, specificSources);\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < specificSources.length; i++) {\\n\\t\\t\\tsource = specificSources[i];\\n\\n\\t\\t\\t// already-pending sources have already been accounted for in pendingSourceCnt\\n\\t\\t\\tif (source._status !== 'pending') {\\n\\t\\t\\t\\tpendingSourceCnt++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsource._fetchId = (source._fetchId || 0) + 1;\\n\\t\\t\\tsource._status = 'pending';\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < specificSources.length; i++) {\\n\\t\\t\\tsource = specificSources[i];\\n\\t\\t\\ttryFetchEventSource(source, source._fetchId);\\n\\t\\t}\\n\\n\\t\\tif (pendingSourceCnt) {\\n\\t\\t\\treturn Promise.construct(function(resolve) {\\n\\t\\t\\t\\tt.one('eventsReceived', resolve); // will send prunedCache\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\telse { // executed all synchronously, or no sources at all\\n\\t\\t\\treturn Promise.resolve(prunedCache);\\n\\t\\t}\\n\\t}\\n\\n\\n\\t// fetches an event source and processes its result ONLY if it is still the current fetch.\\n\\t// caller is responsible for incrementing pendingSourceCnt first.\\n\\tfunction tryFetchEventSource(source, fetchId) {\\n\\t\\t_fetchEventSource(source, function(eventInputs) {\\n\\t\\t\\tvar isArraySource = $.isArray(source.events);\\n\\t\\t\\tvar i, eventInput;\\n\\t\\t\\tvar abstractEvent;\\n\\n\\t\\t\\tif (\\n\\t\\t\\t\\t// is this the source's most recent fetch?\\n\\t\\t\\t\\t// if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt\\n\\t\\t\\t\\tfetchId === source._fetchId &&\\n\\t\\t\\t\\t// event source no longer valid?\\n\\t\\t\\t\\tsource._status !== 'rejected'\\n\\t\\t\\t) {\\n\\t\\t\\t\\tsource._status = 'resolved';\\n\\n\\t\\t\\t\\tif (eventInputs) {\\n\\t\\t\\t\\t\\tfor (i = 0; i < eventInputs.length; i++) {\\n\\t\\t\\t\\t\\t\\teventInput = eventInputs[i];\\n\\n\\t\\t\\t\\t\\t\\tif (isArraySource) { // array sources have already been convert to Event Objects\\n\\t\\t\\t\\t\\t\\t\\tabstractEvent = eventInput;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tabstractEvent = buildEventFromInput(eventInput, source);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (abstractEvent) { // not false (an invalid event)\\n\\t\\t\\t\\t\\t\\t\\tcache.push.apply( // append\\n\\t\\t\\t\\t\\t\\t\\t\\tcache,\\n\\t\\t\\t\\t\\t\\t\\t\\texpandEvent(abstractEvent) // add individual expanded events to the cache\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdecrementPendingSourceCnt();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\n\\n\\tfunction rejectEventSource(source) {\\n\\t\\tvar wasPending = source._status === 'pending';\\n\\n\\t\\tsource._status = 'rejected';\\n\\n\\t\\tif (wasPending) {\\n\\t\\t\\tdecrementPendingSourceCnt();\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction decrementPendingSourceCnt() {\\n\\t\\tpendingSourceCnt--;\\n\\t\\tif (!pendingSourceCnt) {\\n\\t\\t\\treportEventChange(cache); // updates prunedCache\\n\\t\\t\\tt.trigger('eventsReceived', prunedCache);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction _fetchEventSource(source, callback) {\\n\\t\\tvar i;\\n\\t\\tvar fetchers = FC.sourceFetchers;\\n\\t\\tvar res;\\n\\n\\t\\tfor (i=0; i<fetchers.length; i++) {\\n\\t\\t\\tres = fetchers[i].call(\\n\\t\\t\\t\\tt, // this, the Calendar object\\n\\t\\t\\t\\tsource,\\n\\t\\t\\t\\trangeStart.clone(),\\n\\t\\t\\t\\trangeEnd.clone(),\\n\\t\\t\\t\\tt.opt('timezone'),\\n\\t\\t\\t\\tcallback\\n\\t\\t\\t);\\n\\n\\t\\t\\tif (res === true) {\\n\\t\\t\\t\\t// the fetcher is in charge. made its own async request\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse if (typeof res == 'object') {\\n\\t\\t\\t\\t// the fetcher returned a new source. process it\\n\\t\\t\\t\\t_fetchEventSource(res, callback);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar events = source.events;\\n\\t\\tif (events) {\\n\\t\\t\\tif ($.isFunction(events)) {\\n\\t\\t\\t\\tt.pushLoading();\\n\\t\\t\\t\\tevents.call(\\n\\t\\t\\t\\t\\tt, // this, the Calendar object\\n\\t\\t\\t\\t\\trangeStart.clone(),\\n\\t\\t\\t\\t\\trangeEnd.clone(),\\n\\t\\t\\t\\t\\tt.opt('timezone'),\\n\\t\\t\\t\\t\\tfunction(events) {\\n\\t\\t\\t\\t\\t\\tcallback(events);\\n\\t\\t\\t\\t\\t\\tt.popLoading();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\telse if ($.isArray(events)) {\\n\\t\\t\\t\\tcallback(events);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcallback();\\n\\t\\t\\t}\\n\\t\\t}else{\\n\\t\\t\\tvar url = source.url;\\n\\t\\t\\tif (url) {\\n\\t\\t\\t\\tvar success = source.success;\\n\\t\\t\\t\\tvar error = source.error;\\n\\t\\t\\t\\tvar complete = source.complete;\\n\\n\\t\\t\\t\\t// retrieve any outbound GET/POST $.ajax data from the options\\n\\t\\t\\t\\tvar customData;\\n\\t\\t\\t\\tif ($.isFunction(source.data)) {\\n\\t\\t\\t\\t\\t// supplied as a function that returns a key/value object\\n\\t\\t\\t\\t\\tcustomData = source.data();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t// supplied as a straight key/value object\\n\\t\\t\\t\\t\\tcustomData = source.data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// use a copy of the custom data so we can modify the parameters\\n\\t\\t\\t\\t// and not affect the passed-in object.\\n\\t\\t\\t\\tvar data = $.extend({}, customData || {});\\n\\n\\t\\t\\t\\tvar startParam = firstDefined(source.startParam, t.opt('startParam'));\\n\\t\\t\\t\\tvar endParam = firstDefined(source.endParam, t.opt('endParam'));\\n\\t\\t\\t\\tvar timezoneParam = firstDefined(source.timezoneParam, t.opt('timezoneParam'));\\n\\n\\t\\t\\t\\tif (startParam) {\\n\\t\\t\\t\\t\\tdata[startParam] = rangeStart.format();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (endParam) {\\n\\t\\t\\t\\t\\tdata[endParam] = rangeEnd.format();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (t.opt('timezone') && t.opt('timezone') != 'local') {\\n\\t\\t\\t\\t\\tdata[timezoneParam] = t.opt('timezone');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tt.pushLoading();\\n\\t\\t\\t\\t$.ajax($.extend({}, ajaxDefaults, source, {\\n\\t\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\t\\tsuccess: function(events) {\\n\\t\\t\\t\\t\\t\\tevents = events || [];\\n\\t\\t\\t\\t\\t\\tvar res = applyAll(success, this, arguments);\\n\\t\\t\\t\\t\\t\\tif ($.isArray(res)) {\\n\\t\\t\\t\\t\\t\\t\\tevents = res;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcallback(events);\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror: function() {\\n\\t\\t\\t\\t\\t\\tapplyAll(error, this, arguments);\\n\\t\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tcomplete: function() {\\n\\t\\t\\t\\t\\t\\tapplyAll(complete, this, arguments);\\n\\t\\t\\t\\t\\t\\tt.popLoading();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}));\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tcallback();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\n\\t/* Sources\\n\\t-----------------------------------------------------------------------------*/\\n\\n\\n\\tfunction addEventSource(sourceInput) {\\n\\t\\tvar source = buildEventSource(sourceInput);\\n\\t\\tif (source) {\\n\\t\\t\\tsources.push(source);\\n\\t\\t\\tfetchEventSources([ source ], 'add'); // will eventually call reportEventChange\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction buildEventSource(sourceInput) { // will return undefined if invalid source\\n\\t\\tvar normalizers = FC.sourceNormalizers;\\n\\t\\tvar source;\\n\\t\\tvar i;\\n\\n\\t\\tif ($.isFunction(sourceInput) || $.isArray(sourceInput)) {\\n\\t\\t\\tsource = { events: sourceInput };\\n\\t\\t}\\n\\t\\telse if (typeof sourceInput === 'string') {\\n\\t\\t\\tsource = { url: sourceInput };\\n\\t\\t}\\n\\t\\telse if (typeof sourceInput === 'object') {\\n\\t\\t\\tsource = $.extend({}, sourceInput); // shallow copy\\n\\t\\t}\\n\\n\\t\\tif (source) {\\n\\n\\t\\t\\t// TODO: repeat code, same code for event classNames\\n\\t\\t\\tif (source.className) {\\n\\t\\t\\t\\tif (typeof source.className === 'string') {\\n\\t\\t\\t\\t\\tsource.className = source.className.split(/\\\\s+/);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// otherwise, assumed to be an array\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tsource.className = [];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// for array sources, we convert to standard Event Objects up front\\n\\t\\t\\tif ($.isArray(source.events)) {\\n\\t\\t\\t\\tsource.origArray = source.events; // for removeEventSource\\n\\t\\t\\t\\tsource.events = $.map(source.events, function(eventInput) {\\n\\t\\t\\t\\t\\treturn buildEventFromInput(eventInput, source);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (i=0; i<normalizers.length; i++) {\\n\\t\\t\\t\\tnormalizers[i].call(t, source);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn source;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction removeEventSource(matchInput) {\\n\\t\\tremoveSpecificEventSources(\\n\\t\\t\\tgetEventSourcesByMatch(matchInput)\\n\\t\\t);\\n\\t}\\n\\n\\n\\t// if called with no arguments, removes all.\\n\\tfunction removeEventSources(matchInputs) {\\n\\t\\tif (matchInputs == null) {\\n\\t\\t\\tremoveSpecificEventSources(sources, true); // isAll=true\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tremoveSpecificEventSources(\\n\\t\\t\\t\\tgetEventSourcesByMatchArray(matchInputs)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction removeSpecificEventSources(targetSources, isAll) {\\n\\t\\tvar i;\\n\\n\\t\\t// cancel pending requests\\n\\t\\tfor (i = 0; i < targetSources.length; i++) {\\n\\t\\t\\trejectEventSource(targetSources[i]);\\n\\t\\t}\\n\\n\\t\\tif (isAll) { // an optimization\\n\\t\\t\\tsources = [];\\n\\t\\t\\tcache = [];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// remove from persisted source list\\n\\t\\t\\tsources = $.grep(sources, function(source) {\\n\\t\\t\\t\\tfor (i = 0; i < targetSources.length; i++) {\\n\\t\\t\\t\\t\\tif (source === targetSources[i]) {\\n\\t\\t\\t\\t\\t\\treturn false; // exclude\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true; // include\\n\\t\\t\\t});\\n\\n\\t\\t\\tcache = excludeEventsBySources(cache, targetSources);\\n\\t\\t}\\n\\n\\t\\treportEventChange();\\n\\t}\\n\\n\\n\\tfunction getEventSources() {\\n\\t\\treturn sources.slice(1); // returns a shallow copy of sources with stickySource removed\\n\\t}\\n\\n\\n\\tfunction getEventSourceById(id) {\\n\\t\\treturn $.grep(sources, function(source) {\\n\\t\\t\\treturn source.id && source.id === id;\\n\\t\\t})[0];\\n\\t}\\n\\n\\n\\t// like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)\\n\\tfunction getEventSourcesByMatchArray(matchInputs) {\\n\\n\\t\\t// coerce into an array\\n\\t\\tif (!matchInputs) {\\n\\t\\t\\tmatchInputs = [];\\n\\t\\t}\\n\\t\\telse if (!$.isArray(matchInputs)) {\\n\\t\\t\\tmatchInputs = [ matchInputs ];\\n\\t\\t}\\n\\n\\t\\tvar matchingSources = [];\\n\\t\\tvar i;\\n\\n\\t\\t// resolve raw inputs to real event source objects\\n\\t\\tfor (i = 0; i < matchInputs.length; i++) {\\n\\t\\t\\tmatchingSources.push.apply( // append\\n\\t\\t\\t\\tmatchingSources,\\n\\t\\t\\t\\tgetEventSourcesByMatch(matchInputs[i])\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn matchingSources;\\n\\t}\\n\\n\\n\\t// matchInput can either by a real event source object, an ID, or the function/URL for the source.\\n\\t// returns an array of matching source objects.\\n\\tfunction getEventSourcesByMatch(matchInput) {\\n\\t\\tvar i, source;\\n\\n\\t\\t// given an proper event source object\\n\\t\\tfor (i = 0; i < sources.length; i++) {\\n\\t\\t\\tsource = sources[i];\\n\\t\\t\\tif (source === matchInput) {\\n\\t\\t\\t\\treturn [ source ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// an ID match\\n\\t\\tsource = getEventSourceById(matchInput);\\n\\t\\tif (source) {\\n\\t\\t\\treturn [ source ];\\n\\t\\t}\\n\\n\\t\\treturn $.grep(sources, function(source) {\\n\\t\\t\\treturn isSourcesEquivalent(matchInput, source);\\n\\t\\t});\\n\\t}\\n\\n\\n\\tfunction isSourcesEquivalent(source1, source2) {\\n\\t\\treturn source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);\\n\\t}\\n\\n\\n\\tfunction getSourcePrimitive(source) {\\n\\t\\treturn (\\n\\t\\t\\t(typeof source === 'object') ? // a normalized event source?\\n\\t\\t\\t\\t(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive\\n\\t\\t\\t\\tnull\\n\\t\\t) ||\\n\\t\\tsource; // the given argument *is* the primitive\\n\\t}\\n\\n\\n\\t// util\\n\\t// returns a filtered array without events that are part of any of the given sources\\n\\tfunction excludeEventsBySources(specificEvents, specificSources) {\\n\\t\\treturn $.grep(specificEvents, function(event) {\\n\\t\\t\\tfor (var i = 0; i < specificSources.length; i++) {\\n\\t\\t\\t\\tif (event.source === specificSources[i]) {\\n\\t\\t\\t\\t\\treturn false; // exclude\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true; // keep\\n\\t\\t});\\n\\t}\\n\\n\\n\\n\\t/* Manipulation\\n\\t-----------------------------------------------------------------------------*/\\n\\n\\n\\t// Only ever called from the externally-facing API\\n\\tfunction updateEvent(event) {\\n\\t\\tupdateEvents([ event ]);\\n\\t}\\n\\n\\n\\t// Only ever called from the externally-facing API\\n\\tfunction updateEvents(events) {\\n\\t\\tvar i, event;\\n\\n\\t\\tfor (i = 0; i < events.length; i++) {\\n\\t\\t\\tevent = events[i];\\n\\n\\t\\t\\t// massage start/end values, even if date string values\\n\\t\\t\\tevent.start = t.moment(event.start);\\n\\t\\t\\tif (event.end) {\\n\\t\\t\\t\\tevent.end = t.moment(event.end);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tevent.end = null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization\\n\\t\\t}\\n\\n\\t\\treportEventChange(); // reports event modifications (so we can redraw)\\n\\t}\\n\\n\\n\\t// Returns a hash of misc event properties that should be copied over to related events.\\n\\tfunction getMiscEventProps(event) {\\n\\t\\tvar props = {};\\n\\n\\t\\t$.each(event, function(name, val) {\\n\\t\\t\\tif (isMiscEventPropName(name)) {\\n\\t\\t\\t\\tif (val !== undefined && isAtomic(val)) { // a defined non-object\\n\\t\\t\\t\\t\\tprops[name] = val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn props;\\n\\t}\\n\\n\\t// non-date-related, non-id-related, non-secret\\n\\tfunction isMiscEventPropName(name) {\\n\\t\\treturn !/^_|^(id|allDay|start|end)$/.test(name);\\n\\t}\\n\\n\\n\\t// returns the expanded events that were created\\n\\tfunction renderEvent(eventInput, stick) {\\n\\t\\treturn renderEvents([ eventInput ], stick);\\n\\t}\\n\\n\\n\\t// returns the expanded events that were created\\n\\tfunction renderEvents(eventInputs, stick) {\\n\\t\\tvar renderedEvents = [];\\n\\t\\tvar renderableEvents;\\n\\t\\tvar abstractEvent;\\n\\t\\tvar i, j, event;\\n\\n\\t\\tfor (i = 0; i < eventInputs.length; i++) {\\n\\t\\t\\tabstractEvent = buildEventFromInput(eventInputs[i]);\\n\\n\\t\\t\\tif (abstractEvent) { // not false (a valid input)\\n\\t\\t\\t\\trenderableEvents = expandEvent(abstractEvent);\\n\\n\\t\\t\\t\\tfor (j = 0; j < renderableEvents.length; j++) {\\n\\t\\t\\t\\t\\tevent = renderableEvents[j];\\n\\n\\t\\t\\t\\t\\tif (!event.source) {\\n\\t\\t\\t\\t\\t\\tif (stick) {\\n\\t\\t\\t\\t\\t\\t\\tstickySource.events.push(event);\\n\\t\\t\\t\\t\\t\\t\\tevent.source = stickySource;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcache.push(event);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\trenderedEvents = renderedEvents.concat(renderableEvents);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (renderedEvents.length) { // any new events rendered?\\n\\t\\t\\treportEventChange();\\n\\t\\t}\\n\\n\\t\\treturn renderedEvents;\\n\\t}\\n\\n\\n\\tfunction removeEvents(filter) {\\n\\t\\tvar eventID;\\n\\t\\tvar i;\\n\\n\\t\\tif (filter == null) { // null or undefined. remove all events\\n\\t\\t\\tfilter = function() { return true; }; // will always match\\n\\t\\t}\\n\\t\\telse if (!$.isFunction(filter)) { // an event ID\\n\\t\\t\\teventID = filter + '';\\n\\t\\t\\tfilter = function(event) {\\n\\t\\t\\t\\treturn event._id == eventID;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Purge event(s) from our local cache\\n\\t\\tcache = $.grep(cache, filter, true); // inverse=true\\n\\n\\t\\t// Remove events from array sources.\\n\\t\\t// This works because they have been converted to official Event Objects up front.\\n\\t\\t// (and as a result, event._id has been calculated).\\n\\t\\tfor (i=0; i<sources.length; i++) {\\n\\t\\t\\tif ($.isArray(sources[i].events)) {\\n\\t\\t\\t\\tsources[i].events = $.grep(sources[i].events, filter, true);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treportEventChange();\\n\\t}\\n\\n\\n\\tfunction clientEvents(filter) {\\n\\t\\tif ($.isFunction(filter)) {\\n\\t\\t\\treturn $.grep(cache, filter);\\n\\t\\t}\\n\\t\\telse if (filter != null) { // not null, not undefined. an event ID\\n\\t\\t\\tfilter += '';\\n\\t\\t\\treturn $.grep(cache, function(e) {\\n\\t\\t\\t\\treturn e._id == filter;\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\treturn cache; // else, return all\\n\\t}\\n\\n\\n\\t// Makes sure all array event sources have their internal event objects\\n\\t// converted over to the Calendar's current timezone.\\n\\tt.rezoneArrayEventSources = function() {\\n\\t\\tvar i;\\n\\t\\tvar events;\\n\\t\\tvar j;\\n\\n\\t\\tfor (i = 0; i < sources.length; i++) {\\n\\t\\t\\tevents = sources[i].events;\\n\\t\\t\\tif ($.isArray(events)) {\\n\\n\\t\\t\\t\\tfor (j = 0; j < events.length; j++) {\\n\\t\\t\\t\\t\\trezoneEventDates(events[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tfunction rezoneEventDates(event) {\\n\\t\\tevent.start = t.moment(event.start);\\n\\t\\tif (event.end) {\\n\\t\\t\\tevent.end = t.moment(event.end);\\n\\t\\t}\\n\\t\\tbackupEventDates(event);\\n\\t}\\n\\n\\n\\t/* Event Normalization\\n\\t-----------------------------------------------------------------------------*/\\n\\n\\n\\t// Given a raw object with key/value properties, returns an \\\"abstract\\\" Event object.\\n\\t// An \\\"abstract\\\" event is an event that, if recurring, will not have been expanded yet.\\n\\t// Will return `false` when input is invalid.\\n\\t// `source` is optional\\n\\tfunction buildEventFromInput(input, source) {\\n\\t\\tvar calendarEventDataTransform = t.opt('eventDataTransform');\\n\\t\\tvar out = {};\\n\\t\\tvar start, end;\\n\\t\\tvar allDay;\\n\\n\\t\\tif (calendarEventDataTransform) {\\n\\t\\t\\tinput = calendarEventDataTransform(input);\\n\\t\\t}\\n\\t\\tif (source && source.eventDataTransform) {\\n\\t\\t\\tinput = source.eventDataTransform(input);\\n\\t\\t}\\n\\n\\t\\t// Copy all properties over to the resulting object.\\n\\t\\t// The special-case properties will be copied over afterwards.\\n\\t\\t$.extend(out, input);\\n\\n\\t\\tif (source) {\\n\\t\\t\\tout.source = source;\\n\\t\\t}\\n\\n\\t\\tout._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');\\n\\n\\t\\tif (input.className) {\\n\\t\\t\\tif (typeof input.className == 'string') {\\n\\t\\t\\t\\tout.className = input.className.split(/\\\\s+/);\\n\\t\\t\\t}\\n\\t\\t\\telse { // assumed to be an array\\n\\t\\t\\t\\tout.className = input.className;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tout.className = [];\\n\\t\\t}\\n\\n\\t\\tstart = input.start || input.date; // \\\"date\\\" is an alias for \\\"start\\\"\\n\\t\\tend = input.end;\\n\\n\\t\\t// parse as a time (Duration) if applicable\\n\\t\\tif (isTimeString(start)) {\\n\\t\\t\\tstart = moment.duration(start);\\n\\t\\t}\\n\\t\\tif (isTimeString(end)) {\\n\\t\\t\\tend = moment.duration(end);\\n\\t\\t}\\n\\n\\t\\tif (input.dow || moment.isDuration(start) || moment.isDuration(end)) {\\n\\n\\t\\t\\t// the event is \\\"abstract\\\" (recurring) so don't calculate exact start/end dates just yet\\n\\t\\t\\tout.start = start ? moment.duration(start) : null; // will be a Duration or null\\n\\t\\t\\tout.end = end ? moment.duration(end) : null; // will be a Duration or null\\n\\t\\t\\tout._recurring = true; // our internal marker\\n\\t\\t}\\n\\t\\telse {\\n\\n\\t\\t\\tif (start) {\\n\\t\\t\\t\\tstart = t.moment(start);\\n\\t\\t\\t\\tif (!start.isValid()) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (end) {\\n\\t\\t\\t\\tend = t.moment(end);\\n\\t\\t\\t\\tif (!end.isValid()) {\\n\\t\\t\\t\\t\\tend = null; // let defaults take over\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tallDay = input.allDay;\\n\\t\\t\\tif (allDay === undefined) { // still undefined? fallback to default\\n\\t\\t\\t\\tallDay = firstDefined(\\n\\t\\t\\t\\t\\tsource ? source.allDayDefault : undefined,\\n\\t\\t\\t\\t\\tt.opt('allDayDefault')\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\t// still undefined? normalizeEventDates will calculate it\\n\\t\\t\\t}\\n\\n\\t\\t\\tassignDatesToEvent(start, end, allDay, out);\\n\\t\\t}\\n\\n\\t\\tt.normalizeEvent(out); // hook for external use. a prototype method\\n\\n\\t\\treturn out;\\n\\t}\\n\\tt.buildEventFromInput = buildEventFromInput;\\n\\n\\n\\t// Normalizes and assigns the given dates to the given partially-formed event object.\\n\\t// NOTE: mutates the given start/end moments. does not make a copy.\\n\\tfunction assignDatesToEvent(start, end, allDay, event) {\\n\\t\\tevent.start = start;\\n\\t\\tevent.end = end;\\n\\t\\tevent.allDay = allDay;\\n\\t\\tnormalizeEventDates(event);\\n\\t\\tbackupEventDates(event);\\n\\t}\\n\\n\\n\\t// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.\\n\\t// NOTE: Will modify the given object.\\n\\tfunction normalizeEventDates(eventProps) {\\n\\n\\t\\tnormalizeEventTimes(eventProps);\\n\\n\\t\\tif (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {\\n\\t\\t\\teventProps.end = null;\\n\\t\\t}\\n\\n\\t\\tif (!eventProps.end) {\\n\\t\\t\\tif (t.opt('forceEventDuration')) {\\n\\t\\t\\t\\teventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\teventProps.end = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\t// Ensures the allDay property exists and the timeliness of the start/end dates are consistent\\n\\tfunction normalizeEventTimes(eventProps) {\\n\\t\\tif (eventProps.allDay == null) {\\n\\t\\t\\teventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));\\n\\t\\t}\\n\\n\\t\\tif (eventProps.allDay) {\\n\\t\\t\\teventProps.start.stripTime();\\n\\t\\t\\tif (eventProps.end) {\\n\\t\\t\\t\\t// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment\\n\\t\\t\\t\\teventProps.end.stripTime();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (!eventProps.start.hasTime()) {\\n\\t\\t\\t\\teventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time\\n\\t\\t\\t}\\n\\t\\t\\tif (eventProps.end && !eventProps.end.hasTime()) {\\n\\t\\t\\t\\teventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n\\t// If the given event is a recurring event, break it down into an array of individual instances.\\n\\t// If not a recurring event, return an array with the single original event.\\n\\t// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.\\n\\t// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).\\n\\tfunction expandEvent(abstractEvent, _rangeStart, _rangeEnd) {\\n\\t\\tvar events = [];\\n\\t\\tvar dowHash;\\n\\t\\tvar dow;\\n\\t\\tvar i;\\n\\t\\tvar date;\\n\\t\\tvar startTime, endTime;\\n\\t\\tvar start, end;\\n\\t\\tvar event;\\n\\n\\t\\t_rangeStart = _rangeStart || rangeStart;\\n\\t\\t_rangeEnd = _rangeEnd || rangeEnd;\\n\\n\\t\\tif (abstractEvent) {\\n\\t\\t\\tif (abstractEvent._recurring) {\\n\\n\\t\\t\\t\\t// make a boolean hash as to whether the event occurs on each day-of-week\\n\\t\\t\\t\\tif ((dow = abstractEvent.dow)) {\\n\\t\\t\\t\\t\\tdowHash = {};\\n\\t\\t\\t\\t\\tfor (i = 0; i < dow.length; i++) {\\n\\t\\t\\t\\t\\t\\tdowHash[dow[i]] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// iterate through every day in the current range\\n\\t\\t\\t\\tdate = _rangeStart.clone().stripTime(); // holds the date of the current day\\n\\t\\t\\t\\twhile (date.isBefore(_rangeEnd)) {\\n\\n\\t\\t\\t\\t\\tif (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week\\n\\n\\t\\t\\t\\t\\t\\tstartTime = abstractEvent.start; // the stored start and end properties are times (Durations)\\n\\t\\t\\t\\t\\t\\tendTime = abstractEvent.end; // \\\"\\n\\t\\t\\t\\t\\t\\tstart = date.clone();\\n\\t\\t\\t\\t\\t\\tend = null;\\n\\n\\t\\t\\t\\t\\t\\tif (startTime) {\\n\\t\\t\\t\\t\\t\\t\\tstart = start.time(startTime);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (endTime) {\\n\\t\\t\\t\\t\\t\\t\\tend = date.clone().time(endTime);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tevent = $.extend({}, abstractEvent); // make a copy of the original\\n\\t\\t\\t\\t\\t\\tassignDatesToEvent(\\n\\t\\t\\t\\t\\t\\t\\tstart, end,\\n\\t\\t\\t\\t\\t\\t\\t!startTime && !endTime, // allDay?\\n\\t\\t\\t\\t\\t\\t\\tevent\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\tevents.push(event);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdate.add(1, 'days');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tevents.push(abstractEvent); // return the original event. will be a one-item array\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn events;\\n\\t}\\n\\tt.expandEvent = expandEvent;\\n\\n\\n\\n\\t/* Event Modification Math\\n\\t-----------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Modifies an event and all related events by applying the given properties.\\n\\t// Special date-diffing logic is used for manipulation of dates.\\n\\t// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.\\n\\t// All date comparisons are done against the event's pristine _start and _end dates.\\n\\t// Returns an object with delta information and a function to undo all operations.\\n\\t// For making computations in a granularity greater than day/time, specify largeUnit.\\n\\t// NOTE: The given `newProps` might be mutated for normalization purposes.\\n\\tfunction mutateEvent(event, newProps, largeUnit) {\\n\\t\\tvar miscProps = {};\\n\\t\\tvar oldProps;\\n\\t\\tvar clearEnd;\\n\\t\\tvar startDelta;\\n\\t\\tvar endDelta;\\n\\t\\tvar durationDelta;\\n\\t\\tvar undoFunc;\\n\\n\\t\\t// diffs the dates in the appropriate way, returning a duration\\n\\t\\tfunction diffDates(date1, date0) { // date1 - date0\\n\\t\\t\\tif (largeUnit) {\\n\\t\\t\\t\\treturn diffByUnit(date1, date0, largeUnit);\\n\\t\\t\\t}\\n\\t\\t\\telse if (newProps.allDay) {\\n\\t\\t\\t\\treturn diffDay(date1, date0);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn diffDayTime(date1, date0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tnewProps = newProps || {};\\n\\n\\t\\t// normalize new date-related properties\\n\\t\\tif (!newProps.start) {\\n\\t\\t\\tnewProps.start = event.start.clone();\\n\\t\\t}\\n\\t\\tif (newProps.end === undefined) {\\n\\t\\t\\tnewProps.end = event.end ? event.end.clone() : null;\\n\\t\\t}\\n\\t\\tif (newProps.allDay == null) { // is null or undefined?\\n\\t\\t\\tnewProps.allDay = event.allDay;\\n\\t\\t}\\n\\t\\tnormalizeEventDates(newProps);\\n\\n\\t\\t// create normalized versions of the original props to compare against\\n\\t\\t// need a real end value, for diffing\\n\\t\\toldProps = {\\n\\t\\t\\tstart: event._start.clone(),\\n\\t\\t\\tend: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),\\n\\t\\t\\tallDay: newProps.allDay // normalize the dates in the same regard as the new properties\\n\\t\\t};\\n\\t\\tnormalizeEventDates(oldProps);\\n\\n\\t\\t// need to clear the end date if explicitly changed to null\\n\\t\\tclearEnd = event._end !== null && newProps.end === null;\\n\\n\\t\\t// compute the delta for moving the start date\\n\\t\\tstartDelta = diffDates(newProps.start, oldProps.start);\\n\\n\\t\\t// compute the delta for moving the end date\\n\\t\\tif (newProps.end) {\\n\\t\\t\\tendDelta = diffDates(newProps.end, oldProps.end);\\n\\t\\t\\tdurationDelta = endDelta.subtract(startDelta);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdurationDelta = null;\\n\\t\\t}\\n\\n\\t\\t// gather all non-date-related properties\\n\\t\\t$.each(newProps, function(name, val) {\\n\\t\\t\\tif (isMiscEventPropName(name)) {\\n\\t\\t\\t\\tif (val !== undefined) {\\n\\t\\t\\t\\t\\tmiscProps[name] = val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// apply the operations to the event and all related events\\n\\t\\tundoFunc = mutateEvents(\\n\\t\\t\\tclientEvents(event._id), // get events with this ID\\n\\t\\t\\tclearEnd,\\n\\t\\t\\tnewProps.allDay,\\n\\t\\t\\tstartDelta,\\n\\t\\t\\tdurationDelta,\\n\\t\\t\\tmiscProps\\n\\t\\t);\\n\\n\\t\\treturn {\\n\\t\\t\\tdateDelta: startDelta,\\n\\t\\t\\tdurationDelta: durationDelta,\\n\\t\\t\\tundo: undoFunc\\n\\t\\t};\\n\\t}\\n\\n\\n\\t// Modifies an array of events in the following ways (operations are in order):\\n\\t// - clear the event's `end`\\n\\t// - convert the event to allDay\\n\\t// - add `dateDelta` to the start and end\\n\\t// - add `durationDelta` to the event's duration\\n\\t// - assign `miscProps` to the event\\n\\t//\\n\\t// Returns a function that can be called to undo all the operations.\\n\\t//\\n\\t// TODO: don't use so many closures. possible memory issues when lots of events with same ID.\\n\\t//\\n\\tfunction mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {\\n\\t\\tvar isAmbigTimezone = t.getIsAmbigTimezone();\\n\\t\\tvar undoFunctions = [];\\n\\n\\t\\t// normalize zero-length deltas to be null\\n\\t\\tif (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }\\n\\t\\tif (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }\\n\\n\\t\\t$.each(events, function(i, event) {\\n\\t\\t\\tvar oldProps;\\n\\t\\t\\tvar newProps;\\n\\n\\t\\t\\t// build an object holding all the old values, both date-related and misc.\\n\\t\\t\\t// for the undo function.\\n\\t\\t\\toldProps = {\\n\\t\\t\\t\\tstart: event.start.clone(),\\n\\t\\t\\t\\tend: event.end ? event.end.clone() : null,\\n\\t\\t\\t\\tallDay: event.allDay\\n\\t\\t\\t};\\n\\t\\t\\t$.each(miscProps, function(name) {\\n\\t\\t\\t\\toldProps[name] = event[name];\\n\\t\\t\\t});\\n\\n\\t\\t\\t// new date-related properties. work off the original date snapshot.\\n\\t\\t\\t// ok to use references because they will be thrown away when backupEventDates is called.\\n\\t\\t\\tnewProps = {\\n\\t\\t\\t\\tstart: event._start,\\n\\t\\t\\t\\tend: event._end,\\n\\t\\t\\t\\tallDay: allDay // normalize the dates in the same regard as the new properties\\n\\t\\t\\t};\\n\\t\\t\\tnormalizeEventDates(newProps); // massages start/end/allDay\\n\\n\\t\\t\\t// strip or ensure the end date\\n\\t\\t\\tif (clearEnd) {\\n\\t\\t\\t\\tnewProps.end = null;\\n\\t\\t\\t}\\n\\t\\t\\telse if (durationDelta && !newProps.end) { // the duration translation requires an end date\\n\\t\\t\\t\\tnewProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (dateDelta) {\\n\\t\\t\\t\\tnewProps.start.add(dateDelta);\\n\\t\\t\\t\\tif (newProps.end) {\\n\\t\\t\\t\\t\\tnewProps.end.add(dateDelta);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (durationDelta) {\\n\\t\\t\\t\\tnewProps.end.add(durationDelta); // end already ensured above\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the dates have changed, and we know it is impossible to recompute the\\n\\t\\t\\t// timezone offsets, strip the zone.\\n\\t\\t\\tif (\\n\\t\\t\\t\\tisAmbigTimezone &&\\n\\t\\t\\t\\t!newProps.allDay &&\\n\\t\\t\\t\\t(dateDelta || durationDelta)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tnewProps.start.stripZone();\\n\\t\\t\\t\\tif (newProps.end) {\\n\\t\\t\\t\\t\\tnewProps.end.stripZone();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$.extend(event, miscProps, newProps); // copy over misc props, then date-related props\\n\\t\\t\\tbackupEventDates(event); // regenerate internal _start/_end/_allDay\\n\\n\\t\\t\\tundoFunctions.push(function() {\\n\\t\\t\\t\\t$.extend(event, oldProps);\\n\\t\\t\\t\\tbackupEventDates(event); // regenerate internal _start/_end/_allDay\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn function() {\\n\\t\\t\\tfor (var i = 0; i < undoFunctions.length; i++) {\\n\\t\\t\\t\\tundoFunctions[i]();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n}\\n\\n\\n// returns an undo function\\nCalendar.prototype.mutateSeg = function(seg, newProps) {\\n\\treturn this.mutateEvent(seg.event, newProps);\\n};\\n\\n\\n// hook for external libs to manipulate event properties upon creation.\\n// should manipulate the event in-place.\\nCalendar.prototype.normalizeEvent = function(event) {\\n};\\n\\n\\n// Does the given span (start, end, and other location information)\\n// fully contain the other?\\nCalendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {\\n\\tvar eventStart = outerSpan.start.clone().stripZone();\\n\\tvar eventEnd = this.getEventEnd(outerSpan).stripZone();\\n\\n\\treturn innerSpan.start >= eventStart && innerSpan.end <= eventEnd;\\n};\\n\\n\\n// Returns a list of events that the given event should be compared against when being considered for a move to\\n// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.\\nCalendar.prototype.getPeerEvents = function(span, event) {\\n\\tvar cache = this.getEventCache();\\n\\tvar peerEvents = [];\\n\\tvar i, otherEvent;\\n\\n\\tfor (i = 0; i < cache.length; i++) {\\n\\t\\totherEvent = cache[i];\\n\\t\\tif (\\n\\t\\t\\t!event ||\\n\\t\\t\\tevent._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events\\n\\t\\t) {\\n\\t\\t\\tpeerEvents.push(otherEvent);\\n\\t\\t}\\n\\t}\\n\\n\\treturn peerEvents;\\n};\\n\\n\\n// updates the \\\"backup\\\" properties, which are preserved in order to compute diffs later on.\\nfunction backupEventDates(event) {\\n\\tevent._allDay = event.allDay;\\n\\tevent._start = event.start.clone();\\n\\tevent._end = event.end ? event.end.clone() : null;\\n}\\n\\n\\n/* Overlapping / Constraining\\n-----------------------------------------------------------------------------------------*/\\n\\n\\n// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)\\nCalendar.prototype.isEventSpanAllowed = function(span, event) {\\n\\tvar source = event.source || {};\\n\\tvar eventAllowFunc = this.opt('eventAllow');\\n\\n\\tvar constraint = firstDefined(\\n\\t\\tevent.constraint,\\n\\t\\tsource.constraint,\\n\\t\\tthis.opt('eventConstraint')\\n\\t);\\n\\n\\tvar overlap = firstDefined(\\n\\t\\tevent.overlap,\\n\\t\\tsource.overlap,\\n\\t\\tthis.opt('eventOverlap')\\n\\t);\\n\\n\\treturn this.isSpanAllowed(span, constraint, overlap, event) &&\\n\\t\\t(!eventAllowFunc || eventAllowFunc(span, event) !== false);\\n};\\n\\n\\n// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)\\nCalendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {\\n\\tvar eventInput;\\n\\tvar event;\\n\\n\\t// note: very similar logic is in View's reportExternalDrop\\n\\tif (eventProps) {\\n\\t\\teventInput = $.extend({}, eventProps, eventLocation);\\n\\t\\tevent = this.expandEvent(\\n\\t\\t\\tthis.buildEventFromInput(eventInput)\\n\\t\\t)[0];\\n\\t}\\n\\n\\tif (event) {\\n\\t\\treturn this.isEventSpanAllowed(eventSpan, event);\\n\\t}\\n\\telse { // treat it as a selection\\n\\n\\t\\treturn this.isSelectionSpanAllowed(eventSpan);\\n\\t}\\n};\\n\\n\\n// Determines the given span (unzoned start/end with other misc data) can be selected.\\nCalendar.prototype.isSelectionSpanAllowed = function(span) {\\n\\tvar selectAllowFunc = this.opt('selectAllow');\\n\\n\\treturn this.isSpanAllowed(span, this.opt('selectConstraint'), this.opt('selectOverlap')) &&\\n\\t\\t(!selectAllowFunc || selectAllowFunc(span) !== false);\\n};\\n\\n\\n// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist\\n// according to the constraint/overlap settings.\\n// `event` is not required if checking a selection.\\nCalendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {\\n\\tvar constraintEvents;\\n\\tvar anyContainment;\\n\\tvar peerEvents;\\n\\tvar i, peerEvent;\\n\\tvar peerOverlap;\\n\\n\\t// the range must be fully contained by at least one of produced constraint events\\n\\tif (constraint != null) {\\n\\n\\t\\t// not treated as an event! intermediate data structure\\n\\t\\t// TODO: use ranges in the future\\n\\t\\tconstraintEvents = this.constraintToEvents(constraint);\\n\\t\\tif (constraintEvents) { // not invalid\\n\\n\\t\\t\\tanyContainment = false;\\n\\t\\t\\tfor (i = 0; i < constraintEvents.length; i++) {\\n\\t\\t\\t\\tif (this.spanContainsSpan(constraintEvents[i], span)) {\\n\\t\\t\\t\\t\\tanyContainment = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!anyContainment) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpeerEvents = this.getPeerEvents(span, event);\\n\\n\\tfor (i = 0; i < peerEvents.length; i++)  {\\n\\t\\tpeerEvent = peerEvents[i];\\n\\n\\t\\t// there needs to be an actual intersection before disallowing anything\\n\\t\\tif (this.eventIntersectsRange(peerEvent, span)) {\\n\\n\\t\\t\\t// evaluate overlap for the given range and short-circuit if necessary\\n\\t\\t\\tif (overlap === false) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t// if the event's overlap is a test function, pass the peer event in question as the first param\\n\\t\\t\\telse if (typeof overlap === 'function' && !overlap(peerEvent, event)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if we are computing if the given range is allowable for an event, consider the other event's\\n\\t\\t\\t// EventObject-specific or Source-specific `overlap` property\\n\\t\\t\\tif (event) {\\n\\t\\t\\t\\tpeerOverlap = firstDefined(\\n\\t\\t\\t\\t\\tpeerEvent.overlap,\\n\\t\\t\\t\\t\\t(peerEvent.source || {}).overlap\\n\\t\\t\\t\\t\\t// we already considered the global `eventOverlap`\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tif (peerOverlap === false) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if the peer event's overlap is a test function, pass the subject event as the first param\\n\\t\\t\\t\\tif (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n};\\n\\n\\n// Given an event input from the API, produces an array of event objects. Possible event inputs:\\n// 'businessHours'\\n// An event ID (number or string)\\n// An object with specific start/end dates or a recurring event (like what businessHours accepts)\\nCalendar.prototype.constraintToEvents = function(constraintInput) {\\n\\n\\tif (constraintInput === 'businessHours') {\\n\\t\\treturn this.getCurrentBusinessHourEvents();\\n\\t}\\n\\n\\tif (typeof constraintInput === 'object') {\\n\\t\\tif (constraintInput.start != null) { // needs to be event-like input\\n\\t\\t\\treturn this.expandEvent(this.buildEventFromInput(constraintInput));\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn null; // invalid\\n\\t\\t}\\n\\t}\\n\\n\\treturn this.clientEvents(constraintInput); // probably an ID\\n};\\n\\n\\n// Does the event's date range intersect with the given range?\\n// start/end already assumed to have stripped zones :(\\nCalendar.prototype.eventIntersectsRange = function(event, range) {\\n\\tvar eventStart = event.start.clone().stripZone();\\n\\tvar eventEnd = this.getEventEnd(event).stripZone();\\n\\n\\treturn range.start < eventEnd && range.end > eventStart;\\n};\\n\\n\\n/* Business Hours\\n-----------------------------------------------------------------------------------------*/\\n\\nvar BUSINESS_HOUR_EVENT_DEFAULTS = {\\n\\tid: '_fcBusinessHours', // will relate events from different calls to expandEvent\\n\\tstart: '09:00',\\n\\tend: '17:00',\\n\\tdow: [ 1, 2, 3, 4, 5 ], // monday - friday\\n\\trendering: 'inverse-background'\\n\\t// classNames are defined in businessHoursSegClasses\\n};\\n\\n// Return events objects for business hours within the current view.\\n// Abuse of our event system :(\\nCalendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {\\n\\treturn this.computeBusinessHourEvents(wholeDay, this.opt('businessHours'));\\n};\\n\\n// Given a raw input value from options, return events objects for business hours within the current view.\\nCalendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {\\n\\tif (input === true) {\\n\\t\\treturn this.expandBusinessHourEvents(wholeDay, [ {} ]);\\n\\t}\\n\\telse if ($.isPlainObject(input)) {\\n\\t\\treturn this.expandBusinessHourEvents(wholeDay, [ input ]);\\n\\t}\\n\\telse if ($.isArray(input)) {\\n\\t\\treturn this.expandBusinessHourEvents(wholeDay, input, true);\\n\\t}\\n\\telse {\\n\\t\\treturn [];\\n\\t}\\n};\\n\\n// inputs expected to be an array of objects.\\n// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.\\nCalendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {\\n\\tvar view = this.getView();\\n\\tvar events = [];\\n\\tvar i, input;\\n\\n\\tfor (i = 0; i < inputs.length; i++) {\\n\\t\\tinput = inputs[i];\\n\\n\\t\\tif (ignoreNoDow && !input.dow) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// give defaults. will make a copy\\n\\t\\tinput = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);\\n\\n\\t\\t// if a whole-day series is requested, clear the start/end times\\n\\t\\tif (wholeDay) {\\n\\t\\t\\tinput.start = null;\\n\\t\\t\\tinput.end = null;\\n\\t\\t}\\n\\n\\t\\tevents.push.apply(events, // append\\n\\t\\t\\tthis.expandEvent(\\n\\t\\t\\t\\tthis.buildEventFromInput(input),\\n\\t\\t\\t\\tview.activeRange.start,\\n\\t\\t\\t\\tview.activeRange.end\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\treturn events;\\n};\\n\\n;;\\n\\n/* An abstract class for the \\\"basic\\\" views, as well as month view. Renders one or more rows of day cells.\\n----------------------------------------------------------------------------------------------------------------------*/\\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\\n// It is responsible for managing width/height.\\n\\nvar BasicView = FC.BasicView = View.extend({\\n\\n\\tscroller: null,\\n\\n\\tdayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)\\n\\tdayGrid: null, // the main subcomponent that does most of the heavy lifting\\n\\n\\tdayNumbersVisible: false, // display day numbers on each day cell?\\n\\tcolWeekNumbersVisible: false, // display week numbers along the side?\\n\\tcellWeekNumbersVisible: false, // display week numbers in day cell?\\n\\n\\tweekNumberWidth: null, // width of all the week-number cells running down the side\\n\\n\\theadContainerEl: null, // div that hold's the dayGrid's rendered date header\\n\\theadRowEl: null, // the fake row element of the day-of-week header\\n\\n\\n\\tinitialize: function() {\\n\\t\\tthis.dayGrid = this.instantiateDayGrid();\\n\\n\\t\\tthis.scroller = new Scroller({\\n\\t\\t\\toverflowX: 'hidden',\\n\\t\\t\\toverflowY: 'auto'\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Generates the DayGrid object this view needs. Draws from this.dayGridClass\\n\\tinstantiateDayGrid: function() {\\n\\t\\t// generate a subclass on the fly with BasicView-specific behavior\\n\\t\\t// TODO: cache this subclass\\n\\t\\tvar subclass = this.dayGridClass.extend(basicDayGridMethods);\\n\\n\\t\\treturn new subclass(this);\\n\\t},\\n\\n\\n\\t// Computes the date range that will be rendered.\\n\\tbuildRenderRange: function(currentRange, currentRangeUnit) {\\n\\t\\tvar renderRange = View.prototype.buildRenderRange.apply(this, arguments);\\n\\n\\t\\t// year and month views should be aligned with weeks. this is already done for week\\n\\t\\tif (/^(year|month)$/.test(currentRangeUnit)) {\\n\\t\\t\\trenderRange.start.startOf('week');\\n\\n\\t\\t\\t// make end-of-week if not already\\n\\t\\t\\tif (renderRange.end.weekday()) {\\n\\t\\t\\t\\trenderRange.end.add(1, 'week').startOf('week'); // exclusively move backwards\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.trimHiddenDays(renderRange);\\n\\t},\\n\\n\\n\\t// Renders the view into `this.el`, which should already be assigned\\n\\trenderDates: function() {\\n\\n\\t\\tthis.dayGrid.breakOnWeeks = /year|month|week/.test(this.currentRangeUnit); // do before Grid::setRange\\n\\t\\tthis.dayGrid.setRange(this.renderRange);\\n\\n\\t\\tthis.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible\\n\\t\\tif (this.opt('weekNumbers')) {\\n\\t\\t\\tif (this.opt('weekNumbersWithinDays')) {\\n\\t\\t\\t\\tthis.cellWeekNumbersVisible = true;\\n\\t\\t\\t\\tthis.colWeekNumbersVisible = false;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tthis.cellWeekNumbersVisible = false;\\n\\t\\t\\t\\tthis.colWeekNumbersVisible = true;\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tthis.dayGrid.numbersVisible = this.dayNumbersVisible ||\\n\\t\\t\\tthis.cellWeekNumbersVisible || this.colWeekNumbersVisible;\\n\\n\\t\\tthis.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\\n\\t\\tthis.renderHead();\\n\\n\\t\\tthis.scroller.render();\\n\\t\\tvar dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\\n\\t\\tvar dayGridEl = $('<div class=\\\"fc-day-grid\\\" />').appendTo(dayGridContainerEl);\\n\\t\\tthis.el.find('.fc-body > tr > td').append(dayGridContainerEl);\\n\\n\\t\\tthis.dayGrid.setElement(dayGridEl);\\n\\t\\tthis.dayGrid.renderDates(this.hasRigidRows());\\n\\t},\\n\\n\\n\\t// render the day-of-week headers\\n\\trenderHead: function() {\\n\\t\\tthis.headContainerEl =\\n\\t\\t\\tthis.el.find('.fc-head-container')\\n\\t\\t\\t\\t.html(this.dayGrid.renderHeadHtml());\\n\\t\\tthis.headRowEl = this.headContainerEl.find('.fc-row');\\n\\t},\\n\\n\\n\\t// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\\n\\t// always completely kill the dayGrid's rendering.\\n\\tunrenderDates: function() {\\n\\t\\tthis.dayGrid.unrenderDates();\\n\\t\\tthis.dayGrid.removeElement();\\n\\t\\tthis.scroller.destroy();\\n\\t},\\n\\n\\n\\trenderBusinessHours: function() {\\n\\t\\tthis.dayGrid.renderBusinessHours();\\n\\t},\\n\\n\\n\\tunrenderBusinessHours: function() {\\n\\t\\tthis.dayGrid.unrenderBusinessHours();\\n\\t},\\n\\n\\n\\t// Builds the HTML skeleton for the view.\\n\\t// The day-grid component will render inside of a container defined by this HTML.\\n\\trenderSkeletonHtml: function() {\\n\\t\\treturn '' +\\n\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t'<thead class=\\\"fc-head\\\">' +\\n\\t\\t\\t\\t\\t'<tr>' +\\n\\t\\t\\t\\t\\t\\t'<td class=\\\"fc-head-container ' + this.widgetHeaderClass + '\\\"></td>' +\\n\\t\\t\\t\\t\\t'</tr>' +\\n\\t\\t\\t\\t'</thead>' +\\n\\t\\t\\t\\t'<tbody class=\\\"fc-body\\\">' +\\n\\t\\t\\t\\t\\t'<tr>' +\\n\\t\\t\\t\\t\\t\\t'<td class=\\\"' + this.widgetContentClass + '\\\"></td>' +\\n\\t\\t\\t\\t\\t'</tr>' +\\n\\t\\t\\t\\t'</tbody>' +\\n\\t\\t\\t'</table>';\\n\\t},\\n\\n\\n\\t// Generates an HTML attribute string for setting the width of the week number column, if it is known\\n\\tweekNumberStyleAttr: function() {\\n\\t\\tif (this.weekNumberWidth !== null) {\\n\\t\\t\\treturn 'style=\\\"width:' + this.weekNumberWidth + 'px\\\"';\\n\\t\\t}\\n\\t\\treturn '';\\n\\t},\\n\\n\\n\\t// Determines whether each row should have a constant height\\n\\thasRigidRows: function() {\\n\\t\\tvar eventLimit = this.opt('eventLimit');\\n\\t\\treturn eventLimit && typeof eventLimit !== 'number';\\n\\t},\\n\\n\\n\\t/* Dimensions\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Refreshes the horizontal dimensions of the view\\n\\tupdateWidth: function() {\\n\\t\\tif (this.colWeekNumbersVisible) {\\n\\t\\t\\t// Make sure all week number cells running down the side have the same width.\\n\\t\\t\\t// Record the width for cells created later.\\n\\t\\t\\tthis.weekNumberWidth = matchCellWidths(\\n\\t\\t\\t\\tthis.el.find('.fc-week-number')\\n\\t\\t\\t);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Adjusts the vertical dimensions of the view to the specified values\\n\\tsetHeight: function(totalHeight, isAuto) {\\n\\t\\tvar eventLimit = this.opt('eventLimit');\\n\\t\\tvar scrollerHeight;\\n\\t\\tvar scrollbarWidths;\\n\\n\\t\\t// reset all heights to be natural\\n\\t\\tthis.scroller.clear();\\n\\t\\tuncompensateScroll(this.headRowEl);\\n\\n\\t\\tthis.dayGrid.removeSegPopover(); // kill the \\\"more\\\" popover if displayed\\n\\n\\t\\t// is the event limit a constant level number?\\n\\t\\tif (eventLimit && typeof eventLimit === 'number') {\\n\\t\\t\\tthis.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\\n\\t\\t}\\n\\n\\t\\t// distribute the height to the rows\\n\\t\\t// (totalHeight is a \\\"recommended\\\" value if isAuto)\\n\\t\\tscrollerHeight = this.computeScrollerHeight(totalHeight);\\n\\t\\tthis.setGridHeight(scrollerHeight, isAuto);\\n\\n\\t\\t// is the event limit dynamically calculated?\\n\\t\\tif (eventLimit && typeof eventLimit !== 'number') {\\n\\t\\t\\tthis.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\\n\\t\\t}\\n\\n\\t\\tif (!isAuto) { // should we force dimensions of the scroll container?\\n\\n\\t\\t\\tthis.scroller.setHeight(scrollerHeight);\\n\\t\\t\\tscrollbarWidths = this.scroller.getScrollbarWidths();\\n\\n\\t\\t\\tif (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\\n\\n\\t\\t\\t\\tcompensateScroll(this.headRowEl, scrollbarWidths);\\n\\n\\t\\t\\t\\t// doing the scrollbar compensation might have created text overflow which created more height. redo\\n\\t\\t\\t\\tscrollerHeight = this.computeScrollerHeight(totalHeight);\\n\\t\\t\\t\\tthis.scroller.setHeight(scrollerHeight);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// guarantees the same scrollbar widths\\n\\t\\t\\tthis.scroller.lockOverflow(scrollbarWidths);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// given a desired total height of the view, returns what the height of the scroller should be\\n\\tcomputeScrollerHeight: function(totalHeight) {\\n\\t\\treturn totalHeight -\\n\\t\\t\\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\\n\\t},\\n\\n\\n\\t// Sets the height of just the DayGrid component in this view\\n\\tsetGridHeight: function(height, isAuto) {\\n\\t\\tif (isAuto) {\\n\\t\\t\\tundistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdistributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Scroll\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tcomputeInitialDateScroll: function() {\\n\\t\\treturn { top: 0 };\\n\\t},\\n\\n\\n\\tqueryDateScroll: function() {\\n\\t\\treturn { top: this.scroller.getScrollTop() };\\n\\t},\\n\\n\\n\\tapplyDateScroll: function(scroll) {\\n\\t\\tif (scroll.top !== undefined) {\\n\\t\\t\\tthis.scroller.setScrollTop(scroll.top);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Hit Areas\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\t// forward all hit-related method calls to dayGrid\\n\\n\\n\\thitsNeeded: function() {\\n\\t\\tthis.dayGrid.hitsNeeded();\\n\\t},\\n\\n\\n\\thitsNotNeeded: function() {\\n\\t\\tthis.dayGrid.hitsNotNeeded();\\n\\t},\\n\\n\\n\\tprepareHits: function() {\\n\\t\\tthis.dayGrid.prepareHits();\\n\\t},\\n\\n\\n\\treleaseHits: function() {\\n\\t\\tthis.dayGrid.releaseHits();\\n\\t},\\n\\n\\n\\tqueryHit: function(left, top) {\\n\\t\\treturn this.dayGrid.queryHit(left, top);\\n\\t},\\n\\n\\n\\tgetHitSpan: function(hit) {\\n\\t\\treturn this.dayGrid.getHitSpan(hit);\\n\\t},\\n\\n\\n\\tgetHitEl: function(hit) {\\n\\t\\treturn this.dayGrid.getHitEl(hit);\\n\\t},\\n\\n\\n\\t/* Events\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders the given events onto the view and populates the segments array\\n\\trenderEvents: function(events) {\\n\\t\\tthis.dayGrid.renderEvents(events);\\n\\n\\t\\tthis.updateHeight(); // must compensate for events that overflow the row\\n\\t},\\n\\n\\n\\t// Retrieves all segment objects that are rendered in the view\\n\\tgetEventSegs: function() {\\n\\t\\treturn this.dayGrid.getEventSegs();\\n\\t},\\n\\n\\n\\t// Unrenders all event elements and clears internal segment data\\n\\tunrenderEvents: function() {\\n\\t\\tthis.dayGrid.unrenderEvents();\\n\\n\\t\\t// we DON'T need to call updateHeight() because\\n\\t\\t// a renderEvents() call always happens after this, which will eventually call updateHeight()\\n\\t},\\n\\n\\n\\t/* Dragging (for both events and external elements)\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// A returned value of `true` signals that a mock \\\"helper\\\" event has been rendered.\\n\\trenderDrag: function(dropLocation, seg) {\\n\\t\\treturn this.dayGrid.renderDrag(dropLocation, seg);\\n\\t},\\n\\n\\n\\tunrenderDrag: function() {\\n\\t\\tthis.dayGrid.unrenderDrag();\\n\\t},\\n\\n\\n\\t/* Selection\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of a selection\\n\\trenderSelection: function(span) {\\n\\t\\tthis.dayGrid.renderSelection(span);\\n\\t},\\n\\n\\n\\t// Unrenders a visual indications of a selection\\n\\tunrenderSelection: function() {\\n\\t\\tthis.dayGrid.unrenderSelection();\\n\\t}\\n\\n});\\n\\n\\n// Methods that will customize the rendering behavior of the BasicView's dayGrid\\nvar basicDayGridMethods = {\\n\\n\\n\\t// Generates the HTML that will go before the day-of week header cells\\n\\trenderHeadIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\tif (view.colWeekNumbersVisible) {\\n\\t\\t\\treturn '' +\\n\\t\\t\\t\\t'<th class=\\\"fc-week-number ' + view.widgetHeaderClass + '\\\" ' + view.weekNumberStyleAttr() + '>' +\\n\\t\\t\\t\\t\\t'<span>' + // needed for matchCellWidths\\n\\t\\t\\t\\t\\t\\thtmlEscape(view.opt('weekNumberTitle')) +\\n\\t\\t\\t\\t\\t'</span>' +\\n\\t\\t\\t\\t'</th>';\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t},\\n\\n\\n\\t// Generates the HTML that will go before content-skeleton cells that display the day/week numbers\\n\\trenderNumberIntroHtml: function(row) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar weekStart = this.getCellDate(row, 0);\\n\\n\\t\\tif (view.colWeekNumbersVisible) {\\n\\t\\t\\treturn '' +\\n\\t\\t\\t\\t'<td class=\\\"fc-week-number\\\" ' + view.weekNumberStyleAttr() + '>' +\\n\\t\\t\\t\\t\\tview.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\\n\\t\\t\\t\\t\\t\\t{ date: weekStart, type: 'week', forceOff: this.colCnt === 1 },\\n\\t\\t\\t\\t\\t\\tweekStart.format('w') // inner HTML\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t'</td>';\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t},\\n\\n\\n\\t// Generates the HTML that goes before the day bg cells for each day-row\\n\\trenderBgIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\tif (view.colWeekNumbersVisible) {\\n\\t\\t\\treturn '<td class=\\\"fc-week-number ' + view.widgetContentClass + '\\\" ' +\\n\\t\\t\\t\\tview.weekNumberStyleAttr() + '></td>';\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t},\\n\\n\\n\\t// Generates the HTML that goes before every other type of row generated by DayGrid.\\n\\t// Affects helper-skeleton and highlight-skeleton rows.\\n\\trenderIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\tif (view.colWeekNumbersVisible) {\\n\\t\\t\\treturn '<td class=\\\"fc-week-number\\\" ' + view.weekNumberStyleAttr() + '></td>';\\n\\t\\t}\\n\\n\\t\\treturn '';\\n\\t}\\n\\n};\\n\\n;;\\n\\n/* A month view with day cells running in rows (one-per-week) and columns\\n----------------------------------------------------------------------------------------------------------------------*/\\n\\nvar MonthView = FC.MonthView = BasicView.extend({\\n\\n\\n\\t// Computes the date range that will be rendered.\\n\\tbuildRenderRange: function() {\\n\\t\\tvar renderRange = BasicView.prototype.buildRenderRange.apply(this, arguments);\\n\\t\\tvar rowCnt;\\n\\n\\t\\t// ensure 6 weeks\\n\\t\\tif (this.isFixedWeeks()) {\\n\\t\\t\\trowCnt = Math.ceil( // could be partial weeks due to hiddenDays\\n\\t\\t\\t\\trenderRange.end.diff(renderRange.start, 'weeks', true) // dontRound=true\\n\\t\\t\\t);\\n\\t\\t\\trenderRange.end.add(6 - rowCnt, 'weeks');\\n\\t\\t}\\n\\n\\t\\treturn renderRange;\\n\\t},\\n\\n\\n\\t// Overrides the default BasicView behavior to have special multi-week auto-height logic\\n\\tsetGridHeight: function(height, isAuto) {\\n\\n\\t\\t// if auto, make the height of each row the height that it would be if there were 6 weeks\\n\\t\\tif (isAuto) {\\n\\t\\t\\theight *= this.rowCnt / 6;\\n\\t\\t}\\n\\n\\t\\tdistributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\\n\\t},\\n\\n\\n\\tisFixedWeeks: function() {\\n\\t\\treturn this.opt('fixedWeekCount');\\n\\t}\\n\\n});\\n\\n;;\\n\\nfcViews.basic = {\\n\\t'class': BasicView\\n};\\n\\nfcViews.basicDay = {\\n\\ttype: 'basic',\\n\\tduration: { days: 1 }\\n};\\n\\nfcViews.basicWeek = {\\n\\ttype: 'basic',\\n\\tduration: { weeks: 1 }\\n};\\n\\nfcViews.month = {\\n\\t'class': MonthView,\\n\\tduration: { months: 1 }, // important for prev/next\\n\\tdefaults: {\\n\\t\\tfixedWeekCount: true\\n\\t}\\n};\\n;;\\n\\n/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\\n----------------------------------------------------------------------------------------------------------------------*/\\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\\n// Responsible for managing width/height.\\n\\nvar AgendaView = FC.AgendaView = View.extend({\\n\\n\\tscroller: null,\\n\\n\\ttimeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override\\n\\ttimeGrid: null, // the main time-grid subcomponent of this view\\n\\n\\tdayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override\\n\\tdayGrid: null, // the \\\"all-day\\\" subcomponent. if all-day is turned off, this will be null\\n\\n\\taxisWidth: null, // the width of the time axis running down the side\\n\\n\\theadContainerEl: null, // div that hold's the timeGrid's rendered date header\\n\\tnoScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars\\n\\n\\t// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath\\n\\tbottomRuleEl: null,\\n\\n\\t// indicates that minTime/maxTime affects rendering\\n\\tusesMinMaxTime: true,\\n\\n\\n\\tinitialize: function() {\\n\\t\\tthis.timeGrid = this.instantiateTimeGrid();\\n\\n\\t\\tif (this.opt('allDaySlot')) { // should we display the \\\"all-day\\\" area?\\n\\t\\t\\tthis.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view\\n\\t\\t}\\n\\n\\t\\tthis.scroller = new Scroller({\\n\\t\\t\\toverflowX: 'hidden',\\n\\t\\t\\toverflowY: 'auto'\\n\\t\\t});\\n\\t},\\n\\n\\n\\t// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\\n\\tinstantiateTimeGrid: function() {\\n\\t\\tvar subclass = this.timeGridClass.extend(agendaTimeGridMethods);\\n\\n\\t\\treturn new subclass(this);\\n\\t},\\n\\n\\n\\t// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\\n\\tinstantiateDayGrid: function() {\\n\\t\\tvar subclass = this.dayGridClass.extend(agendaDayGridMethods);\\n\\n\\t\\treturn new subclass(this);\\n\\t},\\n\\n\\n\\t/* Rendering\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders the view into `this.el`, which has already been assigned\\n\\trenderDates: function() {\\n\\n\\t\\tthis.timeGrid.setRange(this.renderRange);\\n\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.setRange(this.renderRange);\\n\\t\\t}\\n\\n\\t\\tthis.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\\n\\t\\tthis.renderHead();\\n\\n\\t\\tthis.scroller.render();\\n\\t\\tvar timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\\n\\t\\tvar timeGridEl = $('<div class=\\\"fc-time-grid\\\" />').appendTo(timeGridWrapEl);\\n\\t\\tthis.el.find('.fc-body > tr > td').append(timeGridWrapEl);\\n\\n\\t\\tthis.timeGrid.setElement(timeGridEl);\\n\\t\\tthis.timeGrid.renderDates();\\n\\n\\t\\t// the <hr> that sometimes displays under the time-grid\\n\\t\\tthis.bottomRuleEl = $('<hr class=\\\"fc-divider ' + this.widgetHeaderClass + '\\\"/>')\\n\\t\\t\\t.appendTo(this.timeGrid.el); // inject it into the time-grid\\n\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.setElement(this.el.find('.fc-day-grid'));\\n\\t\\t\\tthis.dayGrid.renderDates();\\n\\n\\t\\t\\t// have the day-grid extend it's coordinate area over the <hr> dividing the two grids\\n\\t\\t\\tthis.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\\n\\t\\t}\\n\\n\\t\\tthis.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller\\n\\t},\\n\\n\\n\\t// render the day-of-week headers\\n\\trenderHead: function() {\\n\\t\\tthis.headContainerEl =\\n\\t\\t\\tthis.el.find('.fc-head-container')\\n\\t\\t\\t\\t.html(this.timeGrid.renderHeadHtml());\\n\\t},\\n\\n\\n\\t// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\\n\\t// always completely kill each grid's rendering.\\n\\tunrenderDates: function() {\\n\\t\\tthis.timeGrid.unrenderDates();\\n\\t\\tthis.timeGrid.removeElement();\\n\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.unrenderDates();\\n\\t\\t\\tthis.dayGrid.removeElement();\\n\\t\\t}\\n\\n\\t\\tthis.scroller.destroy();\\n\\t},\\n\\n\\n\\t// Builds the HTML skeleton for the view.\\n\\t// The day-grid and time-grid components will render inside containers defined by this HTML.\\n\\trenderSkeletonHtml: function() {\\n\\t\\treturn '' +\\n\\t\\t\\t'<table>' +\\n\\t\\t\\t\\t'<thead class=\\\"fc-head\\\">' +\\n\\t\\t\\t\\t\\t'<tr>' +\\n\\t\\t\\t\\t\\t\\t'<td class=\\\"fc-head-container ' + this.widgetHeaderClass + '\\\"></td>' +\\n\\t\\t\\t\\t\\t'</tr>' +\\n\\t\\t\\t\\t'</thead>' +\\n\\t\\t\\t\\t'<tbody class=\\\"fc-body\\\">' +\\n\\t\\t\\t\\t\\t'<tr>' +\\n\\t\\t\\t\\t\\t\\t'<td class=\\\"' + this.widgetContentClass + '\\\">' +\\n\\t\\t\\t\\t\\t\\t\\t(this.dayGrid ?\\n\\t\\t\\t\\t\\t\\t\\t\\t'<div class=\\\"fc-day-grid\\\"/>' +\\n\\t\\t\\t\\t\\t\\t\\t\\t'<hr class=\\\"fc-divider ' + this.widgetHeaderClass + '\\\"/>' :\\n\\t\\t\\t\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t\\t\\t'</td>' +\\n\\t\\t\\t\\t\\t'</tr>' +\\n\\t\\t\\t\\t'</tbody>' +\\n\\t\\t\\t'</table>';\\n\\t},\\n\\n\\n\\t// Generates an HTML attribute string for setting the width of the axis, if it is known\\n\\taxisStyleAttr: function() {\\n\\t\\tif (this.axisWidth !== null) {\\n\\t\\t\\t return 'style=\\\"width:' + this.axisWidth + 'px\\\"';\\n\\t\\t}\\n\\t\\treturn '';\\n\\t},\\n\\n\\n\\t/* Business Hours\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\trenderBusinessHours: function() {\\n\\t\\tthis.timeGrid.renderBusinessHours();\\n\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.renderBusinessHours();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tunrenderBusinessHours: function() {\\n\\t\\tthis.timeGrid.unrenderBusinessHours();\\n\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.unrenderBusinessHours();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Now Indicator\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tgetNowIndicatorUnit: function() {\\n\\t\\treturn this.timeGrid.getNowIndicatorUnit();\\n\\t},\\n\\n\\n\\trenderNowIndicator: function(date) {\\n\\t\\tthis.timeGrid.renderNowIndicator(date);\\n\\t},\\n\\n\\n\\tunrenderNowIndicator: function() {\\n\\t\\tthis.timeGrid.unrenderNowIndicator();\\n\\t},\\n\\n\\n\\t/* Dimensions\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\tupdateSize: function(isResize) {\\n\\t\\tthis.timeGrid.updateSize(isResize);\\n\\n\\t\\tView.prototype.updateSize.call(this, isResize); // call the super-method\\n\\t},\\n\\n\\n\\t// Refreshes the horizontal dimensions of the view\\n\\tupdateWidth: function() {\\n\\t\\t// make all axis cells line up, and record the width so newly created axis cells will have it\\n\\t\\tthis.axisWidth = matchCellWidths(this.el.find('.fc-axis'));\\n\\t},\\n\\n\\n\\t// Adjusts the vertical dimensions of the view to the specified values\\n\\tsetHeight: function(totalHeight, isAuto) {\\n\\t\\tvar eventLimit;\\n\\t\\tvar scrollerHeight;\\n\\t\\tvar scrollbarWidths;\\n\\n\\t\\t// reset all dimensions back to the original state\\n\\t\\tthis.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\\n\\t\\tthis.scroller.clear(); // sets height to 'auto' and clears overflow\\n\\t\\tuncompensateScroll(this.noScrollRowEls);\\n\\n\\t\\t// limit number of events in the all-day area\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.removeSegPopover(); // kill the \\\"more\\\" popover if displayed\\n\\n\\t\\t\\teventLimit = this.opt('eventLimit');\\n\\t\\t\\tif (eventLimit && typeof eventLimit !== 'number') {\\n\\t\\t\\t\\teventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \\\"auto\\\" goes to a real number\\n\\t\\t\\t}\\n\\t\\t\\tif (eventLimit) {\\n\\t\\t\\t\\tthis.dayGrid.limitRows(eventLimit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!isAuto) { // should we force dimensions of the scroll container?\\n\\n\\t\\t\\tscrollerHeight = this.computeScrollerHeight(totalHeight);\\n\\t\\t\\tthis.scroller.setHeight(scrollerHeight);\\n\\t\\t\\tscrollbarWidths = this.scroller.getScrollbarWidths();\\n\\n\\t\\t\\tif (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\\n\\n\\t\\t\\t\\t// make the all-day and header rows lines up\\n\\t\\t\\t\\tcompensateScroll(this.noScrollRowEls, scrollbarWidths);\\n\\n\\t\\t\\t\\t// the scrollbar compensation might have changed text flow, which might affect height, so recalculate\\n\\t\\t\\t\\t// and reapply the desired height to the scroller.\\n\\t\\t\\t\\tscrollerHeight = this.computeScrollerHeight(totalHeight);\\n\\t\\t\\t\\tthis.scroller.setHeight(scrollerHeight);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// guarantees the same scrollbar widths\\n\\t\\t\\tthis.scroller.lockOverflow(scrollbarWidths);\\n\\n\\t\\t\\t// if there's any space below the slats, show the horizontal rule.\\n\\t\\t\\t// this won't cause any new overflow, because lockOverflow already called.\\n\\t\\t\\tif (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\\n\\t\\t\\t\\tthis.bottomRuleEl.show();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// given a desired total height of the view, returns what the height of the scroller should be\\n\\tcomputeScrollerHeight: function(totalHeight) {\\n\\t\\treturn totalHeight -\\n\\t\\t\\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\\n\\t},\\n\\n\\n\\t/* Scroll\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Computes the initial pre-configured scroll state prior to allowing the user to change it\\n\\tcomputeInitialDateScroll: function() {\\n\\t\\tvar scrollTime = moment.duration(this.opt('scrollTime'));\\n\\t\\tvar top = this.timeGrid.computeTimeTop(scrollTime);\\n\\n\\t\\t// zoom can give weird floating-point values. rather scroll a little bit further\\n\\t\\ttop = Math.ceil(top);\\n\\n\\t\\tif (top) {\\n\\t\\t\\ttop++; // to overcome top border that slots beyond the first have. looks better\\n\\t\\t}\\n\\n\\t\\treturn { top: top };\\n\\t},\\n\\n\\n\\tqueryDateScroll: function() {\\n\\t\\treturn { top: this.scroller.getScrollTop() };\\n\\t},\\n\\n\\n\\tapplyDateScroll: function(scroll) {\\n\\t\\tif (scroll.top !== undefined) {\\n\\t\\t\\tthis.scroller.setScrollTop(scroll.top);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Hit Areas\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\t// forward all hit-related method calls to the grids (dayGrid might not be defined)\\n\\n\\n\\thitsNeeded: function() {\\n\\t\\tthis.timeGrid.hitsNeeded();\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.hitsNeeded();\\n\\t\\t}\\n\\t},\\n\\n\\n\\thitsNotNeeded: function() {\\n\\t\\tthis.timeGrid.hitsNotNeeded();\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.hitsNotNeeded();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tprepareHits: function() {\\n\\t\\tthis.timeGrid.prepareHits();\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.prepareHits();\\n\\t\\t}\\n\\t},\\n\\n\\n\\treleaseHits: function() {\\n\\t\\tthis.timeGrid.releaseHits();\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.releaseHits();\\n\\t\\t}\\n\\t},\\n\\n\\n\\tqueryHit: function(left, top) {\\n\\t\\tvar hit = this.timeGrid.queryHit(left, top);\\n\\n\\t\\tif (!hit && this.dayGrid) {\\n\\t\\t\\thit = this.dayGrid.queryHit(left, top);\\n\\t\\t}\\n\\n\\t\\treturn hit;\\n\\t},\\n\\n\\n\\tgetHitSpan: function(hit) {\\n\\t\\t// TODO: hit.component is set as a hack to identify where the hit came from\\n\\t\\treturn hit.component.getHitSpan(hit);\\n\\t},\\n\\n\\n\\tgetHitEl: function(hit) {\\n\\t\\t// TODO: hit.component is set as a hack to identify where the hit came from\\n\\t\\treturn hit.component.getHitEl(hit);\\n\\t},\\n\\n\\n\\t/* Events\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders events onto the view and populates the View's segment array\\n\\trenderEvents: function(events) {\\n\\t\\tvar dayEvents = [];\\n\\t\\tvar timedEvents = [];\\n\\t\\tvar daySegs = [];\\n\\t\\tvar timedSegs;\\n\\t\\tvar i;\\n\\n\\t\\t// separate the events into all-day and timed\\n\\t\\tfor (i = 0; i < events.length; i++) {\\n\\t\\t\\tif (events[i].allDay) {\\n\\t\\t\\t\\tdayEvents.push(events[i]);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ttimedEvents.push(events[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// render the events in the subcomponents\\n\\t\\ttimedSegs = this.timeGrid.renderEvents(timedEvents);\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tdaySegs = this.dayGrid.renderEvents(dayEvents);\\n\\t\\t}\\n\\n\\t\\t// the all-day area is flexible and might have a lot of events, so shift the height\\n\\t\\tthis.updateHeight();\\n\\t},\\n\\n\\n\\t// Retrieves all segment objects that are rendered in the view\\n\\tgetEventSegs: function() {\\n\\t\\treturn this.timeGrid.getEventSegs().concat(\\n\\t\\t\\tthis.dayGrid ? this.dayGrid.getEventSegs() : []\\n\\t\\t);\\n\\t},\\n\\n\\n\\t// Unrenders all event elements and clears internal segment data\\n\\tunrenderEvents: function() {\\n\\n\\t\\t// unrender the events in the subcomponents\\n\\t\\tthis.timeGrid.unrenderEvents();\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.unrenderEvents();\\n\\t\\t}\\n\\n\\t\\t// we DON'T need to call updateHeight() because\\n\\t\\t// a renderEvents() call always happens after this, which will eventually call updateHeight()\\n\\t},\\n\\n\\n\\t/* Dragging (for events and external elements)\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// A returned value of `true` signals that a mock \\\"helper\\\" event has been rendered.\\n\\trenderDrag: function(dropLocation, seg) {\\n\\t\\tif (dropLocation.start.hasTime()) {\\n\\t\\t\\treturn this.timeGrid.renderDrag(dropLocation, seg);\\n\\t\\t}\\n\\t\\telse if (this.dayGrid) {\\n\\t\\t\\treturn this.dayGrid.renderDrag(dropLocation, seg);\\n\\t\\t}\\n\\t},\\n\\n\\n\\tunrenderDrag: function() {\\n\\t\\tthis.timeGrid.unrenderDrag();\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.unrenderDrag();\\n\\t\\t}\\n\\t},\\n\\n\\n\\t/* Selection\\n\\t------------------------------------------------------------------------------------------------------------------*/\\n\\n\\n\\t// Renders a visual indication of a selection\\n\\trenderSelection: function(span) {\\n\\t\\tif (span.start.hasTime() || span.end.hasTime()) {\\n\\t\\t\\tthis.timeGrid.renderSelection(span);\\n\\t\\t}\\n\\t\\telse if (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.renderSelection(span);\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Unrenders a visual indications of a selection\\n\\tunrenderSelection: function() {\\n\\t\\tthis.timeGrid.unrenderSelection();\\n\\t\\tif (this.dayGrid) {\\n\\t\\t\\tthis.dayGrid.unrenderSelection();\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n\\n// Methods that will customize the rendering behavior of the AgendaView's timeGrid\\n// TODO: move into TimeGrid\\nvar agendaTimeGridMethods = {\\n\\n\\n\\t// Generates the HTML that will go before the day-of week header cells\\n\\trenderHeadIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\t\\tvar weekText;\\n\\n\\t\\tif (view.opt('weekNumbers')) {\\n\\t\\t\\tweekText = this.start.format(view.opt('smallWeekFormat'));\\n\\n\\t\\t\\treturn '' +\\n\\t\\t\\t\\t'<th class=\\\"fc-axis fc-week-number ' + view.widgetHeaderClass + '\\\" ' + view.axisStyleAttr() + '>' +\\n\\t\\t\\t\\t\\tview.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\\n\\t\\t\\t\\t\\t\\t{ date: this.start, type: 'week', forceOff: this.colCnt > 1 },\\n\\t\\t\\t\\t\\t\\thtmlEscape(weekText) // inner HTML\\n\\t\\t\\t\\t\\t) +\\n\\t\\t\\t\\t'</th>';\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn '<th class=\\\"fc-axis ' + view.widgetHeaderClass + '\\\" ' + view.axisStyleAttr() + '></th>';\\n\\t\\t}\\n\\t},\\n\\n\\n\\t// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\\n\\trenderBgIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\treturn '<td class=\\\"fc-axis ' + view.widgetContentClass + '\\\" ' + view.axisStyleAttr() + '></td>';\\n\\t},\\n\\n\\n\\t// Generates the HTML that goes before all other types of cells.\\n\\t// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\\n\\trenderIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\treturn '<td class=\\\"fc-axis\\\" ' + view.axisStyleAttr() + '></td>';\\n\\t}\\n\\n};\\n\\n\\n// Methods that will customize the rendering behavior of the AgendaView's dayGrid\\nvar agendaDayGridMethods = {\\n\\n\\n\\t// Generates the HTML that goes before the all-day cells\\n\\trenderBgIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\treturn '' +\\n\\t\\t\\t'<td class=\\\"fc-axis ' + view.widgetContentClass + '\\\" ' + view.axisStyleAttr() + '>' +\\n\\t\\t\\t\\t'<span>' + // needed for matchCellWidths\\n\\t\\t\\t\\t\\tview.getAllDayHtml() +\\n\\t\\t\\t\\t'</span>' +\\n\\t\\t\\t'</td>';\\n\\t},\\n\\n\\n\\t// Generates the HTML that goes before all other types of cells.\\n\\t// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\\n\\trenderIntroHtml: function() {\\n\\t\\tvar view = this.view;\\n\\n\\t\\treturn '<td class=\\\"fc-axis\\\" ' + view.axisStyleAttr() + '></td>';\\n\\t}\\n\\n};\\n\\n;;\\n\\nvar AGENDA_ALL_DAY_EVENT_LIMIT = 5;\\n\\n// potential nice values for the slot-duration and interval-duration\\n// from largest to smallest\\nvar AGENDA_STOCK_SUB_DURATIONS = [\\n\\t{ hours: 1 },\\n\\t{ minutes: 30 },\\n\\t{ minutes: 15 },\\n\\t{ seconds: 30 },\\n\\t{ seconds: 15 }\\n];\\n\\nfcViews.agenda = {\\n\\t'class': AgendaView,\\n\\tdefaults: {\\n\\t\\tallDaySlot: true,\\n\\t\\tslotDuration: '00:30:00',\\n\\t\\tslotEventOverlap: true // a bad name. confused with overlap/constraint system\\n\\t}\\n};\\n\\nfcViews.agendaDay = {\\n\\ttype: 'agenda',\\n\\tduration: { days: 1 }\\n};\\n\\nfcViews.agendaWeek = {\\n\\ttype: 'agenda',\\n\\tduration: { weeks: 1 }\\n};\\n;;\\n\\n/*\\nResponsible for the scroller, and forwarding event-related actions into the \\\"grid\\\"\\n*/\\nvar ListView = View.extend({\\n\\n\\tgrid: null,\\n\\tscroller: null,\\n\\n\\tinitialize: function() {\\n\\t\\tthis.grid = new ListViewGrid(this);\\n\\t\\tthis.scroller = new Scroller({\\n\\t\\t\\toverflowX: 'hidden',\\n\\t\\t\\toverflowY: 'auto'\\n\\t\\t});\\n\\t},\\n\\n\\trenderSkeleton: function() {\\n\\t\\tthis.el.addClass(\\n\\t\\t\\t'fc-list-view ' +\\n\\t\\t\\tthis.widgetContentClass\\n\\t\\t);\\n\\n\\t\\tthis.scroller.render();\\n\\t\\tthis.scroller.el.appendTo(this.el);\\n\\n\\t\\tthis.grid.setElement(this.scroller.scrollEl);\\n\\t},\\n\\n\\tunrenderSkeleton: function() {\\n\\t\\tthis.scroller.destroy(); // will remove the Grid too\\n\\t},\\n\\n\\tsetHeight: function(totalHeight, isAuto) {\\n\\t\\tthis.scroller.setHeight(this.computeScrollerHeight(totalHeight));\\n\\t},\\n\\n\\tcomputeScrollerHeight: function(totalHeight) {\\n\\t\\treturn totalHeight -\\n\\t\\t\\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\\n\\t},\\n\\n\\trenderDates: function() {\\n\\t\\tthis.grid.setRange(this.renderRange); // needs to process range-related options\\n\\t},\\n\\n\\trenderEvents: function(events) {\\n\\t\\tthis.grid.renderEvents(events);\\n\\t},\\n\\n\\tunrenderEvents: function() {\\n\\t\\tthis.grid.unrenderEvents();\\n\\t},\\n\\n\\tisEventResizable: function(event) {\\n\\t\\treturn false;\\n\\t},\\n\\n\\tisEventDraggable: function(event) {\\n\\t\\treturn false;\\n\\t}\\n\\n});\\n\\n/*\\nResponsible for event rendering and user-interaction.\\nIts \\\"el\\\" is the inner-content of the above view's scroller.\\n*/\\nvar ListViewGrid = Grid.extend({\\n\\n\\tsegSelector: '.fc-list-item', // which elements accept event actions\\n\\thasDayInteractions: false, // no day selection or day clicking\\n\\n\\t// slices by day\\n\\tspanToSegs: function(span) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar dayStart = view.renderRange.start.clone().time(0); // timed, so segs get times!\\n\\t\\tvar dayIndex = 0;\\n\\t\\tvar seg;\\n\\t\\tvar segs = [];\\n\\n\\t\\twhile (dayStart < view.renderRange.end) {\\n\\n\\t\\t\\tseg = intersectRanges(span, {\\n\\t\\t\\t\\tstart: dayStart,\\n\\t\\t\\t\\tend: dayStart.clone().add(1, 'day')\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (seg) {\\n\\t\\t\\t\\tseg.dayIndex = dayIndex;\\n\\t\\t\\t\\tsegs.push(seg);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdayStart.add(1, 'day');\\n\\t\\t\\tdayIndex++;\\n\\n\\t\\t\\t// detect when span won't go fully into the next day,\\n\\t\\t\\t// and mutate the latest seg to the be the end.\\n\\t\\t\\tif (\\n\\t\\t\\t\\tseg && !seg.isEnd && span.end.hasTime() &&\\n\\t\\t\\t\\tspan.end < dayStart.clone().add(this.view.nextDayThreshold)\\n\\t\\t\\t) {\\n\\t\\t\\t\\tseg.end = span.end.clone();\\n\\t\\t\\t\\tseg.isEnd = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\t// like \\\"4:00am\\\"\\n\\tcomputeEventTimeFormat: function() {\\n\\t\\treturn this.view.opt('mediumTimeFormat');\\n\\t},\\n\\n\\t// for events with a url, the whole <tr> should be clickable,\\n\\t// but it's impossible to wrap with an <a> tag. simulate this.\\n\\thandleSegClick: function(seg, ev) {\\n\\t\\tvar url;\\n\\n\\t\\tGrid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action\\n\\n\\t\\t// not clicking on or within an <a> with an href\\n\\t\\tif (!$(ev.target).closest('a[href]').length) {\\n\\t\\t\\turl = seg.event.url;\\n\\t\\t\\tif (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler\\n\\t\\t\\t\\twindow.location.href = url; // simulate link click\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// returns list of foreground segs that were actually rendered\\n\\trenderFgSegs: function(segs) {\\n\\t\\tsegs = this.renderFgSegEls(segs); // might filter away hidden events\\n\\n\\t\\tif (!segs.length) {\\n\\t\\t\\tthis.renderEmptyMessage();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.renderSegList(segs);\\n\\t\\t}\\n\\n\\t\\treturn segs;\\n\\t},\\n\\n\\trenderEmptyMessage: function() {\\n\\t\\tthis.el.html(\\n\\t\\t\\t'<div class=\\\"fc-list-empty-wrap2\\\">' + // TODO: try less wraps\\n\\t\\t\\t'<div class=\\\"fc-list-empty-wrap1\\\">' +\\n\\t\\t\\t'<div class=\\\"fc-list-empty\\\">' +\\n\\t\\t\\t\\thtmlEscape(this.view.opt('noEventsMessage')) +\\n\\t\\t\\t'</div>' +\\n\\t\\t\\t'</div>' +\\n\\t\\t\\t'</div>'\\n\\t\\t);\\n\\t},\\n\\n\\t// render the event segments in the view\\n\\trenderSegList: function(allSegs) {\\n\\t\\tvar segsByDay = this.groupSegsByDay(allSegs); // sparse array\\n\\t\\tvar dayIndex;\\n\\t\\tvar daySegs;\\n\\t\\tvar i;\\n\\t\\tvar tableEl = $('<table class=\\\"fc-list-table\\\"><tbody/></table>');\\n\\t\\tvar tbodyEl = tableEl.find('tbody');\\n\\n\\t\\tfor (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {\\n\\t\\t\\tdaySegs = segsByDay[dayIndex];\\n\\t\\t\\tif (daySegs) { // sparse array, so might be undefined\\n\\n\\t\\t\\t\\t// append a day header\\n\\t\\t\\t\\ttbodyEl.append(this.dayHeaderHtml(\\n\\t\\t\\t\\t\\tthis.view.renderRange.start.clone().add(dayIndex, 'days')\\n\\t\\t\\t\\t));\\n\\n\\t\\t\\t\\tthis.sortEventSegs(daySegs);\\n\\n\\t\\t\\t\\tfor (i = 0; i < daySegs.length; i++) {\\n\\t\\t\\t\\t\\ttbodyEl.append(daySegs[i].el); // append event row\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.el.empty().append(tableEl);\\n\\t},\\n\\n\\t// Returns a sparse array of arrays, segs grouped by their dayIndex\\n\\tgroupSegsByDay: function(segs) {\\n\\t\\tvar segsByDay = []; // sparse array\\n\\t\\tvar i, seg;\\n\\n\\t\\tfor (i = 0; i < segs.length; i++) {\\n\\t\\t\\tseg = segs[i];\\n\\t\\t\\t(segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\\n\\t\\t\\t\\t.push(seg);\\n\\t\\t}\\n\\n\\t\\treturn segsByDay;\\n\\t},\\n\\n\\t// generates the HTML for the day headers that live amongst the event rows\\n\\tdayHeaderHtml: function(dayDate) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar mainFormat = view.opt('listDayFormat');\\n\\t\\tvar altFormat = view.opt('listDayAltFormat');\\n\\n\\t\\treturn '<tr class=\\\"fc-list-heading\\\" data-date=\\\"' + dayDate.format('YYYY-MM-DD') + '\\\">' +\\n\\t\\t\\t'<td class=\\\"' + view.widgetHeaderClass + '\\\" colspan=\\\"3\\\">' +\\n\\t\\t\\t\\t(mainFormat ?\\n\\t\\t\\t\\t\\tview.buildGotoAnchorHtml(\\n\\t\\t\\t\\t\\t\\tdayDate,\\n\\t\\t\\t\\t\\t\\t{ 'class': 'fc-list-heading-main' },\\n\\t\\t\\t\\t\\t\\thtmlEscape(dayDate.format(mainFormat)) // inner HTML\\n\\t\\t\\t\\t\\t) :\\n\\t\\t\\t\\t\\t'') +\\n\\t\\t\\t\\t(altFormat ?\\n\\t\\t\\t\\t\\tview.buildGotoAnchorHtml(\\n\\t\\t\\t\\t\\t\\tdayDate,\\n\\t\\t\\t\\t\\t\\t{ 'class': 'fc-list-heading-alt' },\\n\\t\\t\\t\\t\\t\\thtmlEscape(dayDate.format(altFormat)) // inner HTML\\n\\t\\t\\t\\t\\t) :\\n\\t\\t\\t\\t\\t'') +\\n\\t\\t\\t'</td>' +\\n\\t\\t'</tr>';\\n\\t},\\n\\n\\t// generates the HTML for a single event row\\n\\tfgSegHtml: function(seg) {\\n\\t\\tvar view = this.view;\\n\\t\\tvar classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));\\n\\t\\tvar bgColor = this.getSegBackgroundColor(seg);\\n\\t\\tvar event = seg.event;\\n\\t\\tvar url = event.url;\\n\\t\\tvar timeHtml;\\n\\n\\t\\tif (event.allDay) {\\n\\t\\t\\ttimeHtml = view.getAllDayHtml();\\n\\t\\t}\\n\\t\\telse if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day\\n\\t\\t\\tif (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day\\n\\t\\t\\t\\ttimeHtml = htmlEscape(this.getEventTimeText(seg));\\n\\t\\t\\t}\\n\\t\\t\\telse { // inner segment that lasts the whole day\\n\\t\\t\\t\\ttimeHtml = view.getAllDayHtml();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// Display the normal time text for the *event's* times\\n\\t\\t\\ttimeHtml = htmlEscape(this.getEventTimeText(event));\\n\\t\\t}\\n\\n\\t\\tif (url) {\\n\\t\\t\\tclasses.push('fc-has-url');\\n\\t\\t}\\n\\n\\t\\treturn '<tr class=\\\"' + classes.join(' ') + '\\\">' +\\n\\t\\t\\t(this.displayEventTime ?\\n\\t\\t\\t\\t'<td class=\\\"fc-list-item-time ' + view.widgetContentClass + '\\\">' +\\n\\t\\t\\t\\t\\t(timeHtml || '') +\\n\\t\\t\\t\\t'</td>' :\\n\\t\\t\\t\\t'') +\\n\\t\\t\\t'<td class=\\\"fc-list-item-marker ' + view.widgetContentClass + '\\\">' +\\n\\t\\t\\t\\t'<span class=\\\"fc-event-dot\\\"' +\\n\\t\\t\\t\\t(bgColor ?\\n\\t\\t\\t\\t\\t' style=\\\"background-color:' + bgColor + '\\\"' :\\n\\t\\t\\t\\t\\t'') +\\n\\t\\t\\t\\t'></span>' +\\n\\t\\t\\t'</td>' +\\n\\t\\t\\t'<td class=\\\"fc-list-item-title ' + view.widgetContentClass + '\\\">' +\\n\\t\\t\\t\\t'<a' + (url ? ' href=\\\"' + htmlEscape(url) + '\\\"' : '') + '>' +\\n\\t\\t\\t\\t\\thtmlEscape(seg.event.title || '') +\\n\\t\\t\\t\\t'</a>' +\\n\\t\\t\\t'</td>' +\\n\\t\\t'</tr>';\\n\\t}\\n\\n});\\n\\n;;\\n\\nfcViews.list = {\\n\\t'class': ListView,\\n\\tbuttonTextKey: 'list', // what to lookup in locale files\\n\\tdefaults: {\\n\\t\\tbuttonText: 'list', // text to display for English\\n\\t\\tlistDayFormat: 'LL', // like \\\"January 1, 2016\\\"\\n\\t\\tnoEventsMessage: 'No events to display'\\n\\t}\\n};\\n\\nfcViews.listDay = {\\n\\ttype: 'list',\\n\\tduration: { days: 1 },\\n\\tdefaults: {\\n\\t\\tlistDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header\\n\\t}\\n};\\n\\nfcViews.listWeek = {\\n\\ttype: 'list',\\n\\tduration: { weeks: 1 },\\n\\tdefaults: {\\n\\t\\tlistDayFormat: 'dddd', // day-of-week is more important\\n\\t\\tlistDayAltFormat: 'LL'\\n\\t}\\n};\\n\\nfcViews.listMonth = {\\n\\ttype: 'list',\\n\\tduration: { month: 1 },\\n\\tdefaults: {\\n\\t\\tlistDayAltFormat: 'dddd' // day-of-week is nice-to-have\\n\\t}\\n};\\n\\nfcViews.listYear = {\\n\\ttype: 'list',\\n\\tduration: { year: 1 },\\n\\tdefaults: {\\n\\t\\tlistDayAltFormat: 'dddd' // day-of-week is nice-to-have\\n\\t}\\n};\\n\\n;;\\n\\r\\nreturn FC; // export for Node/CommonJS\\r\\n});\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/fullcalendar/dist/fullcalendar.js\n// module id = 1087\n// module chunks = 2","module.exports = \"/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */\\n!function(a,b){\\\"use strict\\\";\\\"object\\\"==typeof module&&\\\"object\\\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\\\"jQuery requires a window with a document\\\");return b(a)}:b(a)}(\\\"undefined\\\"!=typeof window?window:this,function(a,b){\\\"use strict\\\";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement(\\\"script\\\");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q=\\\"3.2.1\\\",r=function(a,b){return new r.fn.init(a,b)},s=/^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\\\"boolean\\\"==typeof g&&(j=g,g=arguments[h]||{},h++),\\\"object\\\"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:\\\"jQuery\\\"+(q+Math.random()).replace(/\\\\D/g,\\\"\\\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\\\"function\\\"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return(\\\"number\\\"===b||\\\"string\\\"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||\\\"[object Object]\\\"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,\\\"constructor\\\")&&b.constructor,\\\"function\\\"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+\\\"\\\":\\\"object\\\"==typeof a||\\\"function\\\"==typeof a?j[k.call(a)]||\\\"object\\\":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,\\\"ms-\\\").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?\\\"\\\":(a+\\\"\\\").replace(s,\\\"\\\")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,\\\"string\\\"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if(\\\"string\\\"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),\\\"function\\\"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each(\\\"Boolean Number String Function Array Date RegExp Object Error Symbol\\\".split(\\\" \\\"),function(a,b){j[\\\"[object \\\"+b+\\\"]\\\"]=b.toLowerCase()});function w(a){var b=!!a&&\\\"length\\\"in a&&a.length,c=r.type(a);return\\\"function\\\"!==c&&!r.isWindow(a)&&(\\\"array\\\"===c||0===b||\\\"number\\\"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\\\"sizzle\\\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J=\\\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\\\",K=\\\"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\\",L=\\\"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\\\",M=\\\"\\\\\\\\[\\\"+K+\\\"*(\\\"+L+\\\")(?:\\\"+K+\\\"*([*^$|!~]?=)\\\"+K+\\\"*(?:'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\"|(\\\"+L+\\\"))|)\\\"+K+\\\"*\\\\\\\\]\\\",N=\\\":(\\\"+L+\\\")(?:\\\\\\\\((('((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\'])*)'|\\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\\")|((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\\\"+M+\\\")*)|.*)\\\\\\\\)|)\\\",O=new RegExp(K+\\\"+\\\",\\\"g\\\"),P=new RegExp(\\\"^\\\"+K+\\\"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\\\"+K+\\\"+$\\\",\\\"g\\\"),Q=new RegExp(\\\"^\\\"+K+\\\"*,\\\"+K+\\\"*\\\"),R=new RegExp(\\\"^\\\"+K+\\\"*([>+~]|\\\"+K+\\\")\\\"+K+\\\"*\\\"),S=new RegExp(\\\"=\\\"+K+\\\"*([^\\\\\\\\]'\\\\\\\"]*?)\\\"+K+\\\"*\\\\\\\\]\\\",\\\"g\\\"),T=new RegExp(N),U=new RegExp(\\\"^\\\"+L+\\\"$\\\"),V={ID:new RegExp(\\\"^#(\\\"+L+\\\")\\\"),CLASS:new RegExp(\\\"^\\\\\\\\.(\\\"+L+\\\")\\\"),TAG:new RegExp(\\\"^(\\\"+L+\\\"|[*])\\\"),ATTR:new RegExp(\\\"^\\\"+M),PSEUDO:new RegExp(\\\"^\\\"+N),CHILD:new RegExp(\\\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\\\"+K+\\\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\\\"+K+\\\"*(?:([+-]|)\\\"+K+\\\"*(\\\\\\\\d+)|))\\\"+K+\\\"*\\\\\\\\)|)\\\",\\\"i\\\"),bool:new RegExp(\\\"^(?:\\\"+J+\\\")$\\\",\\\"i\\\"),needsContext:new RegExp(\\\"^\\\"+K+\\\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\\\"+K+\\\"*((?:-\\\\\\\\d)?\\\\\\\\d*)\\\"+K+\\\"*\\\\\\\\)|)(?=[^-]|$)\\\",\\\"i\\\")},W=/^(?:input|select|textarea|button)$/i,X=/^h\\\\d$/i,Y=/^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,Z=/^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,$=/[+~]/,_=new RegExp(\\\"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\\\"+K+\\\"?|(\\\"+K+\\\")|.)\\\",\\\"ig\\\"),aa=function(a,b,c){var d=\\\"0x\\\"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,ca=function(a,b){return b?\\\"\\\\0\\\"===a?\\\"\\\\ufffd\\\":a.slice(0,-1)+\\\"\\\\\\\\\\\"+a.charCodeAt(a.length-1).toString(16)+\\\" \\\":\\\"\\\\\\\\\\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&(\\\"form\\\"in a||\\\"label\\\"in a)},{dir:\\\"parentNode\\\",next:\\\"legend\\\"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],\\\"string\\\"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+\\\" \\\"]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if(\\\"object\\\"!==b.nodeName.toLowerCase()){(k=b.getAttribute(\\\"id\\\"))?k=k.replace(ba,ca):b.setAttribute(\\\"id\\\",k=u),o=g(a),h=o.length;while(h--)o[h]=\\\"#\\\"+k+\\\" \\\"+sa(o[h]);r=o.join(\\\",\\\"),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute(\\\"id\\\")}}}return i(a.replace(P,\\\"$1\\\"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+\\\" \\\")>d.cacheLength&&delete b[a.shift()],b[c+\\\" \\\"]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement(\\\"fieldset\\\");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split(\\\"|\\\"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return\\\"input\\\"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return(\\\"input\\\"===c||\\\"button\\\"===c)&&b.type===a}}function oa(a){return function(b){return\\\"form\\\"in b?b.parentNode&&b.disabled===!1?\\\"label\\\"in b?\\\"label\\\"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:\\\"label\\\"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&\\\"undefined\\\"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&\\\"HTML\\\"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener(\\\"unload\\\",da,!1):e.attachEvent&&e.attachEvent(\\\"onunload\\\",da)),c.attributes=ja(function(a){return a.className=\\\"i\\\",!a.getAttribute(\\\"className\\\")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment(\\\"\\\")),!a.getElementsByTagName(\\\"*\\\").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute(\\\"id\\\")===b}},d.find.ID=function(a,b){if(\\\"undefined\\\"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c=\\\"undefined\\\"!=typeof a.getAttributeNode&&a.getAttributeNode(\\\"id\\\");return c&&c.value===b}},d.find.ID=function(a,b){if(\\\"undefined\\\"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode(\\\"id\\\"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode(\\\"id\\\"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return\\\"undefined\\\"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if(\\\"*\\\"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if(\\\"undefined\\\"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML=\\\"<a id='\\\"+u+\\\"'></a><select id='\\\"+u+\\\"-\\\\r\\\\\\\\' msallowcapture=''><option selected=''></option></select>\\\",a.querySelectorAll(\\\"[msallowcapture^='']\\\").length&&q.push(\\\"[*^$]=\\\"+K+\\\"*(?:''|\\\\\\\"\\\\\\\")\\\"),a.querySelectorAll(\\\"[selected]\\\").length||q.push(\\\"\\\\\\\\[\\\"+K+\\\"*(?:value|\\\"+J+\\\")\\\"),a.querySelectorAll(\\\"[id~=\\\"+u+\\\"-]\\\").length||q.push(\\\"~=\\\"),a.querySelectorAll(\\\":checked\\\").length||q.push(\\\":checked\\\"),a.querySelectorAll(\\\"a#\\\"+u+\\\"+*\\\").length||q.push(\\\".#.+[+~]\\\")}),ja(function(a){a.innerHTML=\\\"<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>\\\";var b=n.createElement(\\\"input\\\");b.setAttribute(\\\"type\\\",\\\"hidden\\\"),a.appendChild(b).setAttribute(\\\"name\\\",\\\"D\\\"),a.querySelectorAll(\\\"[name=d]\\\").length&&q.push(\\\"name\\\"+K+\\\"*[*^$|!~]?=\\\"),2!==a.querySelectorAll(\\\":enabled\\\").length&&q.push(\\\":enabled\\\",\\\":disabled\\\"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(\\\":disabled\\\").length&&q.push(\\\":enabled\\\",\\\":disabled\\\"),a.querySelectorAll(\\\"*,:x\\\"),q.push(\\\",.*:\\\")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,\\\"*\\\"),s.call(a,\\\"[s!='']:x\\\"),r.push(\\\"!=\\\",N)}),q=q.length&&new RegExp(q.join(\\\"|\\\")),r=r.length&&new RegExp(r.join(\\\"|\\\")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,\\\"='$1']\\\"),c.matchesSelector&&p&&!A[b+\\\" \\\"]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+\\\"\\\").replace(ba,ca)},ga.error=function(a){throw new Error(\\\"Syntax error, unrecognized expression: \\\"+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c=\\\"\\\",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if(\\\"string\\\"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{\\\">\\\":{dir:\\\"parentNode\\\",first:!0},\\\" \\\":{dir:\\\"parentNode\\\"},\\\"+\\\":{dir:\\\"previousSibling\\\",first:!0},\\\"~\\\":{dir:\\\"previousSibling\\\"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||\\\"\\\").replace(_,aa),\\\"~=\\\"===a[2]&&(a[3]=\\\" \\\"+a[3]+\\\" \\\"),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),\\\"nth\\\"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*(\\\"even\\\"===a[3]||\\\"odd\\\"===a[3])),a[5]=+(a[7]+a[8]||\\\"odd\\\"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||\\\"\\\":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(\\\")\\\",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return\\\"*\\\"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+\\\" \\\"];return b||(b=new RegExp(\\\"(^|\\\"+K+\\\")\\\"+a+\\\"(\\\"+K+\\\"|$)\\\"))&&y(a,function(a){return b.test(\\\"string\\\"==typeof a.className&&a.className||\\\"undefined\\\"!=typeof a.getAttribute&&a.getAttribute(\\\"class\\\")||\\\"\\\")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?\\\"!=\\\"===b:!b||(e+=\\\"\\\",\\\"=\\\"===b?e===c:\\\"!=\\\"===b?e!==c:\\\"^=\\\"===b?c&&0===e.indexOf(c):\\\"*=\\\"===b?c&&e.indexOf(c)>-1:\\\"$=\\\"===b?c&&e.slice(-c.length)===c:\\\"~=\\\"===b?(\\\" \\\"+e.replace(O,\\\" \\\")+\\\" \\\").indexOf(c)>-1:\\\"|=\\\"===b&&(e===c||e.slice(0,c.length+1)===c+\\\"-\\\"))}},CHILD:function(a,b,c,d,e){var f=\\\"nth\\\"!==a.slice(0,3),g=\\\"last\\\"!==a.slice(-4),h=\\\"of-type\\\"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?\\\"nextSibling\\\":\\\"previousSibling\\\",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p=\\\"only\\\"===a&&!o&&\\\"nextSibling\\\"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error(\\\"unsupported pseudo: \\\"+a);return e[u]?e(b):e.length>1?(c=[a,a,\\\"\\\",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,\\\"$1\\\"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||\\\"\\\")||ga.error(\\\"unsupported lang: \\\"+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute(\\\"xml:lang\\\")||b.getAttribute(\\\"lang\\\"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+\\\"-\\\");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return\\\"input\\\"===b&&!!a.checked||\\\"option\\\"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return\\\"input\\\"===b&&\\\"button\\\"===a.type||\\\"button\\\"===b},text:function(a){var b;return\\\"input\\\"===a.nodeName.toLowerCase()&&\\\"text\\\"===a.type&&(null==(b=a.getAttribute(\\\"type\\\"))||\\\"text\\\"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+\\\" \\\"];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P,\\\" \\\")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d=\\\"\\\";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&\\\"parentNode\\\"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||\\\"*\\\",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[\\\" \\\"],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:\\\" \\\"===a[i-2].type?\\\"*\\\":\\\"\\\"})).replace(P,\\\"$1\\\"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s=\\\"0\\\",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG(\\\"*\\\",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+\\\" \\\"];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m=\\\"function\\\"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&\\\"ID\\\"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split(\\\"\\\").sort(B).join(\\\"\\\")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement(\\\"fieldset\\\"))}),ja(function(a){return a.innerHTML=\\\"<a href='#'></a>\\\",\\\"#\\\"===a.firstChild.getAttribute(\\\"href\\\")})||ka(\\\"type|href|height|width\\\",function(a,b,c){if(!c)return a.getAttribute(b,\\\"type\\\"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML=\\\"<input/>\\\",a.firstChild.setAttribute(\\\"value\\\",\\\"\\\"),\\\"\\\"===a.firstChild.getAttribute(\\\"value\\\")})||ka(\\\"value\\\",function(a,b,c){if(!c&&\\\"input\\\"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute(\\\"disabled\\\")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[\\\":\\\"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i,D=/^.[^:#\\\\[\\\\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):\\\"string\\\"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=\\\":not(\\\"+a+\\\")\\\"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if(\\\"string\\\"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,\\\"string\\\"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,\\\"string\\\"==typeof a){if(e=\\\"<\\\"===a[0]&&\\\">\\\"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g=\\\"string\\\"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?\\\"string\\\"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,\\\"parentNode\\\")},parentsUntil:function(a,b,c){return y(a,\\\"parentNode\\\",c)},next:function(a){return K(a,\\\"nextSibling\\\")},prev:function(a){return K(a,\\\"previousSibling\\\")},nextAll:function(a){return y(a,\\\"nextSibling\\\")},prevAll:function(a){return y(a,\\\"previousSibling\\\")},nextUntil:function(a,b,c){return y(a,\\\"nextSibling\\\",c)},prevUntil:function(a,b,c){return y(a,\\\"previousSibling\\\",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,\\\"iframe\\\")?a.contentDocument:(B(a,\\\"template\\\")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return\\\"Until\\\"!==a.slice(-5)&&(d=c),d&&\\\"string\\\"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a=\\\"string\\\"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:\\\"\\\")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&\\\"string\\\"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c=\\\"\\\",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=\\\"\\\"),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[[\\\"notify\\\",\\\"progress\\\",r.Callbacks(\\\"memory\\\"),r.Callbacks(\\\"memory\\\"),2],[\\\"resolve\\\",\\\"done\\\",r.Callbacks(\\\"once memory\\\"),r.Callbacks(\\\"once memory\\\"),0,\\\"resolved\\\"],[\\\"reject\\\",\\\"fail\\\",r.Callbacks(\\\"once memory\\\"),r.Callbacks(\\\"once memory\\\"),1,\\\"rejected\\\"]],d=\\\"pending\\\",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},\\\"catch\\\":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+\\\"With\\\"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError(\\\"Thenable self-resolution\\\");j=a&&(\\\"object\\\"==typeof a||\\\"function\\\"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+\\\"With\\\"](this===f?void 0:this,arguments),this},f[b[0]+\\\"With\\\"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),\\\"pending\\\"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn(\\\"jQuery.Deferred exception: \\\"+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)[\\\"catch\\\"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener(\\\"DOMContentLoaded\\\",S),\\na.removeEventListener(\\\"load\\\",S),r.ready()}\\\"complete\\\"===d.readyState||\\\"loading\\\"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener(\\\"DOMContentLoaded\\\",S),a.addEventListener(\\\"load\\\",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if(\\\"object\\\"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if(\\\"string\\\"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&\\\"string\\\"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,Z=/[A-Z]/g;function $(a){return\\\"true\\\"===a||\\\"false\\\"!==a&&(\\\"null\\\"===a?null:a===+a+\\\"\\\"?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d=\\\"data-\\\"+b.replace(Z,\\\"-$&\\\").toLowerCase(),c=a.getAttribute(d),\\\"string\\\"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,\\\"hasDataAttrs\\\"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf(\\\"data-\\\")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,\\\"hasDataAttrs\\\",!0)}return e}return\\\"object\\\"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||\\\"fx\\\")+\\\"queue\\\",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||\\\"fx\\\";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};\\\"inprogress\\\"===e&&(e=c.shift(),d--),e&&(\\\"fx\\\"===b&&c.unshift(\\\"inprogress\\\"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+\\\"queueHooks\\\";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks(\\\"once memory\\\").add(function(){W.remove(a,[b+\\\"queue\\\",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return\\\"string\\\"!=typeof a&&(b=a,a=\\\"fx\\\",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),\\\"fx\\\"===a&&\\\"inprogress\\\"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||\\\"fx\\\",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};\\\"string\\\"!=typeof a&&(b=a,a=void 0),a=a||\\\"fx\\\";while(g--)c=W.get(f[g],a+\\\"queueHooks\\\"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/.source,ba=new RegExp(\\\"^(?:([+-])=|)(\\\"+aa+\\\")([a-z%]*)$\\\",\\\"i\\\"),ca=[\\\"Top\\\",\\\"Right\\\",\\\"Bottom\\\",\\\"Left\\\"],da=function(a,b){return a=b||a,\\\"none\\\"===a.style.display||\\\"\\\"===a.style.display&&r.contains(a.ownerDocument,a)&&\\\"none\\\"===r.css(a,\\\"display\\\")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,\\\"\\\")},i=h(),j=c&&c[3]||(r.cssNumber[b]?\\\"\\\":\\\"px\\\"),k=(r.cssNumber[b]||\\\"px\\\"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||\\\".5\\\",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,\\\"display\\\"),b.parentNode.removeChild(b),\\\"none\\\"===e&&(e=\\\"block\\\"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?(\\\"none\\\"===c&&(e[f]=W.get(d,\\\"display\\\")||null,e[f]||(d.style.display=\\\"\\\")),\\\"\\\"===d.style.display&&da(d)&&(e[f]=ha(d))):\\\"none\\\"!==c&&(e[f]=\\\"none\\\",W.set(d,\\\"display\\\",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return\\\"boolean\\\"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i,la=/^$|\\\\/(?:java|ecma)script/i,ma={option:[1,\\\"<select multiple='multiple'>\\\",\\\"</select>\\\"],thead:[1,\\\"<table>\\\",\\\"</table>\\\"],col:[2,\\\"<table><colgroup>\\\",\\\"</colgroup></table>\\\"],tr:[2,\\\"<table><tbody>\\\",\\\"</tbody></table>\\\"],td:[3,\\\"<table><tbody><tr>\\\",\\\"</tr></tbody></table>\\\"],_default:[0,\\\"\\\",\\\"\\\"]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c=\\\"undefined\\\"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||\\\"*\\\"):\\\"undefined\\\"!=typeof a.querySelectorAll?a.querySelectorAll(b||\\\"*\\\"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],\\\"globalEval\\\",!b||W.get(b[c],\\\"globalEval\\\"))}var pa=/<|&#?\\\\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if(\\\"object\\\"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement(\\\"div\\\")),h=(ka.exec(f)||[\\\"\\\",\\\"\\\"])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=\\\"\\\"}else m.push(b.createTextNode(f));l.textContent=\\\"\\\",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),\\\"script\\\"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||\\\"\\\")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement(\\\"div\\\")),c=d.createElement(\\\"input\\\");c.setAttribute(\\\"type\\\",\\\"radio\\\"),c.setAttribute(\\\"checked\\\",\\\"checked\\\"),c.setAttribute(\\\"name\\\",\\\"t\\\"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML=\\\"<textarea>x</textarea>\\\",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\\\\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if(\\\"object\\\"==typeof b){\\\"string\\\"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&(\\\"string\\\"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return\\\"undefined\\\"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||\\\"\\\").match(L)||[\\\"\\\"],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||\\\"\\\").split(\\\".\\\").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(\\\".\\\")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||\\\"\\\").match(L)||[\\\"\\\"],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||\\\"\\\").split(\\\".\\\").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp(\\\"(^|\\\\\\\\.)\\\"+o.join(\\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\")+\\\"(\\\\\\\\.|$)\\\"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&(\\\"**\\\"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,\\\"handle events\\\")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,\\\"events\\\")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!(\\\"click\\\"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&(\\\"click\\\"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+\\\" \\\",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:\\\"focusin\\\"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:\\\"focusout\\\"},click:{trigger:function(){if(\\\"checkbox\\\"===this.type&&this.click&&B(this,\\\"input\\\"))return this.click(),!1},_default:function(a){return B(a.target,\\\"a\\\")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\\\"char\\\":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:\\\"mouseover\\\",mouseleave:\\\"mouseout\\\",pointerenter:\\\"pointerover\\\",pointerleave:\\\"pointerout\\\"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+\\\".\\\"+d.namespace:d.origType,d.selector,d.handler),this;if(\\\"object\\\"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&\\\"function\\\"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,Ca=/^true\\\\/(.*)/,Da=/^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;function Ea(a,b){return B(a,\\\"table\\\")&&B(11!==b.nodeType?b:b.firstChild,\\\"tr\\\")?r(\\\">tbody\\\",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute(\\\"type\\\"))+\\\"/\\\"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute(\\\"type\\\"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();\\\"input\\\"===c&&ja.test(a.type)?b.checked=a.checked:\\\"input\\\"!==c&&\\\"textarea\\\"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&\\\"string\\\"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,\\\"script\\\"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,\\\"script\\\"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||\\\"\\\")&&!W.access(j,\\\"globalEval\\\")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,\\\"\\\"),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,\\\"script\\\")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,\\\"<$1></$2>\\\")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,\\\"script\\\"),g.length>0&&oa(g,!i&&na(a,\\\"script\\\")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent=\\\"\\\");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if(\\\"string\\\"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||[\\\"\\\",\\\"\\\"])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:\\\"append\\\",prependTo:\\\"prepend\\\",insertBefore:\\\"before\\\",insertAfter:\\\"after\\\",replaceAll:\\\"replaceWith\\\"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp(\\\"^(\\\"+aa+\\\")(?!px)[a-z%]+$\\\",\\\"i\\\"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText=\\\"box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\\\",i.innerHTML=\\\"\\\",ra.appendChild(h);var b=a.getComputedStyle(i);c=\\\"1%\\\"!==b.top,g=\\\"2px\\\"===b.marginLeft,e=\\\"4px\\\"===b.width,i.style.marginRight=\\\"50%\\\",f=\\\"4px\\\"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement(\\\"div\\\"),i=d.createElement(\\\"div\\\");i.style&&(i.style.backgroundClip=\\\"content-box\\\",i.cloneNode(!0).style.backgroundClip=\\\"\\\",o.clearCloneStyle=\\\"content-box\\\"===i.style.backgroundClip,h.style.cssText=\\\"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\\\",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],\\\"\\\"!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+\\\"\\\":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:\\\"absolute\\\",visibility:\\\"hidden\\\",display:\\\"block\\\"},Ta={letterSpacing:\\\"0\\\",fontWeight:\\\"400\\\"},Ua=[\\\"Webkit\\\",\\\"Moz\\\",\\\"ms\\\"],Va=d.createElement(\\\"div\\\").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||\\\"px\\\"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?\\\"border\\\":\\\"content\\\")?4:\\\"width\\\"===b?1:0;f<4;f+=2)\\\"margin\\\"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?(\\\"content\\\"===c&&(g-=r.css(a,\\\"padding\\\"+ca[f],!0,e)),\\\"margin\\\"!==c&&(g-=r.css(a,\\\"border\\\"+ca[f]+\\\"Width\\\",!0,e))):(g+=r.css(a,\\\"padding\\\"+ca[f],!0,e),\\\"padding\\\"!==c&&(g+=r.css(a,\\\"border\\\"+ca[f]+\\\"Width\\\",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g=\\\"border-box\\\"===r.css(a,\\\"boxSizing\\\",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),\\\"auto\\\"===f&&(f=a[\\\"offset\\\"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?\\\"border\\\":\\\"content\\\"),d,e)+\\\"px\\\")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,\\\"opacity\\\");return\\\"\\\"===c?\\\"1\\\":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\\\"float\\\":\\\"cssFloat\\\"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&\\\"get\\\"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,\\\"string\\\"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f=\\\"number\\\"),null!=c&&c===c&&(\\\"number\\\"===f&&(c+=e&&e[3]||(r.cssNumber[h]?\\\"\\\":\\\"px\\\")),o.clearCloneStyle||\\\"\\\"!==c||0!==b.indexOf(\\\"background\\\")||(j[b]=\\\"inherit\\\"),g&&\\\"set\\\"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&\\\"get\\\"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),\\\"normal\\\"===e&&b in Ta&&(e=Ta[b]),\\\"\\\"===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each([\\\"height\\\",\\\"width\\\"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,\\\"display\\\"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,\\\"border-box\\\"===r.css(a,\\\"boxSizing\\\",!1,f),f);return g&&(e=ba.exec(c))&&\\\"px\\\"!==(e[3]||\\\"px\\\")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,\\\"marginLeft\\\"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+\\\"px\\\"}),r.each({margin:\\\"\\\",padding:\\\"\\\",border:\\\"Width\\\"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f=\\\"string\\\"==typeof c?c.split(\\\" \\\"):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?\\\"\\\":\\\"px\\\")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,\\\"\\\"),b&&\\\"auto\\\"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:\\\"swing\\\"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e[\\\"margin\\\"+c]=e[\\\"padding\\\"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners[\\\"*\\\"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l=\\\"width\\\"in b||\\\"height\\\"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,\\\"fxshow\\\");c.queue||(g=r._queueHooks(a,\\\"fx\\\"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,\\\"fx\\\").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||\\\"toggle\\\"===e,e===(p?\\\"hide\\\":\\\"show\\\")){if(\\\"show\\\"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,\\\"display\\\")),k=r.css(a,\\\"display\\\"),\\\"none\\\"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,\\\"display\\\"),ia([a]))),(\\\"inline\\\"===k||\\\"inline-block\\\"===k&&null!=j)&&\\\"none\\\"===r.css(a,\\\"float\\\")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j=\\\"none\\\"===k?\\\"\\\":k)),o.display=\\\"inline-block\\\")),c.overflow&&(o.overflow=\\\"hidden\\\",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?\\\"hidden\\\"in q&&(p=q.hidden):q=W.access(a,\\\"fxshow\\\",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,\\\"fxshow\\\");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&\\\"expand\\\"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{\\\"*\\\":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=[\\\"*\\\"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&\\\"object\\\"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:\\\"number\\\"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue=\\\"fx\\\"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css(\\\"opacity\\\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,\\\"finish\\\"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return\\\"string\\\"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||\\\"fx\\\",[]),this.each(function(){var b=!0,e=null!=a&&a+\\\"queueHooks\\\",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||\\\"fx\\\"),this.each(function(){var b,c=W.get(this),d=c[a+\\\"queue\\\"],e=c[a+\\\"queueHooks\\\"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each([\\\"toggle\\\",\\\"show\\\",\\\"hide\\\"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||\\\"boolean\\\"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb(\\\"show\\\"),slideUp:gb(\\\"hide\\\"),slideToggle:gb(\\\"toggle\\\"),fadeIn:{opacity:\\\"show\\\"},fadeOut:{opacity:\\\"hide\\\"},fadeToggle:{opacity:\\\"toggle\\\"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||\\\"fx\\\",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement(\\\"input\\\"),b=d.createElement(\\\"select\\\"),c=b.appendChild(d.createElement(\\\"option\\\"));a.type=\\\"checkbox\\\",o.checkOn=\\\"\\\"!==a.value,o.optSelected=c.selected,a=d.createElement(\\\"input\\\"),a.value=\\\"t\\\",a.type=\\\"radio\\\",o.radioValue=\\\"t\\\"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return\\\"undefined\\\"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&\\\"set\\\"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+\\\"\\\"),c):e&&\\\"get\\\"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),\\nnull==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&\\\"radio\\\"===b&&B(a,\\\"input\\\")){var c=a.value;return a.setAttribute(\\\"type\\\",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\\\\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&\\\"set\\\"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&\\\"get\\\"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,\\\"tabindex\\\");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{\\\"for\\\":\\\"htmlFor\\\",\\\"class\\\":\\\"className\\\"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each([\\\"tabIndex\\\",\\\"readOnly\\\",\\\"maxLength\\\",\\\"cellSpacing\\\",\\\"cellPadding\\\",\\\"rowSpan\\\",\\\"colSpan\\\",\\\"useMap\\\",\\\"frameBorder\\\",\\\"contentEditable\\\"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(\\\" \\\")}function qb(a){return a.getAttribute&&a.getAttribute(\\\"class\\\")||\\\"\\\"}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if(\\\"string\\\"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&\\\" \\\"+pb(e)+\\\" \\\"){g=0;while(f=b[g++])d.indexOf(\\\" \\\"+f+\\\" \\\")<0&&(d+=f+\\\" \\\");h=pb(d),e!==h&&c.setAttribute(\\\"class\\\",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr(\\\"class\\\",\\\"\\\");if(\\\"string\\\"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&\\\" \\\"+pb(e)+\\\" \\\"){g=0;while(f=b[g++])while(d.indexOf(\\\" \\\"+f+\\\" \\\")>-1)d=d.replace(\\\" \\\"+f+\\\" \\\",\\\" \\\");h=pb(d),e!==h&&c.setAttribute(\\\"class\\\",h)}}return this},toggleClass:function(a,b){var c=typeof a;return\\\"boolean\\\"==typeof b&&\\\"string\\\"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if(\\\"string\\\"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&\\\"boolean\\\"!==c||(b=qb(this),b&&W.set(this,\\\"__className__\\\",b),this.setAttribute&&this.setAttribute(\\\"class\\\",b||a===!1?\\\"\\\":W.get(this,\\\"__className__\\\")||\\\"\\\"))})},hasClass:function(a){var b,c,d=0;b=\\\" \\\"+a+\\\" \\\";while(c=this[d++])if(1===c.nodeType&&(\\\" \\\"+pb(qb(c))+\\\" \\\").indexOf(b)>-1)return!0;return!1}});var rb=/\\\\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e=\\\"\\\":\\\"number\\\"==typeof e?e+=\\\"\\\":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?\\\"\\\":a+\\\"\\\"})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&\\\"set\\\"in b&&void 0!==b.set(this,e,\\\"value\\\")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&\\\"get\\\"in b&&void 0!==(c=b.get(e,\\\"value\\\"))?c:(c=e.value,\\\"string\\\"==typeof c?c.replace(rb,\\\"\\\"):null==c?\\\"\\\":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,\\\"value\\\");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g=\\\"select-one\\\"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,\\\"optgroup\\\"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each([\\\"radio\\\",\\\"checkbox\\\"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute(\\\"value\\\")?\\\"on\\\":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,\\\"type\\\")?b.type:b,q=l.call(b,\\\"namespace\\\")?b.namespace.split(\\\".\\\"):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(\\\".\\\")>-1&&(q=p.split(\\\".\\\"),p=q.shift(),q.sort()),k=p.indexOf(\\\":\\\")<0&&\\\"on\\\"+p,b=b[r.expando]?b:new r.Event(p,\\\"object\\\"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join(\\\".\\\"),b.rnamespace=b.namespace?new RegExp(\\\"(^|\\\\\\\\.)\\\"+q.join(\\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\")+\\\"(\\\\\\\\.|$)\\\"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,\\\"events\\\")||{})[b.type]&&W.get(h,\\\"handle\\\"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each(\\\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\\\".split(\\\" \\\"),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin=\\\"onfocusin\\\"in a,o.focusin||r.each({focus:\\\"focusin\\\",blur:\\\"focusout\\\"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\\\\?/;r.parseXML=function(b){var c;if(!b||\\\"string\\\"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,\\\"text/xml\\\")}catch(d){c=void 0}return c&&!c.getElementsByTagName(\\\"parsererror\\\").length||r.error(\\\"Invalid XML: \\\"+b),c};var wb=/\\\\[\\\\]$/,xb=/\\\\r?\\\\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+\\\"[\\\"+(\\\"object\\\"==typeof e&&null!=e?b:\\\"\\\")+\\\"]\\\",e,c,d)});else if(c||\\\"object\\\"!==r.type(b))d(a,b);else for(e in b)Ab(a+\\\"[\\\"+e+\\\"]\\\",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+\\\"=\\\"+encodeURIComponent(null==c?\\\"\\\":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join(\\\"&\\\")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,\\\"elements\\\");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(\\\":disabled\\\")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,\\\"\\\\r\\\\n\\\")}}):{name:b.name,value:c.replace(xb,\\\"\\\\r\\\\n\\\")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\\\\/\\\\//,Ib={},Jb={},Kb=\\\"*/\\\".concat(\\\"*\\\"),Lb=d.createElement(\\\"a\\\");Lb.href=tb.href;function Mb(a){return function(b,c){\\\"string\\\"!=typeof b&&(c=b,b=\\\"*\\\");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])\\\"+\\\"===d[0]?(d=d.slice(1)||\\\"*\\\",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return\\\"string\\\"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e[\\\"*\\\"]&&g(\\\"*\\\")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while(\\\"*\\\"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader(\\\"Content-Type\\\"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+\\\" \\\"+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if(\\\"*\\\"===f)f=i;else if(\\\"*\\\"!==i&&i!==f){if(g=j[i+\\\" \\\"+f]||j[\\\"* \\\"+f],!g)for(e in j)if(h=e.split(\\\" \\\"),h[1]===f&&(g=j[i+\\\" \\\"+h[0]]||j[\\\"* \\\"+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a[\\\"throws\\\"])b=g(b);else try{b=g(b)}catch(l){return{state:\\\"parsererror\\\",error:g?l:\\\"No conversion from \\\"+i+\\\" to \\\"+f}}}return{state:\\\"success\\\",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:\\\"GET\\\",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:\\\"application/x-www-form-urlencoded; charset=UTF-8\\\",accepts:{\\\"*\\\":Kb,text:\\\"text/plain\\\",html:\\\"text/html\\\",xml:\\\"application/xml, text/xml\\\",json:\\\"application/json, text/javascript\\\"},contents:{xml:/\\\\bxml\\\\b/,html:/\\\\bhtml/,json:/\\\\bjson\\\\b/},responseFields:{xml:\\\"responseXML\\\",text:\\\"responseText\\\",json:\\\"responseJSON\\\"},converters:{\\\"* text\\\":String,\\\"text html\\\":!0,\\\"text json\\\":JSON.parse,\\\"text xml\\\":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){\\\"object\\\"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks(\\\"once memory\\\"),u=o.statusCode||{},v={},w={},x=\\\"canceled\\\",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+\\\"\\\").replace(Hb,tb.protocol+\\\"//\\\"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||\\\"*\\\").toLowerCase().match(L)||[\\\"\\\"],null==o.crossDomain){j=d.createElement(\\\"a\\\");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+\\\"//\\\"+Lb.host!=j.protocol+\\\"//\\\"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&\\\"string\\\"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger(\\\"ajaxStart\\\"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,\\\"\\\"),o.hasContent?o.data&&o.processData&&0===(o.contentType||\\\"\\\").indexOf(\\\"application/x-www-form-urlencoded\\\")&&(o.data=o.data.replace(Bb,\\\"+\\\")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?\\\"&\\\":\\\"?\\\")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,\\\"$1\\\"),n=(vb.test(f)?\\\"&\\\":\\\"?\\\")+\\\"_=\\\"+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader(\\\"If-Modified-Since\\\",r.lastModified[f]),r.etag[f]&&y.setRequestHeader(\\\"If-None-Match\\\",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader(\\\"Content-Type\\\",o.contentType),y.setRequestHeader(\\\"Accept\\\",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+(\\\"*\\\"!==o.dataTypes[0]?\\\", \\\"+Kb+\\\"; q=0.01\\\":\\\"\\\"):o.accepts[\\\"*\\\"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x=\\\"abort\\\",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger(\\\"ajaxSend\\\",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort(\\\"timeout\\\")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,\\\"No Transport\\\");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||\\\"\\\",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader(\\\"Last-Modified\\\"),w&&(r.lastModified[f]=w),w=y.getResponseHeader(\\\"etag\\\"),w&&(r.etag[f]=w)),204===b||\\\"HEAD\\\"===o.type?x=\\\"nocontent\\\":304===b?x=\\\"notmodified\\\":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x=\\\"error\\\",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+\\\"\\\",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?\\\"ajaxSuccess\\\":\\\"ajaxError\\\",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger(\\\"ajaxComplete\\\",[y,o]),--r.active||r.event.trigger(\\\"ajaxStop\\\")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,\\\"json\\\")},getScript:function(a,b){return r.get(a,void 0,b,\\\"script\\\")}}),r.each([\\\"get\\\",\\\"post\\\"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:\\\"GET\\\",dataType:\\\"script\\\",cache:!0,async:!1,global:!1,\\\"throws\\\":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not(\\\"body\\\").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&\\\"withCredentials\\\"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e[\\\"X-Requested-With\\\"]||(e[\\\"X-Requested-With\\\"]=\\\"XMLHttpRequest\\\");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,\\\"abort\\\"===a?h.abort():\\\"error\\\"===a?\\\"number\\\"!=typeof h.status?f(0,\\\"error\\\"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,\\\"text\\\"!==(h.responseType||\\\"text\\\")||\\\"string\\\"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c(\\\"error\\\"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c(\\\"abort\\\");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:\\\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\\\"},contents:{script:/\\\\b(?:java|ecma)script\\\\b/},converters:{\\\"text script\\\":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter(\\\"script\\\",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type=\\\"GET\\\")}),r.ajaxTransport(\\\"script\\\",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r(\\\"<script>\\\").prop({charset:a.scriptCharset,src:a.url}).on(\\\"load error\\\",c=function(a){b.remove(),c=null,a&&f(\\\"error\\\"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\\\\?(?=&|$)|\\\\?\\\\?/;r.ajaxSetup({jsonp:\\\"callback\\\",jsonpCallback:function(){var a=Tb.pop()||r.expando+\\\"_\\\"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter(\\\"json jsonp\\\",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?\\\"url\\\":\\\"string\\\"==typeof b.data&&0===(b.contentType||\\\"\\\").indexOf(\\\"application/x-www-form-urlencoded\\\")&&Ub.test(b.data)&&\\\"data\\\");if(h||\\\"jsonp\\\"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,\\\"$1\\\"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?\\\"&\\\":\\\"?\\\")+b.jsonp+\\\"=\\\"+e),b.converters[\\\"script json\\\"]=function(){return g||r.error(e+\\\" was not called\\\"),g[0]},b.dataTypes[0]=\\\"json\\\",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),\\\"script\\\"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument(\\\"\\\").body;return a.innerHTML=\\\"<form></form><form></form>\\\",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if(\\\"string\\\"!=typeof a)return[];\\\"boolean\\\"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(\\\"\\\"),e=b.createElement(\\\"base\\\"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(\\\" \\\");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&\\\"object\\\"==typeof b&&(e=\\\"POST\\\"),g.length>0&&r.ajax({url:a,type:e||\\\"GET\\\",dataType:\\\"html\\\",data:b}).done(function(a){f=arguments,g.html(d?r(\\\"<div>\\\").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each([\\\"ajaxStart\\\",\\\"ajaxStop\\\",\\\"ajaxComplete\\\",\\\"ajaxError\\\",\\\"ajaxSuccess\\\",\\\"ajaxSend\\\"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,\\\"position\\\"),l=r(a),m={};\\\"static\\\"===k&&(a.style.position=\\\"relative\\\"),h=l.offset(),f=r.css(a,\\\"top\\\"),i=r.css(a,\\\"left\\\"),j=(\\\"absolute\\\"===k||\\\"fixed\\\"===k)&&(f+i).indexOf(\\\"auto\\\")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),\\\"using\\\"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return\\\"fixed\\\"===r.css(c,\\\"position\\\")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],\\\"html\\\")||(d=a.offset()),d={top:d.top+r.css(a[0],\\\"borderTopWidth\\\",!0),left:d.left+r.css(a[0],\\\"borderLeftWidth\\\",!0)}),{top:b.top-d.top-r.css(c,\\\"marginTop\\\",!0),left:b.left-d.left-r.css(c,\\\"marginLeft\\\",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&\\\"static\\\"===r.css(a,\\\"position\\\"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:\\\"pageXOffset\\\",scrollTop:\\\"pageYOffset\\\"},function(a,b){var c=\\\"pageYOffset\\\"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each([\\\"top\\\",\\\"left\\\"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+\\\"px\\\":c})}),r.each({Height:\\\"height\\\",Width:\\\"width\\\"},function(a,b){r.each({padding:\\\"inner\\\"+a,content:b,\\\"\\\":\\\"outer\\\"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||\\\"boolean\\\"!=typeof e),h=c||(e===!0||f===!0?\\\"margin\\\":\\\"border\\\");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf(\\\"outer\\\")?b[\\\"inner\\\"+a]:b.document.documentElement[\\\"client\\\"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body[\\\"scroll\\\"+a],f[\\\"scroll\\\"+a],b.body[\\\"offset\\\"+a],f[\\\"offset\\\"+a],f[\\\"client\\\"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,\\\"**\\\"):this.off(b,a||\\\"**\\\",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,\\\"function\\\"==typeof define&&define.amd&&define(\\\"jquery\\\",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/jquery/dist/jquery.min.js\n// module id = 1088\n// module chunks = 2","module.exports = \"//! moment.js\\n//! version : 2.18.1\\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\\n//! license : MIT\\n//! momentjs.com\\n!function(a,b){\\\"object\\\"==typeof exports&&\\\"undefined\\\"!=typeof module?module.exports=b():\\\"function\\\"==typeof define&&define.amd?define(b):a.moment=b()}(this,function(){\\\"use strict\\\";function a(){return sd.apply(null,arguments)}function b(a){sd=a}function c(a){return a instanceof Array||\\\"[object Array]\\\"===Object.prototype.toString.call(a)}function d(a){return null!=a&&\\\"[object Object]\\\"===Object.prototype.toString.call(a)}function e(a){var b;for(b in a)return!1;return!0}function f(a){return void 0===a}function g(a){return\\\"number\\\"==typeof a||\\\"[object Number]\\\"===Object.prototype.toString.call(a)}function h(a){return a instanceof Date||\\\"[object Date]\\\"===Object.prototype.toString.call(a)}function i(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function j(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function k(a,b){for(var c in b)j(b,c)&&(a[c]=b[c]);return j(b,\\\"toString\\\")&&(a.toString=b.toString),j(b,\\\"valueOf\\\")&&(a.valueOf=b.valueOf),a}function l(a,b,c,d){return sb(a,b,c,d,!0).utc()}function m(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}}function n(a){return null==a._pf&&(a._pf=m()),a._pf}function o(a){if(null==a._isValid){var b=n(a),c=ud.call(b.parsedDateParts,function(a){return null!=a}),d=!isNaN(a._d.getTime())&&b.overflow<0&&!b.empty&&!b.invalidMonth&&!b.invalidWeekday&&!b.nullInput&&!b.invalidFormat&&!b.userInvalidated&&(!b.meridiem||b.meridiem&&c);if(a._strict&&(d=d&&0===b.charsLeftOver&&0===b.unusedTokens.length&&void 0===b.bigHour),null!=Object.isFrozen&&Object.isFrozen(a))return d;a._isValid=d}return a._isValid}function p(a){var b=l(NaN);return null!=a?k(n(b),a):n(b).userInvalidated=!0,b}function q(a,b){var c,d,e;if(f(b._isAMomentObject)||(a._isAMomentObject=b._isAMomentObject),f(b._i)||(a._i=b._i),f(b._f)||(a._f=b._f),f(b._l)||(a._l=b._l),f(b._strict)||(a._strict=b._strict),f(b._tzm)||(a._tzm=b._tzm),f(b._isUTC)||(a._isUTC=b._isUTC),f(b._offset)||(a._offset=b._offset),f(b._pf)||(a._pf=n(b)),f(b._locale)||(a._locale=b._locale),vd.length>0)for(c=0;c<vd.length;c++)d=vd[c],e=b[d],f(e)||(a[d]=e);return a}function r(b){q(this,b),this._d=new Date(null!=b._d?b._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),wd===!1&&(wd=!0,a.updateOffset(this),wd=!1)}function s(a){return a instanceof r||null!=a&&null!=a._isAMomentObject}function t(a){return a<0?Math.ceil(a)||0:Math.floor(a)}function u(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=t(b)),c}function v(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;d<e;d++)(c&&a[d]!==b[d]||!c&&u(a[d])!==u(b[d]))&&g++;return g+f}function w(b){a.suppressDeprecationWarnings===!1&&\\\"undefined\\\"!=typeof console&&console.warn&&console.warn(\\\"Deprecation warning: \\\"+b)}function x(b,c){var d=!0;return k(function(){if(null!=a.deprecationHandler&&a.deprecationHandler(null,b),d){for(var e,f=[],g=0;g<arguments.length;g++){if(e=\\\"\\\",\\\"object\\\"==typeof arguments[g]){e+=\\\"\\\\n[\\\"+g+\\\"] \\\";for(var h in arguments[0])e+=h+\\\": \\\"+arguments[0][h]+\\\", \\\";e=e.slice(0,-2)}else e=arguments[g];f.push(e)}w(b+\\\"\\\\nArguments: \\\"+Array.prototype.slice.call(f).join(\\\"\\\")+\\\"\\\\n\\\"+(new Error).stack),d=!1}return c.apply(this,arguments)},c)}function y(b,c){null!=a.deprecationHandler&&a.deprecationHandler(b,c),xd[b]||(w(c),xd[b]=!0)}function z(a){return a instanceof Function||\\\"[object Function]\\\"===Object.prototype.toString.call(a)}function A(a){var b,c;for(c in a)b=a[c],z(b)?this[c]=b:this[\\\"_\\\"+c]=b;this._config=a,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+\\\"|\\\"+/\\\\d{1,2}/.source)}function B(a,b){var c,e=k({},a);for(c in b)j(b,c)&&(d(a[c])&&d(b[c])?(e[c]={},k(e[c],a[c]),k(e[c],b[c])):null!=b[c]?e[c]=b[c]:delete e[c]);for(c in a)j(a,c)&&!j(b,c)&&d(a[c])&&(e[c]=k({},e[c]));return e}function C(a){null!=a&&this.set(a)}function D(a,b,c){var d=this._calendar[a]||this._calendar.sameElse;return z(d)?d.call(b,c):d}function E(a){var b=this._longDateFormat[a],c=this._longDateFormat[a.toUpperCase()];return b||!c?b:(this._longDateFormat[a]=c.replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a])}function F(){return this._invalidDate}function G(a){return this._ordinal.replace(\\\"%d\\\",a)}function H(a,b,c,d){var e=this._relativeTime[c];return z(e)?e(a,b,c,d):e.replace(/%d/i,a)}function I(a,b){var c=this._relativeTime[a>0?\\\"future\\\":\\\"past\\\"];return z(c)?c(b):c.replace(/%s/i,b)}function J(a,b){var c=a.toLowerCase();Hd[c]=Hd[c+\\\"s\\\"]=Hd[b]=a}function K(a){return\\\"string\\\"==typeof a?Hd[a]||Hd[a.toLowerCase()]:void 0}function L(a){var b,c,d={};for(c in a)j(a,c)&&(b=K(c),b&&(d[b]=a[c]));return d}function M(a,b){Id[a]=b}function N(a){var b=[];for(var c in a)b.push({unit:c,priority:Id[c]});return b.sort(function(a,b){return a.priority-b.priority}),b}function O(b,c){return function(d){return null!=d?(Q(this,b,d),a.updateOffset(this,c),this):P(this,b)}}function P(a,b){return a.isValid()?a._d[\\\"get\\\"+(a._isUTC?\\\"UTC\\\":\\\"\\\")+b]():NaN}function Q(a,b,c){a.isValid()&&a._d[\\\"set\\\"+(a._isUTC?\\\"UTC\\\":\\\"\\\")+b](c)}function R(a){return a=K(a),z(this[a])?this[a]():this}function S(a,b){if(\\\"object\\\"==typeof a){a=L(a);for(var c=N(a),d=0;d<c.length;d++)this[c[d].unit](a[c[d].unit])}else if(a=K(a),z(this[a]))return this[a](b);return this}function T(a,b,c){var d=\\\"\\\"+Math.abs(a),e=b-d.length,f=a>=0;return(f?c?\\\"+\\\":\\\"\\\":\\\"-\\\")+Math.pow(10,Math.max(0,e)).toString().substr(1)+d}function U(a,b,c,d){var e=d;\\\"string\\\"==typeof d&&(e=function(){return this[d]()}),a&&(Md[a]=e),b&&(Md[b[0]]=function(){return T(e.apply(this,arguments),b[1],b[2])}),c&&(Md[c]=function(){return this.localeData().ordinal(e.apply(this,arguments),a)})}function V(a){return a.match(/\\\\[[\\\\s\\\\S]/)?a.replace(/^\\\\[|\\\\]$/g,\\\"\\\"):a.replace(/\\\\\\\\/g,\\\"\\\")}function W(a){var b,c,d=a.match(Jd);for(b=0,c=d.length;b<c;b++)Md[d[b]]?d[b]=Md[d[b]]:d[b]=V(d[b]);return function(b){var e,f=\\\"\\\";for(e=0;e<c;e++)f+=z(d[e])?d[e].call(b,a):d[e];return f}}function X(a,b){return a.isValid()?(b=Y(b,a.localeData()),Ld[b]=Ld[b]||W(b),Ld[b](a)):a.localeData().invalidDate()}function Y(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Kd.lastIndex=0;d>=0&&Kd.test(a);)a=a.replace(Kd,c),Kd.lastIndex=0,d-=1;return a}function Z(a,b,c){ce[a]=z(b)?b:function(a,d){return a&&c?c:b}}function $(a,b){return j(ce,a)?ce[a](b._strict,b._locale):new RegExp(_(a))}function _(a){return aa(a.replace(\\\"\\\\\\\\\\\",\\\"\\\").replace(/\\\\\\\\(\\\\[)|\\\\\\\\(\\\\])|\\\\[([^\\\\]\\\\[]*)\\\\]|\\\\\\\\(.)/g,function(a,b,c,d,e){return b||c||d||e}))}function aa(a){return a.replace(/[-\\\\/\\\\\\\\^$*+?.()|[\\\\]{}]/g,\\\"\\\\\\\\$&\\\")}function ba(a,b){var c,d=b;for(\\\"string\\\"==typeof a&&(a=[a]),g(b)&&(d=function(a,c){c[b]=u(a)}),c=0;c<a.length;c++)de[a[c]]=d}function ca(a,b){ba(a,function(a,c,d,e){d._w=d._w||{},b(a,d._w,d,e)})}function da(a,b,c){null!=b&&j(de,a)&&de[a](b,c._a,c,a)}function ea(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function fa(a,b){return a?c(this._months)?this._months[a.month()]:this._months[(this._months.isFormat||oe).test(b)?\\\"format\\\":\\\"standalone\\\"][a.month()]:c(this._months)?this._months:this._months.standalone}function ga(a,b){return a?c(this._monthsShort)?this._monthsShort[a.month()]:this._monthsShort[oe.test(b)?\\\"format\\\":\\\"standalone\\\"][a.month()]:c(this._monthsShort)?this._monthsShort:this._monthsShort.standalone}function ha(a,b,c){var d,e,f,g=a.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],d=0;d<12;++d)f=l([2e3,d]),this._shortMonthsParse[d]=this.monthsShort(f,\\\"\\\").toLocaleLowerCase(),this._longMonthsParse[d]=this.months(f,\\\"\\\").toLocaleLowerCase();return c?\\\"MMM\\\"===b?(e=ne.call(this._shortMonthsParse,g),e!==-1?e:null):(e=ne.call(this._longMonthsParse,g),e!==-1?e:null):\\\"MMM\\\"===b?(e=ne.call(this._shortMonthsParse,g),e!==-1?e:(e=ne.call(this._longMonthsParse,g),e!==-1?e:null)):(e=ne.call(this._longMonthsParse,g),e!==-1?e:(e=ne.call(this._shortMonthsParse,g),e!==-1?e:null))}function ia(a,b,c){var d,e,f;if(this._monthsParseExact)return ha.call(this,a,b,c);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;d<12;d++){if(e=l([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp(\\\"^\\\"+this.months(e,\\\"\\\").replace(\\\".\\\",\\\"\\\")+\\\"$\\\",\\\"i\\\"),this._shortMonthsParse[d]=new RegExp(\\\"^\\\"+this.monthsShort(e,\\\"\\\").replace(\\\".\\\",\\\"\\\")+\\\"$\\\",\\\"i\\\")),c||this._monthsParse[d]||(f=\\\"^\\\"+this.months(e,\\\"\\\")+\\\"|^\\\"+this.monthsShort(e,\\\"\\\"),this._monthsParse[d]=new RegExp(f.replace(\\\".\\\",\\\"\\\"),\\\"i\\\")),c&&\\\"MMMM\\\"===b&&this._longMonthsParse[d].test(a))return d;if(c&&\\\"MMM\\\"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}}function ja(a,b){var c;if(!a.isValid())return a;if(\\\"string\\\"==typeof b)if(/^\\\\d+$/.test(b))b=u(b);else if(b=a.localeData().monthsParse(b),!g(b))return a;return c=Math.min(a.date(),ea(a.year(),b)),a._d[\\\"set\\\"+(a._isUTC?\\\"UTC\\\":\\\"\\\")+\\\"Month\\\"](b,c),a}function ka(b){return null!=b?(ja(this,b),a.updateOffset(this,!0),this):P(this,\\\"Month\\\")}function la(){return ea(this.year(),this.month())}function ma(a){return this._monthsParseExact?(j(this,\\\"_monthsRegex\\\")||oa.call(this),a?this._monthsShortStrictRegex:this._monthsShortRegex):(j(this,\\\"_monthsShortRegex\\\")||(this._monthsShortRegex=re),this._monthsShortStrictRegex&&a?this._monthsShortStrictRegex:this._monthsShortRegex)}function na(a){return this._monthsParseExact?(j(this,\\\"_monthsRegex\\\")||oa.call(this),a?this._monthsStrictRegex:this._monthsRegex):(j(this,\\\"_monthsRegex\\\")||(this._monthsRegex=se),this._monthsStrictRegex&&a?this._monthsStrictRegex:this._monthsRegex)}function oa(){function a(a,b){return b.length-a.length}var b,c,d=[],e=[],f=[];for(b=0;b<12;b++)c=l([2e3,b]),d.push(this.monthsShort(c,\\\"\\\")),e.push(this.months(c,\\\"\\\")),f.push(this.months(c,\\\"\\\")),f.push(this.monthsShort(c,\\\"\\\"));for(d.sort(a),e.sort(a),f.sort(a),b=0;b<12;b++)d[b]=aa(d[b]),e[b]=aa(e[b]);for(b=0;b<24;b++)f[b]=aa(f[b]);this._monthsRegex=new RegExp(\\\"^(\\\"+f.join(\\\"|\\\")+\\\")\\\",\\\"i\\\"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp(\\\"^(\\\"+e.join(\\\"|\\\")+\\\")\\\",\\\"i\\\"),this._monthsShortStrictRegex=new RegExp(\\\"^(\\\"+d.join(\\\"|\\\")+\\\")\\\",\\\"i\\\")}function pa(a){return qa(a)?366:365}function qa(a){return a%4===0&&a%100!==0||a%400===0}function ra(){return qa(this.year())}function sa(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return a<100&&a>=0&&isFinite(h.getFullYear())&&h.setFullYear(a),h}function ta(a){var b=new Date(Date.UTC.apply(null,arguments));return a<100&&a>=0&&isFinite(b.getUTCFullYear())&&b.setUTCFullYear(a),b}function ua(a,b,c){var d=7+b-c,e=(7+ta(a,0,d).getUTCDay()-b)%7;return-e+d-1}function va(a,b,c,d,e){var f,g,h=(7+c-d)%7,i=ua(a,d,e),j=1+7*(b-1)+h+i;return j<=0?(f=a-1,g=pa(f)+j):j>pa(a)?(f=a+1,g=j-pa(a)):(f=a,g=j),{year:f,dayOfYear:g}}function wa(a,b,c){var d,e,f=ua(a.year(),b,c),g=Math.floor((a.dayOfYear()-f-1)/7)+1;return g<1?(e=a.year()-1,d=g+xa(e,b,c)):g>xa(a.year(),b,c)?(d=g-xa(a.year(),b,c),e=a.year()+1):(e=a.year(),d=g),{week:d,year:e}}function xa(a,b,c){var d=ua(a,b,c),e=ua(a+1,b,c);return(pa(a)-d+e)/7}function ya(a){return wa(a,this._week.dow,this._week.doy).week}function za(){return this._week.dow}function Aa(){return this._week.doy}function Ba(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),\\\"d\\\")}function Ca(a){var b=wa(this,1,4).week;return null==a?b:this.add(7*(a-b),\\\"d\\\")}function Da(a,b){return\\\"string\\\"!=typeof a?a:isNaN(a)?(a=b.weekdaysParse(a),\\\"number\\\"==typeof a?a:null):parseInt(a,10)}function Ea(a,b){return\\\"string\\\"==typeof a?b.weekdaysParse(a)%7||7:isNaN(a)?null:a}function Fa(a,b){return a?c(this._weekdays)?this._weekdays[a.day()]:this._weekdays[this._weekdays.isFormat.test(b)?\\\"format\\\":\\\"standalone\\\"][a.day()]:c(this._weekdays)?this._weekdays:this._weekdays.standalone}function Ga(a){return a?this._weekdaysShort[a.day()]:this._weekdaysShort}function Ha(a){return a?this._weekdaysMin[a.day()]:this._weekdaysMin}function Ia(a,b,c){var d,e,f,g=a.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],d=0;d<7;++d)f=l([2e3,1]).day(d),this._minWeekdaysParse[d]=this.weekdaysMin(f,\\\"\\\").toLocaleLowerCase(),this._shortWeekdaysParse[d]=this.weekdaysShort(f,\\\"\\\").toLocaleLowerCase(),this._weekdaysParse[d]=this.weekdays(f,\\\"\\\").toLocaleLowerCase();return c?\\\"dddd\\\"===b?(e=ne.call(this._weekdaysParse,g),e!==-1?e:null):\\\"ddd\\\"===b?(e=ne.call(this._shortWeekdaysParse,g),e!==-1?e:null):(e=ne.call(this._minWeekdaysParse,g),e!==-1?e:null):\\\"dddd\\\"===b?(e=ne.call(this._weekdaysParse,g),e!==-1?e:(e=ne.call(this._shortWeekdaysParse,g),e!==-1?e:(e=ne.call(this._minWeekdaysParse,g),e!==-1?e:null))):\\\"ddd\\\"===b?(e=ne.call(this._shortWeekdaysParse,g),e!==-1?e:(e=ne.call(this._weekdaysParse,g),e!==-1?e:(e=ne.call(this._minWeekdaysParse,g),e!==-1?e:null))):(e=ne.call(this._minWeekdaysParse,g),e!==-1?e:(e=ne.call(this._weekdaysParse,g),e!==-1?e:(e=ne.call(this._shortWeekdaysParse,g),e!==-1?e:null)))}function Ja(a,b,c){var d,e,f;if(this._weekdaysParseExact)return Ia.call(this,a,b,c);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),d=0;d<7;d++){if(e=l([2e3,1]).day(d),c&&!this._fullWeekdaysParse[d]&&(this._fullWeekdaysParse[d]=new RegExp(\\\"^\\\"+this.weekdays(e,\\\"\\\").replace(\\\".\\\",\\\".?\\\")+\\\"$\\\",\\\"i\\\"),this._shortWeekdaysParse[d]=new RegExp(\\\"^\\\"+this.weekdaysShort(e,\\\"\\\").replace(\\\".\\\",\\\".?\\\")+\\\"$\\\",\\\"i\\\"),this._minWeekdaysParse[d]=new RegExp(\\\"^\\\"+this.weekdaysMin(e,\\\"\\\").replace(\\\".\\\",\\\".?\\\")+\\\"$\\\",\\\"i\\\")),this._weekdaysParse[d]||(f=\\\"^\\\"+this.weekdays(e,\\\"\\\")+\\\"|^\\\"+this.weekdaysShort(e,\\\"\\\")+\\\"|^\\\"+this.weekdaysMin(e,\\\"\\\"),this._weekdaysParse[d]=new RegExp(f.replace(\\\".\\\",\\\"\\\"),\\\"i\\\")),c&&\\\"dddd\\\"===b&&this._fullWeekdaysParse[d].test(a))return d;if(c&&\\\"ddd\\\"===b&&this._shortWeekdaysParse[d].test(a))return d;if(c&&\\\"dd\\\"===b&&this._minWeekdaysParse[d].test(a))return d;if(!c&&this._weekdaysParse[d].test(a))return d}}function Ka(a){if(!this.isValid())return null!=a?this:NaN;var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=Da(a,this.localeData()),this.add(a-b,\\\"d\\\")):b}function La(a){if(!this.isValid())return null!=a?this:NaN;var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,\\\"d\\\")}function Ma(a){if(!this.isValid())return null!=a?this:NaN;if(null!=a){var b=Ea(a,this.localeData());return this.day(this.day()%7?b:b-7)}return this.day()||7}function Na(a){return this._weekdaysParseExact?(j(this,\\\"_weekdaysRegex\\\")||Qa.call(this),a?this._weekdaysStrictRegex:this._weekdaysRegex):(j(this,\\\"_weekdaysRegex\\\")||(this._weekdaysRegex=ye),this._weekdaysStrictRegex&&a?this._weekdaysStrictRegex:this._weekdaysRegex)}function Oa(a){return this._weekdaysParseExact?(j(this,\\\"_weekdaysRegex\\\")||Qa.call(this),a?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(j(this,\\\"_weekdaysShortRegex\\\")||(this._weekdaysShortRegex=ze),this._weekdaysShortStrictRegex&&a?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)}function Pa(a){return this._weekdaysParseExact?(j(this,\\\"_weekdaysRegex\\\")||Qa.call(this),a?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(j(this,\\\"_weekdaysMinRegex\\\")||(this._weekdaysMinRegex=Ae),this._weekdaysMinStrictRegex&&a?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)}function Qa(){function a(a,b){return b.length-a.length}var b,c,d,e,f,g=[],h=[],i=[],j=[];for(b=0;b<7;b++)c=l([2e3,1]).day(b),d=this.weekdaysMin(c,\\\"\\\"),e=this.weekdaysShort(c,\\\"\\\"),f=this.weekdays(c,\\\"\\\"),g.push(d),h.push(e),i.push(f),j.push(d),j.push(e),j.push(f);for(g.sort(a),h.sort(a),i.sort(a),j.sort(a),b=0;b<7;b++)h[b]=aa(h[b]),i[b]=aa(i[b]),j[b]=aa(j[b]);this._weekdaysRegex=new RegExp(\\\"^(\\\"+j.join(\\\"|\\\")+\\\")\\\",\\\"i\\\"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp(\\\"^(\\\"+i.join(\\\"|\\\")+\\\")\\\",\\\"i\\\"),this._weekdaysShortStrictRegex=new RegExp(\\\"^(\\\"+h.join(\\\"|\\\")+\\\")\\\",\\\"i\\\"),this._weekdaysMinStrictRegex=new RegExp(\\\"^(\\\"+g.join(\\\"|\\\")+\\\")\\\",\\\"i\\\")}function Ra(){return this.hours()%12||12}function Sa(){return this.hours()||24}function Ta(a,b){U(a,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),b)})}function Ua(a,b){return b._meridiemParse}function Va(a){return\\\"p\\\"===(a+\\\"\\\").toLowerCase().charAt(0)}function Wa(a,b,c){return a>11?c?\\\"pm\\\":\\\"PM\\\":c?\\\"am\\\":\\\"AM\\\"}function Xa(a){return a?a.toLowerCase().replace(\\\"_\\\",\\\"-\\\"):a}function Ya(a){for(var b,c,d,e,f=0;f<a.length;){for(e=Xa(a[f]).split(\\\"-\\\"),b=e.length,c=Xa(a[f+1]),c=c?c.split(\\\"-\\\"):null;b>0;){if(d=Za(e.slice(0,b).join(\\\"-\\\")))return d;if(c&&c.length>=b&&v(e,c,!0)>=b-1)break;b--}f++}return null}function Za(a){var b=null;if(!Fe[a]&&\\\"undefined\\\"!=typeof module&&module&&module.exports)try{b=Be._abbr,require(\\\"./locale/\\\"+a),$a(b)}catch(a){}return Fe[a]}function $a(a,b){var c;return a&&(c=f(b)?bb(a):_a(a,b),c&&(Be=c)),Be._abbr}function _a(a,b){if(null!==b){var c=Ee;if(b.abbr=a,null!=Fe[a])y(\\\"defineLocaleOverride\\\",\\\"use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.\\\"),c=Fe[a]._config;else if(null!=b.parentLocale){if(null==Fe[b.parentLocale])return Ge[b.parentLocale]||(Ge[b.parentLocale]=[]),Ge[b.parentLocale].push({name:a,config:b}),null;c=Fe[b.parentLocale]._config}return Fe[a]=new C(B(c,b)),Ge[a]&&Ge[a].forEach(function(a){_a(a.name,a.config)}),$a(a),Fe[a]}return delete Fe[a],null}function ab(a,b){if(null!=b){var c,d=Ee;null!=Fe[a]&&(d=Fe[a]._config),b=B(d,b),c=new C(b),c.parentLocale=Fe[a],Fe[a]=c,$a(a)}else null!=Fe[a]&&(null!=Fe[a].parentLocale?Fe[a]=Fe[a].parentLocale:null!=Fe[a]&&delete Fe[a]);return Fe[a]}function bb(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return Be;if(!c(a)){if(b=Za(a))return b;a=[a]}return Ya(a)}function cb(){return Ad(Fe)}function db(a){var b,c=a._a;return c&&n(a).overflow===-2&&(b=c[fe]<0||c[fe]>11?fe:c[ge]<1||c[ge]>ea(c[ee],c[fe])?ge:c[he]<0||c[he]>24||24===c[he]&&(0!==c[ie]||0!==c[je]||0!==c[ke])?he:c[ie]<0||c[ie]>59?ie:c[je]<0||c[je]>59?je:c[ke]<0||c[ke]>999?ke:-1,n(a)._overflowDayOfYear&&(b<ee||b>ge)&&(b=ge),n(a)._overflowWeeks&&b===-1&&(b=le),n(a)._overflowWeekday&&b===-1&&(b=me),n(a).overflow=b),a}function eb(a){var b,c,d,e,f,g,h=a._i,i=He.exec(h)||Ie.exec(h);if(i){for(n(a).iso=!0,b=0,c=Ke.length;b<c;b++)if(Ke[b][1].exec(i[1])){e=Ke[b][0],d=Ke[b][2]!==!1;break}if(null==e)return void(a._isValid=!1);if(i[3]){for(b=0,c=Le.length;b<c;b++)if(Le[b][1].exec(i[3])){f=(i[2]||\\\" \\\")+Le[b][0];break}if(null==f)return void(a._isValid=!1)}if(!d&&null!=f)return void(a._isValid=!1);if(i[4]){if(!Je.exec(i[4]))return void(a._isValid=!1);g=\\\"Z\\\"}a._f=e+(f||\\\"\\\")+(g||\\\"\\\"),lb(a)}else a._isValid=!1}function fb(a){var b,c,d,e,f,g,h,i,j={\\\" GMT\\\":\\\" +0000\\\",\\\" EDT\\\":\\\" -0400\\\",\\\" EST\\\":\\\" -0500\\\",\\\" CDT\\\":\\\" -0500\\\",\\\" CST\\\":\\\" -0600\\\",\\\" MDT\\\":\\\" -0600\\\",\\\" MST\\\":\\\" -0700\\\",\\\" PDT\\\":\\\" -0700\\\",\\\" PST\\\":\\\" -0800\\\"},k=\\\"YXWVUTSRQPONZABCDEFGHIKLM\\\";if(b=a._i.replace(/\\\\([^\\\\)]*\\\\)|[\\\\n\\\\t]/g,\\\" \\\").replace(/(\\\\s\\\\s+)/g,\\\" \\\").replace(/^\\\\s|\\\\s$/g,\\\"\\\"),c=Ne.exec(b)){if(d=c[1]?\\\"ddd\\\"+(5===c[1].length?\\\", \\\":\\\" \\\"):\\\"\\\",e=\\\"D MMM \\\"+(c[2].length>10?\\\"YYYY \\\":\\\"YY \\\"),f=\\\"HH:mm\\\"+(c[4]?\\\":ss\\\":\\\"\\\"),c[1]){var l=new Date(c[2]),m=[\\\"Sun\\\",\\\"Mon\\\",\\\"Tue\\\",\\\"Wed\\\",\\\"Thu\\\",\\\"Fri\\\",\\\"Sat\\\"][l.getDay()];if(c[1].substr(0,3)!==m)return n(a).weekdayMismatch=!0,void(a._isValid=!1)}switch(c[5].length){case 2:0===i?h=\\\" +0000\\\":(i=k.indexOf(c[5][1].toUpperCase())-12,h=(i<0?\\\" -\\\":\\\" +\\\")+(\\\"\\\"+i).replace(/^-?/,\\\"0\\\").match(/..$/)[0]+\\\"00\\\");break;case 4:h=j[c[5]];break;default:h=j[\\\" GMT\\\"]}c[5]=h,a._i=c.splice(1).join(\\\"\\\"),g=\\\" ZZ\\\",a._f=d+e+f+g,lb(a),n(a).rfc2822=!0}else a._isValid=!1}function gb(b){var c=Me.exec(b._i);return null!==c?void(b._d=new Date(+c[1])):(eb(b),void(b._isValid===!1&&(delete b._isValid,fb(b),b._isValid===!1&&(delete b._isValid,a.createFromInputFallback(b)))))}function hb(a,b,c){return null!=a?a:null!=b?b:c}function ib(b){var c=new Date(a.now());return b._useUTC?[c.getUTCFullYear(),c.getUTCMonth(),c.getUTCDate()]:[c.getFullYear(),c.getMonth(),c.getDate()]}function jb(a){var b,c,d,e,f=[];if(!a._d){for(d=ib(a),a._w&&null==a._a[ge]&&null==a._a[fe]&&kb(a),null!=a._dayOfYear&&(e=hb(a._a[ee],d[ee]),(a._dayOfYear>pa(e)||0===a._dayOfYear)&&(n(a)._overflowDayOfYear=!0),c=ta(e,0,a._dayOfYear),a._a[fe]=c.getUTCMonth(),a._a[ge]=c.getUTCDate()),b=0;b<3&&null==a._a[b];++b)a._a[b]=f[b]=d[b];for(;b<7;b++)a._a[b]=f[b]=null==a._a[b]?2===b?1:0:a._a[b];24===a._a[he]&&0===a._a[ie]&&0===a._a[je]&&0===a._a[ke]&&(a._nextDay=!0,a._a[he]=0),a._d=(a._useUTC?ta:sa).apply(null,f),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[he]=24)}}function kb(a){var b,c,d,e,f,g,h,i;if(b=a._w,null!=b.GG||null!=b.W||null!=b.E)f=1,g=4,c=hb(b.GG,a._a[ee],wa(tb(),1,4).year),d=hb(b.W,1),e=hb(b.E,1),(e<1||e>7)&&(i=!0);else{f=a._locale._week.dow,g=a._locale._week.doy;var j=wa(tb(),f,g);c=hb(b.gg,a._a[ee],j.year),d=hb(b.w,j.week),null!=b.d?(e=b.d,(e<0||e>6)&&(i=!0)):null!=b.e?(e=b.e+f,(b.e<0||b.e>6)&&(i=!0)):e=f}d<1||d>xa(c,f,g)?n(a)._overflowWeeks=!0:null!=i?n(a)._overflowWeekday=!0:(h=va(c,d,e,f,g),a._a[ee]=h.year,a._dayOfYear=h.dayOfYear)}function lb(b){if(b._f===a.ISO_8601)return void eb(b);if(b._f===a.RFC_2822)return void fb(b);b._a=[],n(b).empty=!0;var c,d,e,f,g,h=\\\"\\\"+b._i,i=h.length,j=0;for(e=Y(b._f,b._locale).match(Jd)||[],c=0;c<e.length;c++)f=e[c],d=(h.match($(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&n(b).unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),j+=d.length),Md[f]?(d?n(b).empty=!1:n(b).unusedTokens.push(f),da(f,d,b)):b._strict&&!d&&n(b).unusedTokens.push(f);n(b).charsLeftOver=i-j,h.length>0&&n(b).unusedInput.push(h),b._a[he]<=12&&n(b).bigHour===!0&&b._a[he]>0&&(n(b).bigHour=void 0),n(b).parsedDateParts=b._a.slice(0),n(b).meridiem=b._meridiem,b._a[he]=mb(b._locale,b._a[he],b._meridiem),jb(b),db(b)}function mb(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&b<12&&(b+=12),d||12!==b||(b=0),b):b}function nb(a){var b,c,d,e,f;if(0===a._f.length)return n(a).invalidFormat=!0,void(a._d=new Date(NaN));for(e=0;e<a._f.length;e++)f=0,b=q({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._f=a._f[e],lb(b),o(b)&&(f+=n(b).charsLeftOver,f+=10*n(b).unusedTokens.length,n(b).score=f,(null==d||f<d)&&(d=f,c=b));k(a,c||b)}function ob(a){if(!a._d){var b=L(a._i);a._a=i([b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],function(a){return a&&parseInt(a,10)}),jb(a)}}function pb(a){var b=new r(db(qb(a)));return b._nextDay&&(b.add(1,\\\"d\\\"),b._nextDay=void 0),b}function qb(a){var b=a._i,d=a._f;return a._locale=a._locale||bb(a._l),null===b||void 0===d&&\\\"\\\"===b?p({nullInput:!0}):(\\\"string\\\"==typeof b&&(a._i=b=a._locale.preparse(b)),s(b)?new r(db(b)):(h(b)?a._d=b:c(d)?nb(a):d?lb(a):rb(a),o(a)||(a._d=null),a))}function rb(b){var e=b._i;f(e)?b._d=new Date(a.now()):h(e)?b._d=new Date(e.valueOf()):\\\"string\\\"==typeof e?gb(b):c(e)?(b._a=i(e.slice(0),function(a){return parseInt(a,10)}),jb(b)):d(e)?ob(b):g(e)?b._d=new Date(e):a.createFromInputFallback(b)}function sb(a,b,f,g,h){var i={};return f!==!0&&f!==!1||(g=f,f=void 0),(d(a)&&e(a)||c(a)&&0===a.length)&&(a=void 0),i._isAMomentObject=!0,i._useUTC=i._isUTC=h,i._l=f,i._i=a,i._f=b,i._strict=g,pb(i)}function tb(a,b,c,d){return sb(a,b,c,d,!1)}function ub(a,b){var d,e;if(1===b.length&&c(b[0])&&(b=b[0]),!b.length)return tb();for(d=b[0],e=1;e<b.length;++e)b[e].isValid()&&!b[e][a](d)||(d=b[e]);return d}function vb(){var a=[].slice.call(arguments,0);return ub(\\\"isBefore\\\",a)}function wb(){var a=[].slice.call(arguments,0);return ub(\\\"isAfter\\\",a)}function xb(a){for(var b in a)if(Re.indexOf(b)===-1||null!=a[b]&&isNaN(a[b]))return!1;for(var c=!1,d=0;d<Re.length;++d)if(a[Re[d]]){if(c)return!1;parseFloat(a[Re[d]])!==u(a[Re[d]])&&(c=!0)}return!0}function yb(){return this._isValid}function zb(){return Sb(NaN)}function Ab(a){var b=L(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._isValid=xb(b),this._milliseconds=+k+1e3*j+6e4*i+1e3*h*60*60,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=bb(),this._bubble()}function Bb(a){return a instanceof Ab}function Cb(a){return a<0?Math.round(-1*a)*-1:Math.round(a)}function Db(a,b){U(a,0,0,function(){var a=this.utcOffset(),c=\\\"+\\\";return a<0&&(a=-a,c=\\\"-\\\"),c+T(~~(a/60),2)+b+T(~~a%60,2)})}function Eb(a,b){var c=(b||\\\"\\\").match(a);if(null===c)return null;var d=c[c.length-1]||[],e=(d+\\\"\\\").match(Se)||[\\\"-\\\",0,0],f=+(60*e[1])+u(e[2]);return 0===f?0:\\\"+\\\"===e[0]?f:-f}function Fb(b,c){var d,e;return c._isUTC?(d=c.clone(),e=(s(b)||h(b)?b.valueOf():tb(b).valueOf())-d.valueOf(),d._d.setTime(d._d.valueOf()+e),a.updateOffset(d,!1),d):tb(b).local()}function Gb(a){return 15*-Math.round(a._d.getTimezoneOffset()/15)}function Hb(b,c,d){var e,f=this._offset||0;if(!this.isValid())return null!=b?this:NaN;if(null!=b){if(\\\"string\\\"==typeof b){if(b=Eb(_d,b),null===b)return this}else Math.abs(b)<16&&!d&&(b=60*b);return!this._isUTC&&c&&(e=Gb(this)),this._offset=b,this._isUTC=!0,null!=e&&this.add(e,\\\"m\\\"),f!==b&&(!c||this._changeInProgress?Xb(this,Sb(b-f,\\\"m\\\"),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?f:Gb(this)}function Ib(a,b){return null!=a?(\\\"string\\\"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}function Jb(a){return this.utcOffset(0,a)}function Kb(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(Gb(this),\\\"m\\\")),this}function Lb(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if(\\\"string\\\"==typeof this._i){var a=Eb($d,this._i);null!=a?this.utcOffset(a):this.utcOffset(0,!0)}return this}function Mb(a){return!!this.isValid()&&(a=a?tb(a).utcOffset():0,(this.utcOffset()-a)%60===0)}function Nb(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Ob(){if(!f(this._isDSTShifted))return this._isDSTShifted;var a={};if(q(a,this),a=qb(a),a._a){var b=a._isUTC?l(a._a):tb(a._a);this._isDSTShifted=this.isValid()&&v(a._a,b.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted}function Pb(){return!!this.isValid()&&!this._isUTC}function Qb(){return!!this.isValid()&&this._isUTC}function Rb(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}function Sb(a,b){var c,d,e,f=a,h=null;return Bb(a)?f={ms:a._milliseconds,d:a._days,M:a._months}:g(a)?(f={},b?f[b]=a:f.milliseconds=a):(h=Te.exec(a))?(c=\\\"-\\\"===h[1]?-1:1,f={y:0,d:u(h[ge])*c,h:u(h[he])*c,m:u(h[ie])*c,s:u(h[je])*c,ms:u(Cb(1e3*h[ke]))*c}):(h=Ue.exec(a))?(c=\\\"-\\\"===h[1]?-1:1,f={y:Tb(h[2],c),M:Tb(h[3],c),w:Tb(h[4],c),d:Tb(h[5],c),h:Tb(h[6],c),m:Tb(h[7],c),s:Tb(h[8],c)}):null==f?f={}:\\\"object\\\"==typeof f&&(\\\"from\\\"in f||\\\"to\\\"in f)&&(e=Vb(tb(f.from),tb(f.to)),f={},f.ms=e.milliseconds,f.M=e.months),d=new Ab(f),Bb(a)&&j(a,\\\"_locale\\\")&&(d._locale=a._locale),d}function Tb(a,b){var c=a&&parseFloat(a.replace(\\\",\\\",\\\".\\\"));return(isNaN(c)?0:c)*b}function Ub(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,\\\"M\\\").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,\\\"M\\\"),c}function Vb(a,b){var c;return a.isValid()&&b.isValid()?(b=Fb(b,a),a.isBefore(b)?c=Ub(a,b):(c=Ub(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c):{milliseconds:0,months:0}}function Wb(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(y(b,\\\"moment().\\\"+b+\\\"(period, number) is deprecated. Please use moment().\\\"+b+\\\"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.\\\"),f=c,c=d,d=f),c=\\\"string\\\"==typeof c?+c:c,e=Sb(c,d),Xb(this,e,a),this}}function Xb(b,c,d,e){var f=c._milliseconds,g=Cb(c._days),h=Cb(c._months);b.isValid()&&(e=null==e||e,f&&b._d.setTime(b._d.valueOf()+f*d),g&&Q(b,\\\"Date\\\",P(b,\\\"Date\\\")+g*d),h&&ja(b,P(b,\\\"Month\\\")+h*d),e&&a.updateOffset(b,g||h))}function Yb(a,b){var c=a.diff(b,\\\"days\\\",!0);return c<-6?\\\"sameElse\\\":c<-1?\\\"lastWeek\\\":c<0?\\\"lastDay\\\":c<1?\\\"sameDay\\\":c<2?\\\"nextDay\\\":c<7?\\\"nextWeek\\\":\\\"sameElse\\\"}function Zb(b,c){var d=b||tb(),e=Fb(d,this).startOf(\\\"day\\\"),f=a.calendarFormat(this,e)||\\\"sameElse\\\",g=c&&(z(c[f])?c[f].call(this,d):c[f]);return this.format(g||this.localeData().calendar(f,this,tb(d)))}function $b(){return new r(this)}function _b(a,b){var c=s(a)?a:tb(a);return!(!this.isValid()||!c.isValid())&&(b=K(f(b)?\\\"millisecond\\\":b),\\\"millisecond\\\"===b?this.valueOf()>c.valueOf():c.valueOf()<this.clone().startOf(b).valueOf())}function ac(a,b){var c=s(a)?a:tb(a);return!(!this.isValid()||!c.isValid())&&(b=K(f(b)?\\\"millisecond\\\":b),\\\"millisecond\\\"===b?this.valueOf()<c.valueOf():this.clone().endOf(b).valueOf()<c.valueOf())}function bc(a,b,c,d){return d=d||\\\"()\\\",(\\\"(\\\"===d[0]?this.isAfter(a,c):!this.isBefore(a,c))&&(\\\")\\\"===d[1]?this.isBefore(b,c):!this.isAfter(b,c))}function cc(a,b){var c,d=s(a)?a:tb(a);return!(!this.isValid()||!d.isValid())&&(b=K(b||\\\"millisecond\\\"),\\\"millisecond\\\"===b?this.valueOf()===d.valueOf():(c=d.valueOf(),this.clone().startOf(b).valueOf()<=c&&c<=this.clone().endOf(b).valueOf()))}function dc(a,b){return this.isSame(a,b)||this.isAfter(a,b)}function ec(a,b){return this.isSame(a,b)||this.isBefore(a,b)}function fc(a,b,c){var d,e,f,g;return this.isValid()?(d=Fb(a,this),d.isValid()?(e=6e4*(d.utcOffset()-this.utcOffset()),b=K(b),\\\"year\\\"===b||\\\"month\\\"===b||\\\"quarter\\\"===b?(g=gc(this,d),\\\"quarter\\\"===b?g/=3:\\\"year\\\"===b&&(g/=12)):(f=this-d,g=\\\"second\\\"===b?f/1e3:\\\"minute\\\"===b?f/6e4:\\\"hour\\\"===b?f/36e5:\\\"day\\\"===b?(f-e)/864e5:\\\"week\\\"===b?(f-e)/6048e5:f),c?g:t(g)):NaN):NaN}function gc(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,\\\"months\\\");return b-f<0?(c=a.clone().add(e-1,\\\"months\\\"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,\\\"months\\\"),d=(b-f)/(c-f)),-(e+d)||0}function hc(){return this.clone().locale(\\\"en\\\").format(\\\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\\\")}function ic(){if(!this.isValid())return null;var a=this.clone().utc();return a.year()<0||a.year()>9999?X(a,\\\"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\\\"):z(Date.prototype.toISOString)?this.toDate().toISOString():X(a,\\\"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\\\")}function jc(){if(!this.isValid())return\\\"moment.invalid(/* \\\"+this._i+\\\" */)\\\";var a=\\\"moment\\\",b=\\\"\\\";this.isLocal()||(a=0===this.utcOffset()?\\\"moment.utc\\\":\\\"moment.parseZone\\\",b=\\\"Z\\\");var c=\\\"[\\\"+a+'(\\\"]',d=0<=this.year()&&this.year()<=9999?\\\"YYYY\\\":\\\"YYYYYY\\\",e=\\\"-MM-DD[T]HH:mm:ss.SSS\\\",f=b+'[\\\")]';return this.format(c+d+e+f)}function kc(b){b||(b=this.isUtc()?a.defaultFormatUtc:a.defaultFormat);var c=X(this,b);return this.localeData().postformat(c)}function lc(a,b){return this.isValid()&&(s(a)&&a.isValid()||tb(a).isValid())?Sb({to:this,from:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function mc(a){return this.from(tb(),a)}function nc(a,b){return this.isValid()&&(s(a)&&a.isValid()||tb(a).isValid())?Sb({from:this,to:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function oc(a){return this.to(tb(),a)}function pc(a){var b;return void 0===a?this._locale._abbr:(b=bb(a),null!=b&&(this._locale=b),this)}function qc(){return this._locale}function rc(a){switch(a=K(a)){case\\\"year\\\":this.month(0);case\\\"quarter\\\":case\\\"month\\\":this.date(1);case\\\"week\\\":case\\\"isoWeek\\\":case\\\"day\\\":case\\\"date\\\":this.hours(0);case\\\"hour\\\":this.minutes(0);case\\\"minute\\\":this.seconds(0);case\\\"second\\\":this.milliseconds(0)}return\\\"week\\\"===a&&this.weekday(0),\\\"isoWeek\\\"===a&&this.isoWeekday(1),\\\"quarter\\\"===a&&this.month(3*Math.floor(this.month()/3)),this}function sc(a){return a=K(a),void 0===a||\\\"millisecond\\\"===a?this:(\\\"date\\\"===a&&(a=\\\"day\\\"),this.startOf(a).add(1,\\\"isoWeek\\\"===a?\\\"week\\\":a).subtract(1,\\\"ms\\\"))}function tc(){return this._d.valueOf()-6e4*(this._offset||0)}function uc(){return Math.floor(this.valueOf()/1e3)}function vc(){return new Date(this.valueOf())}function wc(){var a=this;return[a.year(),a.month(),a.date(),a.hour(),a.minute(),a.second(),a.millisecond()]}function xc(){var a=this;return{years:a.year(),months:a.month(),date:a.date(),hours:a.hours(),minutes:a.minutes(),seconds:a.seconds(),milliseconds:a.milliseconds()}}function yc(){return this.isValid()?this.toISOString():null}function zc(){return o(this)}function Ac(){\\nreturn k({},n(this))}function Bc(){return n(this).overflow}function Cc(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function Dc(a,b){U(0,[a,a.length],0,b)}function Ec(a){return Ic.call(this,a,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function Fc(a){return Ic.call(this,a,this.isoWeek(),this.isoWeekday(),1,4)}function Gc(){return xa(this.year(),1,4)}function Hc(){var a=this.localeData()._week;return xa(this.year(),a.dow,a.doy)}function Ic(a,b,c,d,e){var f;return null==a?wa(this,d,e).year:(f=xa(a,d,e),b>f&&(b=f),Jc.call(this,a,b,c,d,e))}function Jc(a,b,c,d,e){var f=va(a,b,c,d,e),g=ta(f.year,0,f.dayOfYear);return this.year(g.getUTCFullYear()),this.month(g.getUTCMonth()),this.date(g.getUTCDate()),this}function Kc(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)}function Lc(a){var b=Math.round((this.clone().startOf(\\\"day\\\")-this.clone().startOf(\\\"year\\\"))/864e5)+1;return null==a?b:this.add(a-b,\\\"d\\\")}function Mc(a,b){b[ke]=u(1e3*(\\\"0.\\\"+a))}function Nc(){return this._isUTC?\\\"UTC\\\":\\\"\\\"}function Oc(){return this._isUTC?\\\"Coordinated Universal Time\\\":\\\"\\\"}function Pc(a){return tb(1e3*a)}function Qc(){return tb.apply(null,arguments).parseZone()}function Rc(a){return a}function Sc(a,b,c,d){var e=bb(),f=l().set(d,b);return e[c](f,a)}function Tc(a,b,c){if(g(a)&&(b=a,a=void 0),a=a||\\\"\\\",null!=b)return Sc(a,b,c,\\\"month\\\");var d,e=[];for(d=0;d<12;d++)e[d]=Sc(a,d,c,\\\"month\\\");return e}function Uc(a,b,c,d){\\\"boolean\\\"==typeof a?(g(b)&&(c=b,b=void 0),b=b||\\\"\\\"):(b=a,c=b,a=!1,g(b)&&(c=b,b=void 0),b=b||\\\"\\\");var e=bb(),f=a?e._week.dow:0;if(null!=c)return Sc(b,(c+f)%7,d,\\\"day\\\");var h,i=[];for(h=0;h<7;h++)i[h]=Sc(b,(h+f)%7,d,\\\"day\\\");return i}function Vc(a,b){return Tc(a,b,\\\"months\\\")}function Wc(a,b){return Tc(a,b,\\\"monthsShort\\\")}function Xc(a,b,c){return Uc(a,b,c,\\\"weekdays\\\")}function Yc(a,b,c){return Uc(a,b,c,\\\"weekdaysShort\\\")}function Zc(a,b,c){return Uc(a,b,c,\\\"weekdaysMin\\\")}function $c(){var a=this._data;return this._milliseconds=df(this._milliseconds),this._days=df(this._days),this._months=df(this._months),a.milliseconds=df(a.milliseconds),a.seconds=df(a.seconds),a.minutes=df(a.minutes),a.hours=df(a.hours),a.months=df(a.months),a.years=df(a.years),this}function _c(a,b,c,d){var e=Sb(b,c);return a._milliseconds+=d*e._milliseconds,a._days+=d*e._days,a._months+=d*e._months,a._bubble()}function ad(a,b){return _c(this,a,b,1)}function bd(a,b){return _c(this,a,b,-1)}function cd(a){return a<0?Math.floor(a):Math.ceil(a)}function dd(){var a,b,c,d,e,f=this._milliseconds,g=this._days,h=this._months,i=this._data;return f>=0&&g>=0&&h>=0||f<=0&&g<=0&&h<=0||(f+=864e5*cd(fd(h)+g),g=0,h=0),i.milliseconds=f%1e3,a=t(f/1e3),i.seconds=a%60,b=t(a/60),i.minutes=b%60,c=t(b/60),i.hours=c%24,g+=t(c/24),e=t(ed(g)),h+=e,g-=cd(fd(e)),d=t(h/12),h%=12,i.days=g,i.months=h,i.years=d,this}function ed(a){return 4800*a/146097}function fd(a){return 146097*a/4800}function gd(a){if(!this.isValid())return NaN;var b,c,d=this._milliseconds;if(a=K(a),\\\"month\\\"===a||\\\"year\\\"===a)return b=this._days+d/864e5,c=this._months+ed(b),\\\"month\\\"===a?c:c/12;switch(b=this._days+Math.round(fd(this._months)),a){case\\\"week\\\":return b/7+d/6048e5;case\\\"day\\\":return b+d/864e5;case\\\"hour\\\":return 24*b+d/36e5;case\\\"minute\\\":return 1440*b+d/6e4;case\\\"second\\\":return 86400*b+d/1e3;case\\\"millisecond\\\":return Math.floor(864e5*b)+d;default:throw new Error(\\\"Unknown unit \\\"+a)}}function hd(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*u(this._months/12):NaN}function id(a){return function(){return this.as(a)}}function jd(a){return a=K(a),this.isValid()?this[a+\\\"s\\\"]():NaN}function kd(a){return function(){return this.isValid()?this._data[a]:NaN}}function ld(){return t(this.days()/7)}function md(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function nd(a,b,c){var d=Sb(a).abs(),e=uf(d.as(\\\"s\\\")),f=uf(d.as(\\\"m\\\")),g=uf(d.as(\\\"h\\\")),h=uf(d.as(\\\"d\\\")),i=uf(d.as(\\\"M\\\")),j=uf(d.as(\\\"y\\\")),k=e<=vf.ss&&[\\\"s\\\",e]||e<vf.s&&[\\\"ss\\\",e]||f<=1&&[\\\"m\\\"]||f<vf.m&&[\\\"mm\\\",f]||g<=1&&[\\\"h\\\"]||g<vf.h&&[\\\"hh\\\",g]||h<=1&&[\\\"d\\\"]||h<vf.d&&[\\\"dd\\\",h]||i<=1&&[\\\"M\\\"]||i<vf.M&&[\\\"MM\\\",i]||j<=1&&[\\\"y\\\"]||[\\\"yy\\\",j];return k[2]=b,k[3]=+a>0,k[4]=c,md.apply(null,k)}function od(a){return void 0===a?uf:\\\"function\\\"==typeof a&&(uf=a,!0)}function pd(a,b){return void 0!==vf[a]&&(void 0===b?vf[a]:(vf[a]=b,\\\"s\\\"===a&&(vf.ss=b-1),!0))}function qd(a){if(!this.isValid())return this.localeData().invalidDate();var b=this.localeData(),c=nd(this,!a,b);return a&&(c=b.pastFuture(+this,c)),b.postformat(c)}function rd(){if(!this.isValid())return this.localeData().invalidDate();var a,b,c,d=wf(this._milliseconds)/1e3,e=wf(this._days),f=wf(this._months);a=t(d/60),b=t(a/60),d%=60,a%=60,c=t(f/12),f%=12;var g=c,h=f,i=e,j=b,k=a,l=d,m=this.asSeconds();return m?(m<0?\\\"-\\\":\\\"\\\")+\\\"P\\\"+(g?g+\\\"Y\\\":\\\"\\\")+(h?h+\\\"M\\\":\\\"\\\")+(i?i+\\\"D\\\":\\\"\\\")+(j||k||l?\\\"T\\\":\\\"\\\")+(j?j+\\\"H\\\":\\\"\\\")+(k?k+\\\"M\\\":\\\"\\\")+(l?l+\\\"S\\\":\\\"\\\"):\\\"P0D\\\"}var sd,td;td=Array.prototype.some?Array.prototype.some:function(a){for(var b=Object(this),c=b.length>>>0,d=0;d<c;d++)if(d in b&&a.call(this,b[d],d,b))return!0;return!1};var ud=td,vd=a.momentProperties=[],wd=!1,xd={};a.suppressDeprecationWarnings=!1,a.deprecationHandler=null;var yd;yd=Object.keys?Object.keys:function(a){var b,c=[];for(b in a)j(a,b)&&c.push(b);return c};var zd,Ad=yd,Bd={sameDay:\\\"[Today at] LT\\\",nextDay:\\\"[Tomorrow at] LT\\\",nextWeek:\\\"dddd [at] LT\\\",lastDay:\\\"[Yesterday at] LT\\\",lastWeek:\\\"[Last] dddd [at] LT\\\",sameElse:\\\"L\\\"},Cd={LTS:\\\"h:mm:ss A\\\",LT:\\\"h:mm A\\\",L:\\\"MM/DD/YYYY\\\",LL:\\\"MMMM D, YYYY\\\",LLL:\\\"MMMM D, YYYY h:mm A\\\",LLLL:\\\"dddd, MMMM D, YYYY h:mm A\\\"},Dd=\\\"Invalid date\\\",Ed=\\\"%d\\\",Fd=/\\\\d{1,2}/,Gd={future:\\\"in %s\\\",past:\\\"%s ago\\\",s:\\\"a few seconds\\\",ss:\\\"%d seconds\\\",m:\\\"a minute\\\",mm:\\\"%d minutes\\\",h:\\\"an hour\\\",hh:\\\"%d hours\\\",d:\\\"a day\\\",dd:\\\"%d days\\\",M:\\\"a month\\\",MM:\\\"%d months\\\",y:\\\"a year\\\",yy:\\\"%d years\\\"},Hd={},Id={},Jd=/(\\\\[[^\\\\[]*\\\\])|(\\\\\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Kd=/(\\\\[[^\\\\[]*\\\\])|(\\\\\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Ld={},Md={},Nd=/\\\\d/,Od=/\\\\d\\\\d/,Pd=/\\\\d{3}/,Qd=/\\\\d{4}/,Rd=/[+-]?\\\\d{6}/,Sd=/\\\\d\\\\d?/,Td=/\\\\d\\\\d\\\\d\\\\d?/,Ud=/\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d?/,Vd=/\\\\d{1,3}/,Wd=/\\\\d{1,4}/,Xd=/[+-]?\\\\d{1,6}/,Yd=/\\\\d+/,Zd=/[+-]?\\\\d+/,$d=/Z|[+-]\\\\d\\\\d:?\\\\d\\\\d/gi,_d=/Z|[+-]\\\\d\\\\d(?::?\\\\d\\\\d)?/gi,ae=/[+-]?\\\\d+(\\\\.\\\\d{1,3})?/,be=/[0-9]*['a-z\\\\u00A0-\\\\u05FF\\\\u0700-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]+|[\\\\u0600-\\\\u06FF\\\\/]+(\\\\s*?[\\\\u0600-\\\\u06FF]+){1,2}/i,ce={},de={},ee=0,fe=1,ge=2,he=3,ie=4,je=5,ke=6,le=7,me=8;zd=Array.prototype.indexOf?Array.prototype.indexOf:function(a){var b;for(b=0;b<this.length;++b)if(this[b]===a)return b;return-1};var ne=zd;U(\\\"M\\\",[\\\"MM\\\",2],\\\"Mo\\\",function(){return this.month()+1}),U(\\\"MMM\\\",0,0,function(a){return this.localeData().monthsShort(this,a)}),U(\\\"MMMM\\\",0,0,function(a){return this.localeData().months(this,a)}),J(\\\"month\\\",\\\"M\\\"),M(\\\"month\\\",8),Z(\\\"M\\\",Sd),Z(\\\"MM\\\",Sd,Od),Z(\\\"MMM\\\",function(a,b){return b.monthsShortRegex(a)}),Z(\\\"MMMM\\\",function(a,b){return b.monthsRegex(a)}),ba([\\\"M\\\",\\\"MM\\\"],function(a,b){b[fe]=u(a)-1}),ba([\\\"MMM\\\",\\\"MMMM\\\"],function(a,b,c,d){var e=c._locale.monthsParse(a,d,c._strict);null!=e?b[fe]=e:n(c).invalidMonth=a});var oe=/D[oD]?(\\\\[[^\\\\[\\\\]]*\\\\]|\\\\s)+MMMM?/,pe=\\\"January_February_March_April_May_June_July_August_September_October_November_December\\\".split(\\\"_\\\"),qe=\\\"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\\\".split(\\\"_\\\"),re=be,se=be;U(\\\"Y\\\",0,0,function(){var a=this.year();return a<=9999?\\\"\\\"+a:\\\"+\\\"+a}),U(0,[\\\"YY\\\",2],0,function(){return this.year()%100}),U(0,[\\\"YYYY\\\",4],0,\\\"year\\\"),U(0,[\\\"YYYYY\\\",5],0,\\\"year\\\"),U(0,[\\\"YYYYYY\\\",6,!0],0,\\\"year\\\"),J(\\\"year\\\",\\\"y\\\"),M(\\\"year\\\",1),Z(\\\"Y\\\",Zd),Z(\\\"YY\\\",Sd,Od),Z(\\\"YYYY\\\",Wd,Qd),Z(\\\"YYYYY\\\",Xd,Rd),Z(\\\"YYYYYY\\\",Xd,Rd),ba([\\\"YYYYY\\\",\\\"YYYYYY\\\"],ee),ba(\\\"YYYY\\\",function(b,c){c[ee]=2===b.length?a.parseTwoDigitYear(b):u(b)}),ba(\\\"YY\\\",function(b,c){c[ee]=a.parseTwoDigitYear(b)}),ba(\\\"Y\\\",function(a,b){b[ee]=parseInt(a,10)}),a.parseTwoDigitYear=function(a){return u(a)+(u(a)>68?1900:2e3)};var te=O(\\\"FullYear\\\",!0);U(\\\"w\\\",[\\\"ww\\\",2],\\\"wo\\\",\\\"week\\\"),U(\\\"W\\\",[\\\"WW\\\",2],\\\"Wo\\\",\\\"isoWeek\\\"),J(\\\"week\\\",\\\"w\\\"),J(\\\"isoWeek\\\",\\\"W\\\"),M(\\\"week\\\",5),M(\\\"isoWeek\\\",5),Z(\\\"w\\\",Sd),Z(\\\"ww\\\",Sd,Od),Z(\\\"W\\\",Sd),Z(\\\"WW\\\",Sd,Od),ca([\\\"w\\\",\\\"ww\\\",\\\"W\\\",\\\"WW\\\"],function(a,b,c,d){b[d.substr(0,1)]=u(a)});var ue={dow:0,doy:6};U(\\\"d\\\",0,\\\"do\\\",\\\"day\\\"),U(\\\"dd\\\",0,0,function(a){return this.localeData().weekdaysMin(this,a)}),U(\\\"ddd\\\",0,0,function(a){return this.localeData().weekdaysShort(this,a)}),U(\\\"dddd\\\",0,0,function(a){return this.localeData().weekdays(this,a)}),U(\\\"e\\\",0,0,\\\"weekday\\\"),U(\\\"E\\\",0,0,\\\"isoWeekday\\\"),J(\\\"day\\\",\\\"d\\\"),J(\\\"weekday\\\",\\\"e\\\"),J(\\\"isoWeekday\\\",\\\"E\\\"),M(\\\"day\\\",11),M(\\\"weekday\\\",11),M(\\\"isoWeekday\\\",11),Z(\\\"d\\\",Sd),Z(\\\"e\\\",Sd),Z(\\\"E\\\",Sd),Z(\\\"dd\\\",function(a,b){return b.weekdaysMinRegex(a)}),Z(\\\"ddd\\\",function(a,b){return b.weekdaysShortRegex(a)}),Z(\\\"dddd\\\",function(a,b){return b.weekdaysRegex(a)}),ca([\\\"dd\\\",\\\"ddd\\\",\\\"dddd\\\"],function(a,b,c,d){var e=c._locale.weekdaysParse(a,d,c._strict);null!=e?b.d=e:n(c).invalidWeekday=a}),ca([\\\"d\\\",\\\"e\\\",\\\"E\\\"],function(a,b,c,d){b[d]=u(a)});var ve=\\\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\\\".split(\\\"_\\\"),we=\\\"Sun_Mon_Tue_Wed_Thu_Fri_Sat\\\".split(\\\"_\\\"),xe=\\\"Su_Mo_Tu_We_Th_Fr_Sa\\\".split(\\\"_\\\"),ye=be,ze=be,Ae=be;U(\\\"H\\\",[\\\"HH\\\",2],0,\\\"hour\\\"),U(\\\"h\\\",[\\\"hh\\\",2],0,Ra),U(\\\"k\\\",[\\\"kk\\\",2],0,Sa),U(\\\"hmm\\\",0,0,function(){return\\\"\\\"+Ra.apply(this)+T(this.minutes(),2)}),U(\\\"hmmss\\\",0,0,function(){return\\\"\\\"+Ra.apply(this)+T(this.minutes(),2)+T(this.seconds(),2)}),U(\\\"Hmm\\\",0,0,function(){return\\\"\\\"+this.hours()+T(this.minutes(),2)}),U(\\\"Hmmss\\\",0,0,function(){return\\\"\\\"+this.hours()+T(this.minutes(),2)+T(this.seconds(),2)}),Ta(\\\"a\\\",!0),Ta(\\\"A\\\",!1),J(\\\"hour\\\",\\\"h\\\"),M(\\\"hour\\\",13),Z(\\\"a\\\",Ua),Z(\\\"A\\\",Ua),Z(\\\"H\\\",Sd),Z(\\\"h\\\",Sd),Z(\\\"k\\\",Sd),Z(\\\"HH\\\",Sd,Od),Z(\\\"hh\\\",Sd,Od),Z(\\\"kk\\\",Sd,Od),Z(\\\"hmm\\\",Td),Z(\\\"hmmss\\\",Ud),Z(\\\"Hmm\\\",Td),Z(\\\"Hmmss\\\",Ud),ba([\\\"H\\\",\\\"HH\\\"],he),ba([\\\"k\\\",\\\"kk\\\"],function(a,b,c){var d=u(a);b[he]=24===d?0:d}),ba([\\\"a\\\",\\\"A\\\"],function(a,b,c){c._isPm=c._locale.isPM(a),c._meridiem=a}),ba([\\\"h\\\",\\\"hh\\\"],function(a,b,c){b[he]=u(a),n(c).bigHour=!0}),ba(\\\"hmm\\\",function(a,b,c){var d=a.length-2;b[he]=u(a.substr(0,d)),b[ie]=u(a.substr(d)),n(c).bigHour=!0}),ba(\\\"hmmss\\\",function(a,b,c){var d=a.length-4,e=a.length-2;b[he]=u(a.substr(0,d)),b[ie]=u(a.substr(d,2)),b[je]=u(a.substr(e)),n(c).bigHour=!0}),ba(\\\"Hmm\\\",function(a,b,c){var d=a.length-2;b[he]=u(a.substr(0,d)),b[ie]=u(a.substr(d))}),ba(\\\"Hmmss\\\",function(a,b,c){var d=a.length-4,e=a.length-2;b[he]=u(a.substr(0,d)),b[ie]=u(a.substr(d,2)),b[je]=u(a.substr(e))});var Be,Ce=/[ap]\\\\.?m?\\\\.?/i,De=O(\\\"Hours\\\",!0),Ee={calendar:Bd,longDateFormat:Cd,invalidDate:Dd,ordinal:Ed,dayOfMonthOrdinalParse:Fd,relativeTime:Gd,months:pe,monthsShort:qe,week:ue,weekdays:ve,weekdaysMin:xe,weekdaysShort:we,meridiemParse:Ce},Fe={},Ge={},He=/^\\\\s*((?:[+-]\\\\d{6}|\\\\d{4})-(?:\\\\d\\\\d-\\\\d\\\\d|W\\\\d\\\\d-\\\\d|W\\\\d\\\\d|\\\\d\\\\d\\\\d|\\\\d\\\\d))(?:(T| )(\\\\d\\\\d(?::\\\\d\\\\d(?::\\\\d\\\\d(?:[.,]\\\\d+)?)?)?)([\\\\+\\\\-]\\\\d\\\\d(?::?\\\\d\\\\d)?|\\\\s*Z)?)?$/,Ie=/^\\\\s*((?:[+-]\\\\d{6}|\\\\d{4})(?:\\\\d\\\\d\\\\d\\\\d|W\\\\d\\\\d\\\\d|W\\\\d\\\\d|\\\\d\\\\d\\\\d|\\\\d\\\\d))(?:(T| )(\\\\d\\\\d(?:\\\\d\\\\d(?:\\\\d\\\\d(?:[.,]\\\\d+)?)?)?)([\\\\+\\\\-]\\\\d\\\\d(?::?\\\\d\\\\d)?|\\\\s*Z)?)?$/,Je=/Z|[+-]\\\\d\\\\d(?::?\\\\d\\\\d)?/,Ke=[[\\\"YYYYYY-MM-DD\\\",/[+-]\\\\d{6}-\\\\d\\\\d-\\\\d\\\\d/],[\\\"YYYY-MM-DD\\\",/\\\\d{4}-\\\\d\\\\d-\\\\d\\\\d/],[\\\"GGGG-[W]WW-E\\\",/\\\\d{4}-W\\\\d\\\\d-\\\\d/],[\\\"GGGG-[W]WW\\\",/\\\\d{4}-W\\\\d\\\\d/,!1],[\\\"YYYY-DDD\\\",/\\\\d{4}-\\\\d{3}/],[\\\"YYYY-MM\\\",/\\\\d{4}-\\\\d\\\\d/,!1],[\\\"YYYYYYMMDD\\\",/[+-]\\\\d{10}/],[\\\"YYYYMMDD\\\",/\\\\d{8}/],[\\\"GGGG[W]WWE\\\",/\\\\d{4}W\\\\d{3}/],[\\\"GGGG[W]WW\\\",/\\\\d{4}W\\\\d{2}/,!1],[\\\"YYYYDDD\\\",/\\\\d{7}/]],Le=[[\\\"HH:mm:ss.SSSS\\\",/\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d\\\\.\\\\d+/],[\\\"HH:mm:ss,SSSS\\\",/\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d,\\\\d+/],[\\\"HH:mm:ss\\\",/\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d/],[\\\"HH:mm\\\",/\\\\d\\\\d:\\\\d\\\\d/],[\\\"HHmmss.SSSS\\\",/\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\.\\\\d+/],[\\\"HHmmss,SSSS\\\",/\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d,\\\\d+/],[\\\"HHmmss\\\",/\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d/],[\\\"HHmm\\\",/\\\\d\\\\d\\\\d\\\\d/],[\\\"HH\\\",/\\\\d\\\\d/]],Me=/^\\\\/?Date\\\\((\\\\-?\\\\d+)/i,Ne=/^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\\\s)?(\\\\d?\\\\d\\\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\\\s(?:\\\\d\\\\d)?\\\\d\\\\d\\\\s)(\\\\d\\\\d:\\\\d\\\\d)(\\\\:\\\\d\\\\d)?(\\\\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\\\\d{4}))$/;a.createFromInputFallback=x(\\\"value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.\\\",function(a){a._d=new Date(a._i+(a._useUTC?\\\" UTC\\\":\\\"\\\"))}),a.ISO_8601=function(){},a.RFC_2822=function(){};var Oe=x(\\\"moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/\\\",function(){var a=tb.apply(null,arguments);return this.isValid()&&a.isValid()?a<this?this:a:p()}),Pe=x(\\\"moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/\\\",function(){var a=tb.apply(null,arguments);return this.isValid()&&a.isValid()?a>this?this:a:p()}),Qe=function(){return Date.now?Date.now():+new Date},Re=[\\\"year\\\",\\\"quarter\\\",\\\"month\\\",\\\"week\\\",\\\"day\\\",\\\"hour\\\",\\\"minute\\\",\\\"second\\\",\\\"millisecond\\\"];Db(\\\"Z\\\",\\\":\\\"),Db(\\\"ZZ\\\",\\\"\\\"),Z(\\\"Z\\\",_d),Z(\\\"ZZ\\\",_d),ba([\\\"Z\\\",\\\"ZZ\\\"],function(a,b,c){c._useUTC=!0,c._tzm=Eb(_d,a)});var Se=/([\\\\+\\\\-]|\\\\d\\\\d)/gi;a.updateOffset=function(){};var Te=/^(\\\\-)?(?:(\\\\d*)[. ])?(\\\\d+)\\\\:(\\\\d+)(?:\\\\:(\\\\d+)(\\\\.\\\\d*)?)?$/,Ue=/^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;Sb.fn=Ab.prototype,Sb.invalid=zb;var Ve=Wb(1,\\\"add\\\"),We=Wb(-1,\\\"subtract\\\");a.defaultFormat=\\\"YYYY-MM-DDTHH:mm:ssZ\\\",a.defaultFormatUtc=\\\"YYYY-MM-DDTHH:mm:ss[Z]\\\";var Xe=x(\\\"moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.\\\",function(a){return void 0===a?this.localeData():this.locale(a)});U(0,[\\\"gg\\\",2],0,function(){return this.weekYear()%100}),U(0,[\\\"GG\\\",2],0,function(){return this.isoWeekYear()%100}),Dc(\\\"gggg\\\",\\\"weekYear\\\"),Dc(\\\"ggggg\\\",\\\"weekYear\\\"),Dc(\\\"GGGG\\\",\\\"isoWeekYear\\\"),Dc(\\\"GGGGG\\\",\\\"isoWeekYear\\\"),J(\\\"weekYear\\\",\\\"gg\\\"),J(\\\"isoWeekYear\\\",\\\"GG\\\"),M(\\\"weekYear\\\",1),M(\\\"isoWeekYear\\\",1),Z(\\\"G\\\",Zd),Z(\\\"g\\\",Zd),Z(\\\"GG\\\",Sd,Od),Z(\\\"gg\\\",Sd,Od),Z(\\\"GGGG\\\",Wd,Qd),Z(\\\"gggg\\\",Wd,Qd),Z(\\\"GGGGG\\\",Xd,Rd),Z(\\\"ggggg\\\",Xd,Rd),ca([\\\"gggg\\\",\\\"ggggg\\\",\\\"GGGG\\\",\\\"GGGGG\\\"],function(a,b,c,d){b[d.substr(0,2)]=u(a)}),ca([\\\"gg\\\",\\\"GG\\\"],function(b,c,d,e){c[e]=a.parseTwoDigitYear(b)}),U(\\\"Q\\\",0,\\\"Qo\\\",\\\"quarter\\\"),J(\\\"quarter\\\",\\\"Q\\\"),M(\\\"quarter\\\",7),Z(\\\"Q\\\",Nd),ba(\\\"Q\\\",function(a,b){b[fe]=3*(u(a)-1)}),U(\\\"D\\\",[\\\"DD\\\",2],\\\"Do\\\",\\\"date\\\"),J(\\\"date\\\",\\\"D\\\"),M(\\\"date\\\",9),Z(\\\"D\\\",Sd),Z(\\\"DD\\\",Sd,Od),Z(\\\"Do\\\",function(a,b){return a?b._dayOfMonthOrdinalParse||b._ordinalParse:b._dayOfMonthOrdinalParseLenient}),ba([\\\"D\\\",\\\"DD\\\"],ge),ba(\\\"Do\\\",function(a,b){b[ge]=u(a.match(Sd)[0],10)});var Ye=O(\\\"Date\\\",!0);U(\\\"DDD\\\",[\\\"DDDD\\\",3],\\\"DDDo\\\",\\\"dayOfYear\\\"),J(\\\"dayOfYear\\\",\\\"DDD\\\"),M(\\\"dayOfYear\\\",4),Z(\\\"DDD\\\",Vd),Z(\\\"DDDD\\\",Pd),ba([\\\"DDD\\\",\\\"DDDD\\\"],function(a,b,c){c._dayOfYear=u(a)}),U(\\\"m\\\",[\\\"mm\\\",2],0,\\\"minute\\\"),J(\\\"minute\\\",\\\"m\\\"),M(\\\"minute\\\",14),Z(\\\"m\\\",Sd),Z(\\\"mm\\\",Sd,Od),ba([\\\"m\\\",\\\"mm\\\"],ie);var Ze=O(\\\"Minutes\\\",!1);U(\\\"s\\\",[\\\"ss\\\",2],0,\\\"second\\\"),J(\\\"second\\\",\\\"s\\\"),M(\\\"second\\\",15),Z(\\\"s\\\",Sd),Z(\\\"ss\\\",Sd,Od),ba([\\\"s\\\",\\\"ss\\\"],je);var $e=O(\\\"Seconds\\\",!1);U(\\\"S\\\",0,0,function(){return~~(this.millisecond()/100)}),U(0,[\\\"SS\\\",2],0,function(){return~~(this.millisecond()/10)}),U(0,[\\\"SSS\\\",3],0,\\\"millisecond\\\"),U(0,[\\\"SSSS\\\",4],0,function(){return 10*this.millisecond()}),U(0,[\\\"SSSSS\\\",5],0,function(){return 100*this.millisecond()}),U(0,[\\\"SSSSSS\\\",6],0,function(){return 1e3*this.millisecond()}),U(0,[\\\"SSSSSSS\\\",7],0,function(){return 1e4*this.millisecond()}),U(0,[\\\"SSSSSSSS\\\",8],0,function(){return 1e5*this.millisecond()}),U(0,[\\\"SSSSSSSSS\\\",9],0,function(){return 1e6*this.millisecond()}),J(\\\"millisecond\\\",\\\"ms\\\"),M(\\\"millisecond\\\",16),Z(\\\"S\\\",Vd,Nd),Z(\\\"SS\\\",Vd,Od),Z(\\\"SSS\\\",Vd,Pd);var _e;for(_e=\\\"SSSS\\\";_e.length<=9;_e+=\\\"S\\\")Z(_e,Yd);for(_e=\\\"S\\\";_e.length<=9;_e+=\\\"S\\\")ba(_e,Mc);var af=O(\\\"Milliseconds\\\",!1);U(\\\"z\\\",0,0,\\\"zoneAbbr\\\"),U(\\\"zz\\\",0,0,\\\"zoneName\\\");var bf=r.prototype;bf.add=Ve,bf.calendar=Zb,bf.clone=$b,bf.diff=fc,bf.endOf=sc,bf.format=kc,bf.from=lc,bf.fromNow=mc,bf.to=nc,bf.toNow=oc,bf.get=R,bf.invalidAt=Bc,bf.isAfter=_b,bf.isBefore=ac,bf.isBetween=bc,bf.isSame=cc,bf.isSameOrAfter=dc,bf.isSameOrBefore=ec,bf.isValid=zc,bf.lang=Xe,bf.locale=pc,bf.localeData=qc,bf.max=Pe,bf.min=Oe,bf.parsingFlags=Ac,bf.set=S,bf.startOf=rc,bf.subtract=We,bf.toArray=wc,bf.toObject=xc,bf.toDate=vc,bf.toISOString=ic,bf.inspect=jc,bf.toJSON=yc,bf.toString=hc,bf.unix=uc,bf.valueOf=tc,bf.creationData=Cc,bf.year=te,bf.isLeapYear=ra,bf.weekYear=Ec,bf.isoWeekYear=Fc,bf.quarter=bf.quarters=Kc,bf.month=ka,bf.daysInMonth=la,bf.week=bf.weeks=Ba,bf.isoWeek=bf.isoWeeks=Ca,bf.weeksInYear=Hc,bf.isoWeeksInYear=Gc,bf.date=Ye,bf.day=bf.days=Ka,bf.weekday=La,bf.isoWeekday=Ma,bf.dayOfYear=Lc,bf.hour=bf.hours=De,bf.minute=bf.minutes=Ze,bf.second=bf.seconds=$e,bf.millisecond=bf.milliseconds=af,bf.utcOffset=Hb,bf.utc=Jb,bf.local=Kb,bf.parseZone=Lb,bf.hasAlignedHourOffset=Mb,bf.isDST=Nb,bf.isLocal=Pb,bf.isUtcOffset=Qb,bf.isUtc=Rb,bf.isUTC=Rb,bf.zoneAbbr=Nc,bf.zoneName=Oc,bf.dates=x(\\\"dates accessor is deprecated. Use date instead.\\\",Ye),bf.months=x(\\\"months accessor is deprecated. Use month instead\\\",ka),bf.years=x(\\\"years accessor is deprecated. Use year instead\\\",te),bf.zone=x(\\\"moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/\\\",Ib),bf.isDSTShifted=x(\\\"isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information\\\",Ob);var cf=C.prototype;cf.calendar=D,cf.longDateFormat=E,cf.invalidDate=F,cf.ordinal=G,cf.preparse=Rc,cf.postformat=Rc,cf.relativeTime=H,cf.pastFuture=I,cf.set=A,cf.months=fa,cf.monthsShort=ga,cf.monthsParse=ia,cf.monthsRegex=na,cf.monthsShortRegex=ma,cf.week=ya,cf.firstDayOfYear=Aa,cf.firstDayOfWeek=za,cf.weekdays=Fa,cf.weekdaysMin=Ha,cf.weekdaysShort=Ga,cf.weekdaysParse=Ja,cf.weekdaysRegex=Na,cf.weekdaysShortRegex=Oa,cf.weekdaysMinRegex=Pa,cf.isPM=Va,cf.meridiem=Wa,$a(\\\"en\\\",{dayOfMonthOrdinalParse:/\\\\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===u(a%100/10)?\\\"th\\\":1===b?\\\"st\\\":2===b?\\\"nd\\\":3===b?\\\"rd\\\":\\\"th\\\";return a+c}}),a.lang=x(\\\"moment.lang is deprecated. Use moment.locale instead.\\\",$a),a.langData=x(\\\"moment.langData is deprecated. Use moment.localeData instead.\\\",bb);var df=Math.abs,ef=id(\\\"ms\\\"),ff=id(\\\"s\\\"),gf=id(\\\"m\\\"),hf=id(\\\"h\\\"),jf=id(\\\"d\\\"),kf=id(\\\"w\\\"),lf=id(\\\"M\\\"),mf=id(\\\"y\\\"),nf=kd(\\\"milliseconds\\\"),of=kd(\\\"seconds\\\"),pf=kd(\\\"minutes\\\"),qf=kd(\\\"hours\\\"),rf=kd(\\\"days\\\"),sf=kd(\\\"months\\\"),tf=kd(\\\"years\\\"),uf=Math.round,vf={ss:44,s:45,m:45,h:22,d:26,M:11},wf=Math.abs,xf=Ab.prototype;return xf.isValid=yb,xf.abs=$c,xf.add=ad,xf.subtract=bd,xf.as=gd,xf.asMilliseconds=ef,xf.asSeconds=ff,xf.asMinutes=gf,xf.asHours=hf,xf.asDays=jf,xf.asWeeks=kf,xf.asMonths=lf,xf.asYears=mf,xf.valueOf=hd,xf._bubble=dd,xf.get=jd,xf.milliseconds=nf,xf.seconds=of,xf.minutes=pf,xf.hours=qf,xf.days=rf,xf.weeks=ld,xf.months=sf,xf.years=tf,xf.humanize=qd,xf.toISOString=rd,xf.toString=rd,xf.toJSON=rd,xf.locale=pc,xf.localeData=qc,xf.toIsoString=x(\\\"toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)\\\",rd),xf.lang=Xe,U(\\\"X\\\",0,0,\\\"unix\\\"),U(\\\"x\\\",0,0,\\\"valueOf\\\"),Z(\\\"x\\\",Zd),Z(\\\"X\\\",ae),ba(\\\"X\\\",function(a,b,c){c._d=new Date(1e3*parseFloat(a,10))}),ba(\\\"x\\\",function(a,b,c){c._d=new Date(u(a))}),a.version=\\\"2.18.1\\\",b(tb),a.fn=bf,a.min=vb,a.max=wb,a.now=Qe,a.utc=l,a.unix=Pc,a.months=Vc,a.isDate=h,a.locale=$a,a.invalid=p,a.duration=Sb,a.isMoment=s,a.weekdays=Xc,a.parseZone=Qc,a.localeData=bb,a.isDuration=Bb,a.monthsShort=Wc,a.weekdaysMin=Zc,a.defineLocale=_a,a.updateLocale=ab,a.locales=cb,a.weekdaysShort=Yc,a.normalizeUnits=K,a.relativeTimeRounding=od,a.relativeTimeThreshold=pd,a.calendarFormat=Yb,a.prototype=bf,a});\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/moment/min/moment.min.js\n// module id = 1089\n// module chunks = 2","module.exports = \"/*!\\n * Chart.js\\n * http://chartjs.org/\\n * Version: 2.5.0\\n *\\n * Copyright 2017 Nick Downie\\n * Released under the MIT license\\n * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md\\n */\\n(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n/* MIT license */\\nvar colorNames = require(5);\\n\\nmodule.exports = {\\n   getRgba: getRgba,\\n   getHsla: getHsla,\\n   getRgb: getRgb,\\n   getHsl: getHsl,\\n   getHwb: getHwb,\\n   getAlpha: getAlpha,\\n\\n   hexString: hexString,\\n   rgbString: rgbString,\\n   rgbaString: rgbaString,\\n   percentString: percentString,\\n   percentaString: percentaString,\\n   hslString: hslString,\\n   hslaString: hslaString,\\n   hwbString: hwbString,\\n   keyword: keyword\\n}\\n\\nfunction getRgba(string) {\\n   if (!string) {\\n      return;\\n   }\\n   var abbr =  /^#([a-fA-F0-9]{3})$/,\\n       hex =  /^#([a-fA-F0-9]{6})$/,\\n       rgba = /^rgba?\\\\(\\\\s*([+-]?\\\\d+)\\\\s*,\\\\s*([+-]?\\\\d+)\\\\s*,\\\\s*([+-]?\\\\d+)\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)$/,\\n       per = /^rgba?\\\\(\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)$/,\\n       keyword = /(\\\\w+)/;\\n\\n   var rgb = [0, 0, 0],\\n       a = 1,\\n       match = string.match(abbr);\\n   if (match) {\\n      match = match[1];\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = parseInt(match[i] + match[i], 16);\\n      }\\n   }\\n   else if (match = string.match(hex)) {\\n      match = match[1];\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\\n      }\\n   }\\n   else if (match = string.match(rgba)) {\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = parseInt(match[i + 1]);\\n      }\\n      a = parseFloat(match[4]);\\n   }\\n   else if (match = string.match(per)) {\\n      for (var i = 0; i < rgb.length; i++) {\\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\\n      }\\n      a = parseFloat(match[4]);\\n   }\\n   else if (match = string.match(keyword)) {\\n      if (match[1] == \\\"transparent\\\") {\\n         return [0, 0, 0, 0];\\n      }\\n      rgb = colorNames[match[1]];\\n      if (!rgb) {\\n         return;\\n      }\\n   }\\n\\n   for (var i = 0; i < rgb.length; i++) {\\n      rgb[i] = scale(rgb[i], 0, 255);\\n   }\\n   if (!a && a != 0) {\\n      a = 1;\\n   }\\n   else {\\n      a = scale(a, 0, 1);\\n   }\\n   rgb[3] = a;\\n   return rgb;\\n}\\n\\nfunction getHsla(string) {\\n   if (!string) {\\n      return;\\n   }\\n   var hsl = /^hsla?\\\\(\\\\s*([+-]?\\\\d+)(?:deg)?\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)/;\\n   var match = string.match(hsl);\\n   if (match) {\\n      var alpha = parseFloat(match[4]);\\n      var h = scale(parseInt(match[1]), 0, 360),\\n          s = scale(parseFloat(match[2]), 0, 100),\\n          l = scale(parseFloat(match[3]), 0, 100),\\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\\n      return [h, s, l, a];\\n   }\\n}\\n\\nfunction getHwb(string) {\\n   if (!string) {\\n      return;\\n   }\\n   var hwb = /^hwb\\\\(\\\\s*([+-]?\\\\d+)(?:deg)?\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*,\\\\s*([+-]?[\\\\d\\\\.]+)%\\\\s*(?:,\\\\s*([+-]?[\\\\d\\\\.]+)\\\\s*)?\\\\)/;\\n   var match = string.match(hwb);\\n   if (match) {\\n    var alpha = parseFloat(match[4]);\\n      var h = scale(parseInt(match[1]), 0, 360),\\n          w = scale(parseFloat(match[2]), 0, 100),\\n          b = scale(parseFloat(match[3]), 0, 100),\\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\\n      return [h, w, b, a];\\n   }\\n}\\n\\nfunction getRgb(string) {\\n   var rgba = getRgba(string);\\n   return rgba && rgba.slice(0, 3);\\n}\\n\\nfunction getHsl(string) {\\n  var hsla = getHsla(string);\\n  return hsla && hsla.slice(0, 3);\\n}\\n\\nfunction getAlpha(string) {\\n   var vals = getRgba(string);\\n   if (vals) {\\n      return vals[3];\\n   }\\n   else if (vals = getHsla(string)) {\\n      return vals[3];\\n   }\\n   else if (vals = getHwb(string)) {\\n      return vals[3];\\n   }\\n}\\n\\n// generators\\nfunction hexString(rgb) {\\n   return \\\"#\\\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\\n              + hexDouble(rgb[2]);\\n}\\n\\nfunction rgbString(rgba, alpha) {\\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\\n      return rgbaString(rgba, alpha);\\n   }\\n   return \\\"rgb(\\\" + rgba[0] + \\\", \\\" + rgba[1] + \\\", \\\" + rgba[2] + \\\")\\\";\\n}\\n\\nfunction rgbaString(rgba, alpha) {\\n   if (alpha === undefined) {\\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\\n   }\\n   return \\\"rgba(\\\" + rgba[0] + \\\", \\\" + rgba[1] + \\\", \\\" + rgba[2]\\n           + \\\", \\\" + alpha + \\\")\\\";\\n}\\n\\nfunction percentString(rgba, alpha) {\\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\\n      return percentaString(rgba, alpha);\\n   }\\n   var r = Math.round(rgba[0]/255 * 100),\\n       g = Math.round(rgba[1]/255 * 100),\\n       b = Math.round(rgba[2]/255 * 100);\\n\\n   return \\\"rgb(\\\" + r + \\\"%, \\\" + g + \\\"%, \\\" + b + \\\"%)\\\";\\n}\\n\\nfunction percentaString(rgba, alpha) {\\n   var r = Math.round(rgba[0]/255 * 100),\\n       g = Math.round(rgba[1]/255 * 100),\\n       b = Math.round(rgba[2]/255 * 100);\\n   return \\\"rgba(\\\" + r + \\\"%, \\\" + g + \\\"%, \\\" + b + \\\"%, \\\" + (alpha || rgba[3] || 1) + \\\")\\\";\\n}\\n\\nfunction hslString(hsla, alpha) {\\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\\n      return hslaString(hsla, alpha);\\n   }\\n   return \\\"hsl(\\\" + hsla[0] + \\\", \\\" + hsla[1] + \\\"%, \\\" + hsla[2] + \\\"%)\\\";\\n}\\n\\nfunction hslaString(hsla, alpha) {\\n   if (alpha === undefined) {\\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\\n   }\\n   return \\\"hsla(\\\" + hsla[0] + \\\", \\\" + hsla[1] + \\\"%, \\\" + hsla[2] + \\\"%, \\\"\\n           + alpha + \\\")\\\";\\n}\\n\\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\\n// (hwb have alpha optional & 1 is default value)\\nfunction hwbString(hwb, alpha) {\\n   if (alpha === undefined) {\\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\\n   }\\n   return \\\"hwb(\\\" + hwb[0] + \\\", \\\" + hwb[1] + \\\"%, \\\" + hwb[2] + \\\"%\\\"\\n           + (alpha !== undefined && alpha !== 1 ? \\\", \\\" + alpha : \\\"\\\") + \\\")\\\";\\n}\\n\\nfunction keyword(rgb) {\\n  return reverseNames[rgb.slice(0, 3)];\\n}\\n\\n// helpers\\nfunction scale(num, min, max) {\\n   return Math.min(Math.max(min, num), max);\\n}\\n\\nfunction hexDouble(num) {\\n  var str = num.toString(16).toUpperCase();\\n  return (str.length < 2) ? \\\"0\\\" + str : str;\\n}\\n\\n\\n//create a list of reverse color names\\nvar reverseNames = {};\\nfor (var name in colorNames) {\\n   reverseNames[colorNames[name]] = name;\\n}\\n\\n},{\\\"5\\\":5}],2:[function(require,module,exports){\\n/* MIT license */\\nvar convert = require(4);\\nvar string = require(1);\\n\\nvar Color = function (obj) {\\n\\tif (obj instanceof Color) {\\n\\t\\treturn obj;\\n\\t}\\n\\tif (!(this instanceof Color)) {\\n\\t\\treturn new Color(obj);\\n\\t}\\n\\n\\tthis.values = {\\n\\t\\trgb: [0, 0, 0],\\n\\t\\thsl: [0, 0, 0],\\n\\t\\thsv: [0, 0, 0],\\n\\t\\thwb: [0, 0, 0],\\n\\t\\tcmyk: [0, 0, 0, 0],\\n\\t\\talpha: 1\\n\\t};\\n\\n\\t// parse Color() argument\\n\\tvar vals;\\n\\tif (typeof obj === 'string') {\\n\\t\\tvals = string.getRgba(obj);\\n\\t\\tif (vals) {\\n\\t\\t\\tthis.setValues('rgb', vals);\\n\\t\\t} else if (vals = string.getHsla(obj)) {\\n\\t\\t\\tthis.setValues('hsl', vals);\\n\\t\\t} else if (vals = string.getHwb(obj)) {\\n\\t\\t\\tthis.setValues('hwb', vals);\\n\\t\\t} else {\\n\\t\\t\\tthrow new Error('Unable to parse color from string \\\"' + obj + '\\\"');\\n\\t\\t}\\n\\t} else if (typeof obj === 'object') {\\n\\t\\tvals = obj;\\n\\t\\tif (vals.r !== undefined || vals.red !== undefined) {\\n\\t\\t\\tthis.setValues('rgb', vals);\\n\\t\\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\\n\\t\\t\\tthis.setValues('hsl', vals);\\n\\t\\t} else if (vals.v !== undefined || vals.value !== undefined) {\\n\\t\\t\\tthis.setValues('hsv', vals);\\n\\t\\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\\n\\t\\t\\tthis.setValues('hwb', vals);\\n\\t\\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\\n\\t\\t\\tthis.setValues('cmyk', vals);\\n\\t\\t} else {\\n\\t\\t\\tthrow new Error('Unable to parse color from object ' + JSON.stringify(obj));\\n\\t\\t}\\n\\t}\\n};\\n\\nColor.prototype = {\\n\\trgb: function () {\\n\\t\\treturn this.setSpace('rgb', arguments);\\n\\t},\\n\\thsl: function () {\\n\\t\\treturn this.setSpace('hsl', arguments);\\n\\t},\\n\\thsv: function () {\\n\\t\\treturn this.setSpace('hsv', arguments);\\n\\t},\\n\\thwb: function () {\\n\\t\\treturn this.setSpace('hwb', arguments);\\n\\t},\\n\\tcmyk: function () {\\n\\t\\treturn this.setSpace('cmyk', arguments);\\n\\t},\\n\\n\\trgbArray: function () {\\n\\t\\treturn this.values.rgb;\\n\\t},\\n\\thslArray: function () {\\n\\t\\treturn this.values.hsl;\\n\\t},\\n\\thsvArray: function () {\\n\\t\\treturn this.values.hsv;\\n\\t},\\n\\thwbArray: function () {\\n\\t\\tvar values = this.values;\\n\\t\\tif (values.alpha !== 1) {\\n\\t\\t\\treturn values.hwb.concat([values.alpha]);\\n\\t\\t}\\n\\t\\treturn values.hwb;\\n\\t},\\n\\tcmykArray: function () {\\n\\t\\treturn this.values.cmyk;\\n\\t},\\n\\trgbaArray: function () {\\n\\t\\tvar values = this.values;\\n\\t\\treturn values.rgb.concat([values.alpha]);\\n\\t},\\n\\thslaArray: function () {\\n\\t\\tvar values = this.values;\\n\\t\\treturn values.hsl.concat([values.alpha]);\\n\\t},\\n\\talpha: function (val) {\\n\\t\\tif (val === undefined) {\\n\\t\\t\\treturn this.values.alpha;\\n\\t\\t}\\n\\t\\tthis.setValues('alpha', val);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tred: function (val) {\\n\\t\\treturn this.setChannel('rgb', 0, val);\\n\\t},\\n\\tgreen: function (val) {\\n\\t\\treturn this.setChannel('rgb', 1, val);\\n\\t},\\n\\tblue: function (val) {\\n\\t\\treturn this.setChannel('rgb', 2, val);\\n\\t},\\n\\thue: function (val) {\\n\\t\\tif (val) {\\n\\t\\t\\tval %= 360;\\n\\t\\t\\tval = val < 0 ? 360 + val : val;\\n\\t\\t}\\n\\t\\treturn this.setChannel('hsl', 0, val);\\n\\t},\\n\\tsaturation: function (val) {\\n\\t\\treturn this.setChannel('hsl', 1, val);\\n\\t},\\n\\tlightness: function (val) {\\n\\t\\treturn this.setChannel('hsl', 2, val);\\n\\t},\\n\\tsaturationv: function (val) {\\n\\t\\treturn this.setChannel('hsv', 1, val);\\n\\t},\\n\\twhiteness: function (val) {\\n\\t\\treturn this.setChannel('hwb', 1, val);\\n\\t},\\n\\tblackness: function (val) {\\n\\t\\treturn this.setChannel('hwb', 2, val);\\n\\t},\\n\\tvalue: function (val) {\\n\\t\\treturn this.setChannel('hsv', 2, val);\\n\\t},\\n\\tcyan: function (val) {\\n\\t\\treturn this.setChannel('cmyk', 0, val);\\n\\t},\\n\\tmagenta: function (val) {\\n\\t\\treturn this.setChannel('cmyk', 1, val);\\n\\t},\\n\\tyellow: function (val) {\\n\\t\\treturn this.setChannel('cmyk', 2, val);\\n\\t},\\n\\tblack: function (val) {\\n\\t\\treturn this.setChannel('cmyk', 3, val);\\n\\t},\\n\\n\\thexString: function () {\\n\\t\\treturn string.hexString(this.values.rgb);\\n\\t},\\n\\trgbString: function () {\\n\\t\\treturn string.rgbString(this.values.rgb, this.values.alpha);\\n\\t},\\n\\trgbaString: function () {\\n\\t\\treturn string.rgbaString(this.values.rgb, this.values.alpha);\\n\\t},\\n\\tpercentString: function () {\\n\\t\\treturn string.percentString(this.values.rgb, this.values.alpha);\\n\\t},\\n\\thslString: function () {\\n\\t\\treturn string.hslString(this.values.hsl, this.values.alpha);\\n\\t},\\n\\thslaString: function () {\\n\\t\\treturn string.hslaString(this.values.hsl, this.values.alpha);\\n\\t},\\n\\thwbString: function () {\\n\\t\\treturn string.hwbString(this.values.hwb, this.values.alpha);\\n\\t},\\n\\tkeyword: function () {\\n\\t\\treturn string.keyword(this.values.rgb, this.values.alpha);\\n\\t},\\n\\n\\trgbNumber: function () {\\n\\t\\tvar rgb = this.values.rgb;\\n\\t\\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\\n\\t},\\n\\n\\tluminosity: function () {\\n\\t\\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\\n\\t\\tvar rgb = this.values.rgb;\\n\\t\\tvar lum = [];\\n\\t\\tfor (var i = 0; i < rgb.length; i++) {\\n\\t\\t\\tvar chan = rgb[i] / 255;\\n\\t\\t\\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\\n\\t\\t}\\n\\t\\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\\n\\t},\\n\\n\\tcontrast: function (color2) {\\n\\t\\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\\n\\t\\tvar lum1 = this.luminosity();\\n\\t\\tvar lum2 = color2.luminosity();\\n\\t\\tif (lum1 > lum2) {\\n\\t\\t\\treturn (lum1 + 0.05) / (lum2 + 0.05);\\n\\t\\t}\\n\\t\\treturn (lum2 + 0.05) / (lum1 + 0.05);\\n\\t},\\n\\n\\tlevel: function (color2) {\\n\\t\\tvar contrastRatio = this.contrast(color2);\\n\\t\\tif (contrastRatio >= 7.1) {\\n\\t\\t\\treturn 'AAA';\\n\\t\\t}\\n\\n\\t\\treturn (contrastRatio >= 4.5) ? 'AA' : '';\\n\\t},\\n\\n\\tdark: function () {\\n\\t\\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\\n\\t\\tvar rgb = this.values.rgb;\\n\\t\\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\\n\\t\\treturn yiq < 128;\\n\\t},\\n\\n\\tlight: function () {\\n\\t\\treturn !this.dark();\\n\\t},\\n\\n\\tnegate: function () {\\n\\t\\tvar rgb = [];\\n\\t\\tfor (var i = 0; i < 3; i++) {\\n\\t\\t\\trgb[i] = 255 - this.values.rgb[i];\\n\\t\\t}\\n\\t\\tthis.setValues('rgb', rgb);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tlighten: function (ratio) {\\n\\t\\tvar hsl = this.values.hsl;\\n\\t\\thsl[2] += hsl[2] * ratio;\\n\\t\\tthis.setValues('hsl', hsl);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tdarken: function (ratio) {\\n\\t\\tvar hsl = this.values.hsl;\\n\\t\\thsl[2] -= hsl[2] * ratio;\\n\\t\\tthis.setValues('hsl', hsl);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tsaturate: function (ratio) {\\n\\t\\tvar hsl = this.values.hsl;\\n\\t\\thsl[1] += hsl[1] * ratio;\\n\\t\\tthis.setValues('hsl', hsl);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tdesaturate: function (ratio) {\\n\\t\\tvar hsl = this.values.hsl;\\n\\t\\thsl[1] -= hsl[1] * ratio;\\n\\t\\tthis.setValues('hsl', hsl);\\n\\t\\treturn this;\\n\\t},\\n\\n\\twhiten: function (ratio) {\\n\\t\\tvar hwb = this.values.hwb;\\n\\t\\thwb[1] += hwb[1] * ratio;\\n\\t\\tthis.setValues('hwb', hwb);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tblacken: function (ratio) {\\n\\t\\tvar hwb = this.values.hwb;\\n\\t\\thwb[2] += hwb[2] * ratio;\\n\\t\\tthis.setValues('hwb', hwb);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tgreyscale: function () {\\n\\t\\tvar rgb = this.values.rgb;\\n\\t\\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\\n\\t\\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\\n\\t\\tthis.setValues('rgb', [val, val, val]);\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclearer: function (ratio) {\\n\\t\\tvar alpha = this.values.alpha;\\n\\t\\tthis.setValues('alpha', alpha - (alpha * ratio));\\n\\t\\treturn this;\\n\\t},\\n\\n\\topaquer: function (ratio) {\\n\\t\\tvar alpha = this.values.alpha;\\n\\t\\tthis.setValues('alpha', alpha + (alpha * ratio));\\n\\t\\treturn this;\\n\\t},\\n\\n\\trotate: function (degrees) {\\n\\t\\tvar hsl = this.values.hsl;\\n\\t\\tvar hue = (hsl[0] + degrees) % 360;\\n\\t\\thsl[0] = hue < 0 ? 360 + hue : hue;\\n\\t\\tthis.setValues('hsl', hsl);\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/**\\n\\t * Ported from sass implementation in C\\n\\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\\n\\t */\\n\\tmix: function (mixinColor, weight) {\\n\\t\\tvar color1 = this;\\n\\t\\tvar color2 = mixinColor;\\n\\t\\tvar p = weight === undefined ? 0.5 : weight;\\n\\n\\t\\tvar w = 2 * p - 1;\\n\\t\\tvar a = color1.alpha() - color2.alpha();\\n\\n\\t\\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\\n\\t\\tvar w2 = 1 - w1;\\n\\n\\t\\treturn this\\n\\t\\t\\t.rgb(\\n\\t\\t\\t\\tw1 * color1.red() + w2 * color2.red(),\\n\\t\\t\\t\\tw1 * color1.green() + w2 * color2.green(),\\n\\t\\t\\t\\tw1 * color1.blue() + w2 * color2.blue()\\n\\t\\t\\t)\\n\\t\\t\\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\\n\\t},\\n\\n\\ttoJSON: function () {\\n\\t\\treturn this.rgb();\\n\\t},\\n\\n\\tclone: function () {\\n\\t\\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\\n\\t\\t// making the final build way to big to embed in Chart.js. So let's do it manually,\\n\\t\\t// assuming that values to clone are 1 dimension arrays containing only numbers,\\n\\t\\t// except 'alpha' which is a number.\\n\\t\\tvar result = new Color();\\n\\t\\tvar source = this.values;\\n\\t\\tvar target = result.values;\\n\\t\\tvar value, type;\\n\\n\\t\\tfor (var prop in source) {\\n\\t\\t\\tif (source.hasOwnProperty(prop)) {\\n\\t\\t\\t\\tvalue = source[prop];\\n\\t\\t\\t\\ttype = ({}).toString.call(value);\\n\\t\\t\\t\\tif (type === '[object Array]') {\\n\\t\\t\\t\\t\\ttarget[prop] = value.slice(0);\\n\\t\\t\\t\\t} else if (type === '[object Number]') {\\n\\t\\t\\t\\t\\ttarget[prop] = value;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconsole.error('unexpected color value:', value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n\\nColor.prototype.spaces = {\\n\\trgb: ['red', 'green', 'blue'],\\n\\thsl: ['hue', 'saturation', 'lightness'],\\n\\thsv: ['hue', 'saturation', 'value'],\\n\\thwb: ['hue', 'whiteness', 'blackness'],\\n\\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\\n};\\n\\nColor.prototype.maxes = {\\n\\trgb: [255, 255, 255],\\n\\thsl: [360, 100, 100],\\n\\thsv: [360, 100, 100],\\n\\thwb: [360, 100, 100],\\n\\tcmyk: [100, 100, 100, 100]\\n};\\n\\nColor.prototype.getValues = function (space) {\\n\\tvar values = this.values;\\n\\tvar vals = {};\\n\\n\\tfor (var i = 0; i < space.length; i++) {\\n\\t\\tvals[space.charAt(i)] = values[space][i];\\n\\t}\\n\\n\\tif (values.alpha !== 1) {\\n\\t\\tvals.a = values.alpha;\\n\\t}\\n\\n\\t// {r: 255, g: 255, b: 255, a: 0.4}\\n\\treturn vals;\\n};\\n\\nColor.prototype.setValues = function (space, vals) {\\n\\tvar values = this.values;\\n\\tvar spaces = this.spaces;\\n\\tvar maxes = this.maxes;\\n\\tvar alpha = 1;\\n\\tvar i;\\n\\n\\tif (space === 'alpha') {\\n\\t\\talpha = vals;\\n\\t} else if (vals.length) {\\n\\t\\t// [10, 10, 10]\\n\\t\\tvalues[space] = vals.slice(0, space.length);\\n\\t\\talpha = vals[space.length];\\n\\t} else if (vals[space.charAt(0)] !== undefined) {\\n\\t\\t// {r: 10, g: 10, b: 10}\\n\\t\\tfor (i = 0; i < space.length; i++) {\\n\\t\\t\\tvalues[space][i] = vals[space.charAt(i)];\\n\\t\\t}\\n\\n\\t\\talpha = vals.a;\\n\\t} else if (vals[spaces[space][0]] !== undefined) {\\n\\t\\t// {red: 10, green: 10, blue: 10}\\n\\t\\tvar chans = spaces[space];\\n\\n\\t\\tfor (i = 0; i < space.length; i++) {\\n\\t\\t\\tvalues[space][i] = vals[chans[i]];\\n\\t\\t}\\n\\n\\t\\talpha = vals.alpha;\\n\\t}\\n\\n\\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\\n\\n\\tif (space === 'alpha') {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvar capped;\\n\\n\\t// cap values of the space prior converting all values\\n\\tfor (i = 0; i < space.length; i++) {\\n\\t\\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\\n\\t\\tvalues[space][i] = Math.round(capped);\\n\\t}\\n\\n\\t// convert to all the other color spaces\\n\\tfor (var sname in spaces) {\\n\\t\\tif (sname !== space) {\\n\\t\\t\\tvalues[sname] = convert[space][sname](values[space]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n};\\n\\nColor.prototype.setSpace = function (space, args) {\\n\\tvar vals = args[0];\\n\\n\\tif (vals === undefined) {\\n\\t\\t// color.rgb()\\n\\t\\treturn this.getValues(space);\\n\\t}\\n\\n\\t// color.rgb(10, 10, 10)\\n\\tif (typeof vals === 'number') {\\n\\t\\tvals = Array.prototype.slice.call(args);\\n\\t}\\n\\n\\tthis.setValues(space, vals);\\n\\treturn this;\\n};\\n\\nColor.prototype.setChannel = function (space, index, val) {\\n\\tvar svalues = this.values[space];\\n\\tif (val === undefined) {\\n\\t\\t// color.red()\\n\\t\\treturn svalues[index];\\n\\t} else if (val === svalues[index]) {\\n\\t\\t// color.red(color.red())\\n\\t\\treturn this;\\n\\t}\\n\\n\\t// color.red(100)\\n\\tsvalues[index] = val;\\n\\tthis.setValues(space, svalues);\\n\\n\\treturn this;\\n};\\n\\nif (typeof window !== 'undefined') {\\n\\twindow.Color = Color;\\n}\\n\\nmodule.exports = Color;\\n\\n},{\\\"1\\\":1,\\\"4\\\":4}],3:[function(require,module,exports){\\n/* MIT license */\\n\\nmodule.exports = {\\n  rgb2hsl: rgb2hsl,\\n  rgb2hsv: rgb2hsv,\\n  rgb2hwb: rgb2hwb,\\n  rgb2cmyk: rgb2cmyk,\\n  rgb2keyword: rgb2keyword,\\n  rgb2xyz: rgb2xyz,\\n  rgb2lab: rgb2lab,\\n  rgb2lch: rgb2lch,\\n\\n  hsl2rgb: hsl2rgb,\\n  hsl2hsv: hsl2hsv,\\n  hsl2hwb: hsl2hwb,\\n  hsl2cmyk: hsl2cmyk,\\n  hsl2keyword: hsl2keyword,\\n\\n  hsv2rgb: hsv2rgb,\\n  hsv2hsl: hsv2hsl,\\n  hsv2hwb: hsv2hwb,\\n  hsv2cmyk: hsv2cmyk,\\n  hsv2keyword: hsv2keyword,\\n\\n  hwb2rgb: hwb2rgb,\\n  hwb2hsl: hwb2hsl,\\n  hwb2hsv: hwb2hsv,\\n  hwb2cmyk: hwb2cmyk,\\n  hwb2keyword: hwb2keyword,\\n\\n  cmyk2rgb: cmyk2rgb,\\n  cmyk2hsl: cmyk2hsl,\\n  cmyk2hsv: cmyk2hsv,\\n  cmyk2hwb: cmyk2hwb,\\n  cmyk2keyword: cmyk2keyword,\\n\\n  keyword2rgb: keyword2rgb,\\n  keyword2hsl: keyword2hsl,\\n  keyword2hsv: keyword2hsv,\\n  keyword2hwb: keyword2hwb,\\n  keyword2cmyk: keyword2cmyk,\\n  keyword2lab: keyword2lab,\\n  keyword2xyz: keyword2xyz,\\n\\n  xyz2rgb: xyz2rgb,\\n  xyz2lab: xyz2lab,\\n  xyz2lch: xyz2lch,\\n\\n  lab2xyz: lab2xyz,\\n  lab2rgb: lab2rgb,\\n  lab2lch: lab2lch,\\n\\n  lch2lab: lch2lab,\\n  lch2xyz: lch2xyz,\\n  lch2rgb: lch2rgb\\n}\\n\\n\\nfunction rgb2hsl(rgb) {\\n  var r = rgb[0]/255,\\n      g = rgb[1]/255,\\n      b = rgb[2]/255,\\n      min = Math.min(r, g, b),\\n      max = Math.max(r, g, b),\\n      delta = max - min,\\n      h, s, l;\\n\\n  if (max == min)\\n    h = 0;\\n  else if (r == max)\\n    h = (g - b) / delta;\\n  else if (g == max)\\n    h = 2 + (b - r) / delta;\\n  else if (b == max)\\n    h = 4 + (r - g)/ delta;\\n\\n  h = Math.min(h * 60, 360);\\n\\n  if (h < 0)\\n    h += 360;\\n\\n  l = (min + max) / 2;\\n\\n  if (max == min)\\n    s = 0;\\n  else if (l <= 0.5)\\n    s = delta / (max + min);\\n  else\\n    s = delta / (2 - max - min);\\n\\n  return [h, s * 100, l * 100];\\n}\\n\\nfunction rgb2hsv(rgb) {\\n  var r = rgb[0],\\n      g = rgb[1],\\n      b = rgb[2],\\n      min = Math.min(r, g, b),\\n      max = Math.max(r, g, b),\\n      delta = max - min,\\n      h, s, v;\\n\\n  if (max == 0)\\n    s = 0;\\n  else\\n    s = (delta/max * 1000)/10;\\n\\n  if (max == min)\\n    h = 0;\\n  else if (r == max)\\n    h = (g - b) / delta;\\n  else if (g == max)\\n    h = 2 + (b - r) / delta;\\n  else if (b == max)\\n    h = 4 + (r - g) / delta;\\n\\n  h = Math.min(h * 60, 360);\\n\\n  if (h < 0)\\n    h += 360;\\n\\n  v = ((max / 255) * 1000) / 10;\\n\\n  return [h, s, v];\\n}\\n\\nfunction rgb2hwb(rgb) {\\n  var r = rgb[0],\\n      g = rgb[1],\\n      b = rgb[2],\\n      h = rgb2hsl(rgb)[0],\\n      w = 1/255 * Math.min(r, Math.min(g, b)),\\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\\n\\n  return [h, w * 100, b * 100];\\n}\\n\\nfunction rgb2cmyk(rgb) {\\n  var r = rgb[0] / 255,\\n      g = rgb[1] / 255,\\n      b = rgb[2] / 255,\\n      c, m, y, k;\\n\\n  k = Math.min(1 - r, 1 - g, 1 - b);\\n  c = (1 - r - k) / (1 - k) || 0;\\n  m = (1 - g - k) / (1 - k) || 0;\\n  y = (1 - b - k) / (1 - k) || 0;\\n  return [c * 100, m * 100, y * 100, k * 100];\\n}\\n\\nfunction rgb2keyword(rgb) {\\n  return reverseKeywords[JSON.stringify(rgb)];\\n}\\n\\nfunction rgb2xyz(rgb) {\\n  var r = rgb[0] / 255,\\n      g = rgb[1] / 255,\\n      b = rgb[2] / 255;\\n\\n  // assume sRGB\\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\\n\\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\\n\\n  return [x * 100, y *100, z * 100];\\n}\\n\\nfunction rgb2lab(rgb) {\\n  var xyz = rgb2xyz(rgb),\\n        x = xyz[0],\\n        y = xyz[1],\\n        z = xyz[2],\\n        l, a, b;\\n\\n  x /= 95.047;\\n  y /= 100;\\n  z /= 108.883;\\n\\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\\n\\n  l = (116 * y) - 16;\\n  a = 500 * (x - y);\\n  b = 200 * (y - z);\\n\\n  return [l, a, b];\\n}\\n\\nfunction rgb2lch(args) {\\n  return lab2lch(rgb2lab(args));\\n}\\n\\nfunction hsl2rgb(hsl) {\\n  var h = hsl[0] / 360,\\n      s = hsl[1] / 100,\\n      l = hsl[2] / 100,\\n      t1, t2, t3, rgb, val;\\n\\n  if (s == 0) {\\n    val = l * 255;\\n    return [val, val, val];\\n  }\\n\\n  if (l < 0.5)\\n    t2 = l * (1 + s);\\n  else\\n    t2 = l + s - l * s;\\n  t1 = 2 * l - t2;\\n\\n  rgb = [0, 0, 0];\\n  for (var i = 0; i < 3; i++) {\\n    t3 = h + 1 / 3 * - (i - 1);\\n    t3 < 0 && t3++;\\n    t3 > 1 && t3--;\\n\\n    if (6 * t3 < 1)\\n      val = t1 + (t2 - t1) * 6 * t3;\\n    else if (2 * t3 < 1)\\n      val = t2;\\n    else if (3 * t3 < 2)\\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\\n    else\\n      val = t1;\\n\\n    rgb[i] = val * 255;\\n  }\\n\\n  return rgb;\\n}\\n\\nfunction hsl2hsv(hsl) {\\n  var h = hsl[0],\\n      s = hsl[1] / 100,\\n      l = hsl[2] / 100,\\n      sv, v;\\n\\n  if(l === 0) {\\n      // no need to do calc on black\\n      // also avoids divide by 0 error\\n      return [0, 0, 0];\\n  }\\n\\n  l *= 2;\\n  s *= (l <= 1) ? l : 2 - l;\\n  v = (l + s) / 2;\\n  sv = (2 * s) / (l + s);\\n  return [h, sv * 100, v * 100];\\n}\\n\\nfunction hsl2hwb(args) {\\n  return rgb2hwb(hsl2rgb(args));\\n}\\n\\nfunction hsl2cmyk(args) {\\n  return rgb2cmyk(hsl2rgb(args));\\n}\\n\\nfunction hsl2keyword(args) {\\n  return rgb2keyword(hsl2rgb(args));\\n}\\n\\n\\nfunction hsv2rgb(hsv) {\\n  var h = hsv[0] / 60,\\n      s = hsv[1] / 100,\\n      v = hsv[2] / 100,\\n      hi = Math.floor(h) % 6;\\n\\n  var f = h - Math.floor(h),\\n      p = 255 * v * (1 - s),\\n      q = 255 * v * (1 - (s * f)),\\n      t = 255 * v * (1 - (s * (1 - f))),\\n      v = 255 * v;\\n\\n  switch(hi) {\\n    case 0:\\n      return [v, t, p];\\n    case 1:\\n      return [q, v, p];\\n    case 2:\\n      return [p, v, t];\\n    case 3:\\n      return [p, q, v];\\n    case 4:\\n      return [t, p, v];\\n    case 5:\\n      return [v, p, q];\\n  }\\n}\\n\\nfunction hsv2hsl(hsv) {\\n  var h = hsv[0],\\n      s = hsv[1] / 100,\\n      v = hsv[2] / 100,\\n      sl, l;\\n\\n  l = (2 - s) * v;\\n  sl = s * v;\\n  sl /= (l <= 1) ? l : 2 - l;\\n  sl = sl || 0;\\n  l /= 2;\\n  return [h, sl * 100, l * 100];\\n}\\n\\nfunction hsv2hwb(args) {\\n  return rgb2hwb(hsv2rgb(args))\\n}\\n\\nfunction hsv2cmyk(args) {\\n  return rgb2cmyk(hsv2rgb(args));\\n}\\n\\nfunction hsv2keyword(args) {\\n  return rgb2keyword(hsv2rgb(args));\\n}\\n\\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\\nfunction hwb2rgb(hwb) {\\n  var h = hwb[0] / 360,\\n      wh = hwb[1] / 100,\\n      bl = hwb[2] / 100,\\n      ratio = wh + bl,\\n      i, v, f, n;\\n\\n  // wh + bl cant be > 1\\n  if (ratio > 1) {\\n    wh /= ratio;\\n    bl /= ratio;\\n  }\\n\\n  i = Math.floor(6 * h);\\n  v = 1 - bl;\\n  f = 6 * h - i;\\n  if ((i & 0x01) != 0) {\\n    f = 1 - f;\\n  }\\n  n = wh + f * (v - wh);  // linear interpolation\\n\\n  switch (i) {\\n    default:\\n    case 6:\\n    case 0: r = v; g = n; b = wh; break;\\n    case 1: r = n; g = v; b = wh; break;\\n    case 2: r = wh; g = v; b = n; break;\\n    case 3: r = wh; g = n; b = v; break;\\n    case 4: r = n; g = wh; b = v; break;\\n    case 5: r = v; g = wh; b = n; break;\\n  }\\n\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction hwb2hsl(args) {\\n  return rgb2hsl(hwb2rgb(args));\\n}\\n\\nfunction hwb2hsv(args) {\\n  return rgb2hsv(hwb2rgb(args));\\n}\\n\\nfunction hwb2cmyk(args) {\\n  return rgb2cmyk(hwb2rgb(args));\\n}\\n\\nfunction hwb2keyword(args) {\\n  return rgb2keyword(hwb2rgb(args));\\n}\\n\\nfunction cmyk2rgb(cmyk) {\\n  var c = cmyk[0] / 100,\\n      m = cmyk[1] / 100,\\n      y = cmyk[2] / 100,\\n      k = cmyk[3] / 100,\\n      r, g, b;\\n\\n  r = 1 - Math.min(1, c * (1 - k) + k);\\n  g = 1 - Math.min(1, m * (1 - k) + k);\\n  b = 1 - Math.min(1, y * (1 - k) + k);\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction cmyk2hsl(args) {\\n  return rgb2hsl(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2hsv(args) {\\n  return rgb2hsv(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2hwb(args) {\\n  return rgb2hwb(cmyk2rgb(args));\\n}\\n\\nfunction cmyk2keyword(args) {\\n  return rgb2keyword(cmyk2rgb(args));\\n}\\n\\n\\nfunction xyz2rgb(xyz) {\\n  var x = xyz[0] / 100,\\n      y = xyz[1] / 100,\\n      z = xyz[2] / 100,\\n      r, g, b;\\n\\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\\n\\n  // assume sRGB\\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\\n    : r = (r * 12.92);\\n\\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\\n    : g = (g * 12.92);\\n\\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\\n    : b = (b * 12.92);\\n\\n  r = Math.min(Math.max(0, r), 1);\\n  g = Math.min(Math.max(0, g), 1);\\n  b = Math.min(Math.max(0, b), 1);\\n\\n  return [r * 255, g * 255, b * 255];\\n}\\n\\nfunction xyz2lab(xyz) {\\n  var x = xyz[0],\\n      y = xyz[1],\\n      z = xyz[2],\\n      l, a, b;\\n\\n  x /= 95.047;\\n  y /= 100;\\n  z /= 108.883;\\n\\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\\n\\n  l = (116 * y) - 16;\\n  a = 500 * (x - y);\\n  b = 200 * (y - z);\\n\\n  return [l, a, b];\\n}\\n\\nfunction xyz2lch(args) {\\n  return lab2lch(xyz2lab(args));\\n}\\n\\nfunction lab2xyz(lab) {\\n  var l = lab[0],\\n      a = lab[1],\\n      b = lab[2],\\n      x, y, z, y2;\\n\\n  if (l <= 8) {\\n    y = (l * 100) / 903.3;\\n    y2 = (7.787 * (y / 100)) + (16 / 116);\\n  } else {\\n    y = 100 * Math.pow((l + 16) / 116, 3);\\n    y2 = Math.pow(y / 100, 1/3);\\n  }\\n\\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\\n\\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\\n\\n  return [x, y, z];\\n}\\n\\nfunction lab2lch(lab) {\\n  var l = lab[0],\\n      a = lab[1],\\n      b = lab[2],\\n      hr, h, c;\\n\\n  hr = Math.atan2(b, a);\\n  h = hr * 360 / 2 / Math.PI;\\n  if (h < 0) {\\n    h += 360;\\n  }\\n  c = Math.sqrt(a * a + b * b);\\n  return [l, c, h];\\n}\\n\\nfunction lab2rgb(args) {\\n  return xyz2rgb(lab2xyz(args));\\n}\\n\\nfunction lch2lab(lch) {\\n  var l = lch[0],\\n      c = lch[1],\\n      h = lch[2],\\n      a, b, hr;\\n\\n  hr = h / 360 * 2 * Math.PI;\\n  a = c * Math.cos(hr);\\n  b = c * Math.sin(hr);\\n  return [l, a, b];\\n}\\n\\nfunction lch2xyz(args) {\\n  return lab2xyz(lch2lab(args));\\n}\\n\\nfunction lch2rgb(args) {\\n  return lab2rgb(lch2lab(args));\\n}\\n\\nfunction keyword2rgb(keyword) {\\n  return cssKeywords[keyword];\\n}\\n\\nfunction keyword2hsl(args) {\\n  return rgb2hsl(keyword2rgb(args));\\n}\\n\\nfunction keyword2hsv(args) {\\n  return rgb2hsv(keyword2rgb(args));\\n}\\n\\nfunction keyword2hwb(args) {\\n  return rgb2hwb(keyword2rgb(args));\\n}\\n\\nfunction keyword2cmyk(args) {\\n  return rgb2cmyk(keyword2rgb(args));\\n}\\n\\nfunction keyword2lab(args) {\\n  return rgb2lab(keyword2rgb(args));\\n}\\n\\nfunction keyword2xyz(args) {\\n  return rgb2xyz(keyword2rgb(args));\\n}\\n\\nvar cssKeywords = {\\n  aliceblue:  [240,248,255],\\n  antiquewhite: [250,235,215],\\n  aqua: [0,255,255],\\n  aquamarine: [127,255,212],\\n  azure:  [240,255,255],\\n  beige:  [245,245,220],\\n  bisque: [255,228,196],\\n  black:  [0,0,0],\\n  blanchedalmond: [255,235,205],\\n  blue: [0,0,255],\\n  blueviolet: [138,43,226],\\n  brown:  [165,42,42],\\n  burlywood:  [222,184,135],\\n  cadetblue:  [95,158,160],\\n  chartreuse: [127,255,0],\\n  chocolate:  [210,105,30],\\n  coral:  [255,127,80],\\n  cornflowerblue: [100,149,237],\\n  cornsilk: [255,248,220],\\n  crimson:  [220,20,60],\\n  cyan: [0,255,255],\\n  darkblue: [0,0,139],\\n  darkcyan: [0,139,139],\\n  darkgoldenrod:  [184,134,11],\\n  darkgray: [169,169,169],\\n  darkgreen:  [0,100,0],\\n  darkgrey: [169,169,169],\\n  darkkhaki:  [189,183,107],\\n  darkmagenta:  [139,0,139],\\n  darkolivegreen: [85,107,47],\\n  darkorange: [255,140,0],\\n  darkorchid: [153,50,204],\\n  darkred:  [139,0,0],\\n  darksalmon: [233,150,122],\\n  darkseagreen: [143,188,143],\\n  darkslateblue:  [72,61,139],\\n  darkslategray:  [47,79,79],\\n  darkslategrey:  [47,79,79],\\n  darkturquoise:  [0,206,209],\\n  darkviolet: [148,0,211],\\n  deeppink: [255,20,147],\\n  deepskyblue:  [0,191,255],\\n  dimgray:  [105,105,105],\\n  dimgrey:  [105,105,105],\\n  dodgerblue: [30,144,255],\\n  firebrick:  [178,34,34],\\n  floralwhite:  [255,250,240],\\n  forestgreen:  [34,139,34],\\n  fuchsia:  [255,0,255],\\n  gainsboro:  [220,220,220],\\n  ghostwhite: [248,248,255],\\n  gold: [255,215,0],\\n  goldenrod:  [218,165,32],\\n  gray: [128,128,128],\\n  green:  [0,128,0],\\n  greenyellow:  [173,255,47],\\n  grey: [128,128,128],\\n  honeydew: [240,255,240],\\n  hotpink:  [255,105,180],\\n  indianred:  [205,92,92],\\n  indigo: [75,0,130],\\n  ivory:  [255,255,240],\\n  khaki:  [240,230,140],\\n  lavender: [230,230,250],\\n  lavenderblush:  [255,240,245],\\n  lawngreen:  [124,252,0],\\n  lemonchiffon: [255,250,205],\\n  lightblue:  [173,216,230],\\n  lightcoral: [240,128,128],\\n  lightcyan:  [224,255,255],\\n  lightgoldenrodyellow: [250,250,210],\\n  lightgray:  [211,211,211],\\n  lightgreen: [144,238,144],\\n  lightgrey:  [211,211,211],\\n  lightpink:  [255,182,193],\\n  lightsalmon:  [255,160,122],\\n  lightseagreen:  [32,178,170],\\n  lightskyblue: [135,206,250],\\n  lightslategray: [119,136,153],\\n  lightslategrey: [119,136,153],\\n  lightsteelblue: [176,196,222],\\n  lightyellow:  [255,255,224],\\n  lime: [0,255,0],\\n  limegreen:  [50,205,50],\\n  linen:  [250,240,230],\\n  magenta:  [255,0,255],\\n  maroon: [128,0,0],\\n  mediumaquamarine: [102,205,170],\\n  mediumblue: [0,0,205],\\n  mediumorchid: [186,85,211],\\n  mediumpurple: [147,112,219],\\n  mediumseagreen: [60,179,113],\\n  mediumslateblue:  [123,104,238],\\n  mediumspringgreen:  [0,250,154],\\n  mediumturquoise:  [72,209,204],\\n  mediumvioletred:  [199,21,133],\\n  midnightblue: [25,25,112],\\n  mintcream:  [245,255,250],\\n  mistyrose:  [255,228,225],\\n  moccasin: [255,228,181],\\n  navajowhite:  [255,222,173],\\n  navy: [0,0,128],\\n  oldlace:  [253,245,230],\\n  olive:  [128,128,0],\\n  olivedrab:  [107,142,35],\\n  orange: [255,165,0],\\n  orangered:  [255,69,0],\\n  orchid: [218,112,214],\\n  palegoldenrod:  [238,232,170],\\n  palegreen:  [152,251,152],\\n  paleturquoise:  [175,238,238],\\n  palevioletred:  [219,112,147],\\n  papayawhip: [255,239,213],\\n  peachpuff:  [255,218,185],\\n  peru: [205,133,63],\\n  pink: [255,192,203],\\n  plum: [221,160,221],\\n  powderblue: [176,224,230],\\n  purple: [128,0,128],\\n  rebeccapurple: [102, 51, 153],\\n  red:  [255,0,0],\\n  rosybrown:  [188,143,143],\\n  royalblue:  [65,105,225],\\n  saddlebrown:  [139,69,19],\\n  salmon: [250,128,114],\\n  sandybrown: [244,164,96],\\n  seagreen: [46,139,87],\\n  seashell: [255,245,238],\\n  sienna: [160,82,45],\\n  silver: [192,192,192],\\n  skyblue:  [135,206,235],\\n  slateblue:  [106,90,205],\\n  slategray:  [112,128,144],\\n  slategrey:  [112,128,144],\\n  snow: [255,250,250],\\n  springgreen:  [0,255,127],\\n  steelblue:  [70,130,180],\\n  tan:  [210,180,140],\\n  teal: [0,128,128],\\n  thistle:  [216,191,216],\\n  tomato: [255,99,71],\\n  turquoise:  [64,224,208],\\n  violet: [238,130,238],\\n  wheat:  [245,222,179],\\n  white:  [255,255,255],\\n  whitesmoke: [245,245,245],\\n  yellow: [255,255,0],\\n  yellowgreen:  [154,205,50]\\n};\\n\\nvar reverseKeywords = {};\\nfor (var key in cssKeywords) {\\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\\n}\\n\\n},{}],4:[function(require,module,exports){\\nvar conversions = require(3);\\n\\nvar convert = function() {\\n   return new Converter();\\n}\\n\\nfor (var func in conversions) {\\n  // export Raw versions\\n  convert[func + \\\"Raw\\\"] =  (function(func) {\\n    // accept array or plain args\\n    return function(arg) {\\n      if (typeof arg == \\\"number\\\")\\n        arg = Array.prototype.slice.call(arguments);\\n      return conversions[func](arg);\\n    }\\n  })(func);\\n\\n  var pair = /(\\\\w+)2(\\\\w+)/.exec(func),\\n      from = pair[1],\\n      to = pair[2];\\n\\n  // export rgb2hsl and [\\\"rgb\\\"][\\\"hsl\\\"]\\n  convert[from] = convert[from] || {};\\n\\n  convert[from][to] = convert[func] = (function(func) { \\n    return function(arg) {\\n      if (typeof arg == \\\"number\\\")\\n        arg = Array.prototype.slice.call(arguments);\\n      \\n      var val = conversions[func](arg);\\n      if (typeof val == \\\"string\\\" || val === undefined)\\n        return val; // keyword\\n\\n      for (var i = 0; i < val.length; i++)\\n        val[i] = Math.round(val[i]);\\n      return val;\\n    }\\n  })(func);\\n}\\n\\n\\n/* Converter does lazy conversion and caching */\\nvar Converter = function() {\\n   this.convs = {};\\n};\\n\\n/* Either get the values for a space or\\n  set the values for a space, depending on args */\\nConverter.prototype.routeSpace = function(space, args) {\\n   var values = args[0];\\n   if (values === undefined) {\\n      // color.rgb()\\n      return this.getValues(space);\\n   }\\n   // color.rgb(10, 10, 10)\\n   if (typeof values == \\\"number\\\") {\\n      values = Array.prototype.slice.call(args);        \\n   }\\n\\n   return this.setValues(space, values);\\n};\\n  \\n/* Set the values for a space, invalidating cache */\\nConverter.prototype.setValues = function(space, values) {\\n   this.space = space;\\n   this.convs = {};\\n   this.convs[space] = values;\\n   return this;\\n};\\n\\n/* Get the values for a space. If there's already\\n  a conversion for the space, fetch it, otherwise\\n  compute it */\\nConverter.prototype.getValues = function(space) {\\n   var vals = this.convs[space];\\n   if (!vals) {\\n      var fspace = this.space,\\n          from = this.convs[fspace];\\n      vals = convert[fspace][space](from);\\n\\n      this.convs[space] = vals;\\n   }\\n  return vals;\\n};\\n\\n[\\\"rgb\\\", \\\"hsl\\\", \\\"hsv\\\", \\\"cmyk\\\", \\\"keyword\\\"].forEach(function(space) {\\n   Converter.prototype[space] = function(vals) {\\n      return this.routeSpace(space, arguments);\\n   }\\n});\\n\\nmodule.exports = convert;\\n},{\\\"3\\\":3}],5:[function(require,module,exports){\\nmodule.exports = {\\n\\t\\\"aliceblue\\\": [240, 248, 255],\\n\\t\\\"antiquewhite\\\": [250, 235, 215],\\n\\t\\\"aqua\\\": [0, 255, 255],\\n\\t\\\"aquamarine\\\": [127, 255, 212],\\n\\t\\\"azure\\\": [240, 255, 255],\\n\\t\\\"beige\\\": [245, 245, 220],\\n\\t\\\"bisque\\\": [255, 228, 196],\\n\\t\\\"black\\\": [0, 0, 0],\\n\\t\\\"blanchedalmond\\\": [255, 235, 205],\\n\\t\\\"blue\\\": [0, 0, 255],\\n\\t\\\"blueviolet\\\": [138, 43, 226],\\n\\t\\\"brown\\\": [165, 42, 42],\\n\\t\\\"burlywood\\\": [222, 184, 135],\\n\\t\\\"cadetblue\\\": [95, 158, 160],\\n\\t\\\"chartreuse\\\": [127, 255, 0],\\n\\t\\\"chocolate\\\": [210, 105, 30],\\n\\t\\\"coral\\\": [255, 127, 80],\\n\\t\\\"cornflowerblue\\\": [100, 149, 237],\\n\\t\\\"cornsilk\\\": [255, 248, 220],\\n\\t\\\"crimson\\\": [220, 20, 60],\\n\\t\\\"cyan\\\": [0, 255, 255],\\n\\t\\\"darkblue\\\": [0, 0, 139],\\n\\t\\\"darkcyan\\\": [0, 139, 139],\\n\\t\\\"darkgoldenrod\\\": [184, 134, 11],\\n\\t\\\"darkgray\\\": [169, 169, 169],\\n\\t\\\"darkgreen\\\": [0, 100, 0],\\n\\t\\\"darkgrey\\\": [169, 169, 169],\\n\\t\\\"darkkhaki\\\": [189, 183, 107],\\n\\t\\\"darkmagenta\\\": [139, 0, 139],\\n\\t\\\"darkolivegreen\\\": [85, 107, 47],\\n\\t\\\"darkorange\\\": [255, 140, 0],\\n\\t\\\"darkorchid\\\": [153, 50, 204],\\n\\t\\\"darkred\\\": [139, 0, 0],\\n\\t\\\"darksalmon\\\": [233, 150, 122],\\n\\t\\\"darkseagreen\\\": [143, 188, 143],\\n\\t\\\"darkslateblue\\\": [72, 61, 139],\\n\\t\\\"darkslategray\\\": [47, 79, 79],\\n\\t\\\"darkslategrey\\\": [47, 79, 79],\\n\\t\\\"darkturquoise\\\": [0, 206, 209],\\n\\t\\\"darkviolet\\\": [148, 0, 211],\\n\\t\\\"deeppink\\\": [255, 20, 147],\\n\\t\\\"deepskyblue\\\": [0, 191, 255],\\n\\t\\\"dimgray\\\": [105, 105, 105],\\n\\t\\\"dimgrey\\\": [105, 105, 105],\\n\\t\\\"dodgerblue\\\": [30, 144, 255],\\n\\t\\\"firebrick\\\": [178, 34, 34],\\n\\t\\\"floralwhite\\\": [255, 250, 240],\\n\\t\\\"forestgreen\\\": [34, 139, 34],\\n\\t\\\"fuchsia\\\": [255, 0, 255],\\n\\t\\\"gainsboro\\\": [220, 220, 220],\\n\\t\\\"ghostwhite\\\": [248, 248, 255],\\n\\t\\\"gold\\\": [255, 215, 0],\\n\\t\\\"goldenrod\\\": [218, 165, 32],\\n\\t\\\"gray\\\": [128, 128, 128],\\n\\t\\\"green\\\": [0, 128, 0],\\n\\t\\\"greenyellow\\\": [173, 255, 47],\\n\\t\\\"grey\\\": [128, 128, 128],\\n\\t\\\"honeydew\\\": [240, 255, 240],\\n\\t\\\"hotpink\\\": [255, 105, 180],\\n\\t\\\"indianred\\\": [205, 92, 92],\\n\\t\\\"indigo\\\": [75, 0, 130],\\n\\t\\\"ivory\\\": [255, 255, 240],\\n\\t\\\"khaki\\\": [240, 230, 140],\\n\\t\\\"lavender\\\": [230, 230, 250],\\n\\t\\\"lavenderblush\\\": [255, 240, 245],\\n\\t\\\"lawngreen\\\": [124, 252, 0],\\n\\t\\\"lemonchiffon\\\": [255, 250, 205],\\n\\t\\\"lightblue\\\": [173, 216, 230],\\n\\t\\\"lightcoral\\\": [240, 128, 128],\\n\\t\\\"lightcyan\\\": [224, 255, 255],\\n\\t\\\"lightgoldenrodyellow\\\": [250, 250, 210],\\n\\t\\\"lightgray\\\": [211, 211, 211],\\n\\t\\\"lightgreen\\\": [144, 238, 144],\\n\\t\\\"lightgrey\\\": [211, 211, 211],\\n\\t\\\"lightpink\\\": [255, 182, 193],\\n\\t\\\"lightsalmon\\\": [255, 160, 122],\\n\\t\\\"lightseagreen\\\": [32, 178, 170],\\n\\t\\\"lightskyblue\\\": [135, 206, 250],\\n\\t\\\"lightslategray\\\": [119, 136, 153],\\n\\t\\\"lightslategrey\\\": [119, 136, 153],\\n\\t\\\"lightsteelblue\\\": [176, 196, 222],\\n\\t\\\"lightyellow\\\": [255, 255, 224],\\n\\t\\\"lime\\\": [0, 255, 0],\\n\\t\\\"limegreen\\\": [50, 205, 50],\\n\\t\\\"linen\\\": [250, 240, 230],\\n\\t\\\"magenta\\\": [255, 0, 255],\\n\\t\\\"maroon\\\": [128, 0, 0],\\n\\t\\\"mediumaquamarine\\\": [102, 205, 170],\\n\\t\\\"mediumblue\\\": [0, 0, 205],\\n\\t\\\"mediumorchid\\\": [186, 85, 211],\\n\\t\\\"mediumpurple\\\": [147, 112, 219],\\n\\t\\\"mediumseagreen\\\": [60, 179, 113],\\n\\t\\\"mediumslateblue\\\": [123, 104, 238],\\n\\t\\\"mediumspringgreen\\\": [0, 250, 154],\\n\\t\\\"mediumturquoise\\\": [72, 209, 204],\\n\\t\\\"mediumvioletred\\\": [199, 21, 133],\\n\\t\\\"midnightblue\\\": [25, 25, 112],\\n\\t\\\"mintcream\\\": [245, 255, 250],\\n\\t\\\"mistyrose\\\": [255, 228, 225],\\n\\t\\\"moccasin\\\": [255, 228, 181],\\n\\t\\\"navajowhite\\\": [255, 222, 173],\\n\\t\\\"navy\\\": [0, 0, 128],\\n\\t\\\"oldlace\\\": [253, 245, 230],\\n\\t\\\"olive\\\": [128, 128, 0],\\n\\t\\\"olivedrab\\\": [107, 142, 35],\\n\\t\\\"orange\\\": [255, 165, 0],\\n\\t\\\"orangered\\\": [255, 69, 0],\\n\\t\\\"orchid\\\": [218, 112, 214],\\n\\t\\\"palegoldenrod\\\": [238, 232, 170],\\n\\t\\\"palegreen\\\": [152, 251, 152],\\n\\t\\\"paleturquoise\\\": [175, 238, 238],\\n\\t\\\"palevioletred\\\": [219, 112, 147],\\n\\t\\\"papayawhip\\\": [255, 239, 213],\\n\\t\\\"peachpuff\\\": [255, 218, 185],\\n\\t\\\"peru\\\": [205, 133, 63],\\n\\t\\\"pink\\\": [255, 192, 203],\\n\\t\\\"plum\\\": [221, 160, 221],\\n\\t\\\"powderblue\\\": [176, 224, 230],\\n\\t\\\"purple\\\": [128, 0, 128],\\n\\t\\\"rebeccapurple\\\": [102, 51, 153],\\n\\t\\\"red\\\": [255, 0, 0],\\n\\t\\\"rosybrown\\\": [188, 143, 143],\\n\\t\\\"royalblue\\\": [65, 105, 225],\\n\\t\\\"saddlebrown\\\": [139, 69, 19],\\n\\t\\\"salmon\\\": [250, 128, 114],\\n\\t\\\"sandybrown\\\": [244, 164, 96],\\n\\t\\\"seagreen\\\": [46, 139, 87],\\n\\t\\\"seashell\\\": [255, 245, 238],\\n\\t\\\"sienna\\\": [160, 82, 45],\\n\\t\\\"silver\\\": [192, 192, 192],\\n\\t\\\"skyblue\\\": [135, 206, 235],\\n\\t\\\"slateblue\\\": [106, 90, 205],\\n\\t\\\"slategray\\\": [112, 128, 144],\\n\\t\\\"slategrey\\\": [112, 128, 144],\\n\\t\\\"snow\\\": [255, 250, 250],\\n\\t\\\"springgreen\\\": [0, 255, 127],\\n\\t\\\"steelblue\\\": [70, 130, 180],\\n\\t\\\"tan\\\": [210, 180, 140],\\n\\t\\\"teal\\\": [0, 128, 128],\\n\\t\\\"thistle\\\": [216, 191, 216],\\n\\t\\\"tomato\\\": [255, 99, 71],\\n\\t\\\"turquoise\\\": [64, 224, 208],\\n\\t\\\"violet\\\": [238, 130, 238],\\n\\t\\\"wheat\\\": [245, 222, 179],\\n\\t\\\"white\\\": [255, 255, 255],\\n\\t\\\"whitesmoke\\\": [245, 245, 245],\\n\\t\\\"yellow\\\": [255, 255, 0],\\n\\t\\\"yellowgreen\\\": [154, 205, 50]\\n};\\n},{}],6:[function(require,module,exports){\\n//! moment.js\\n//! version : 2.17.1\\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\\n//! license : MIT\\n//! momentjs.com\\n\\n;(function (global, factory) {\\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n    typeof define === 'function' && define.amd ? define(factory) :\\n    global.moment = factory()\\n}(this, (function () { 'use strict';\\n\\nvar hookCallback;\\n\\nfunction hooks () {\\n    return hookCallback.apply(null, arguments);\\n}\\n\\n// This is done to register the method called with moment()\\n// without creating circular dependencies.\\nfunction setHookCallback (callback) {\\n    hookCallback = callback;\\n}\\n\\nfunction isArray(input) {\\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\\n}\\n\\nfunction isObject(input) {\\n    // IE8 will treat undefined and null as object if it wasn't for\\n    // input != null\\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\\n}\\n\\nfunction isObjectEmpty(obj) {\\n    var k;\\n    for (k in obj) {\\n        // even if its not own property I'd still call it non-empty\\n        return false;\\n    }\\n    return true;\\n}\\n\\nfunction isNumber(input) {\\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\\n}\\n\\nfunction isDate(input) {\\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\\n}\\n\\nfunction map(arr, fn) {\\n    var res = [], i;\\n    for (i = 0; i < arr.length; ++i) {\\n        res.push(fn(arr[i], i));\\n    }\\n    return res;\\n}\\n\\nfunction hasOwnProp(a, b) {\\n    return Object.prototype.hasOwnProperty.call(a, b);\\n}\\n\\nfunction extend(a, b) {\\n    for (var i in b) {\\n        if (hasOwnProp(b, i)) {\\n            a[i] = b[i];\\n        }\\n    }\\n\\n    if (hasOwnProp(b, 'toString')) {\\n        a.toString = b.toString;\\n    }\\n\\n    if (hasOwnProp(b, 'valueOf')) {\\n        a.valueOf = b.valueOf;\\n    }\\n\\n    return a;\\n}\\n\\nfunction createUTC (input, format, locale, strict) {\\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\\n}\\n\\nfunction defaultParsingFlags() {\\n    // We need to deep clone this object.\\n    return {\\n        empty           : false,\\n        unusedTokens    : [],\\n        unusedInput     : [],\\n        overflow        : -2,\\n        charsLeftOver   : 0,\\n        nullInput       : false,\\n        invalidMonth    : null,\\n        invalidFormat   : false,\\n        userInvalidated : false,\\n        iso             : false,\\n        parsedDateParts : [],\\n        meridiem        : null\\n    };\\n}\\n\\nfunction getParsingFlags(m) {\\n    if (m._pf == null) {\\n        m._pf = defaultParsingFlags();\\n    }\\n    return m._pf;\\n}\\n\\nvar some;\\nif (Array.prototype.some) {\\n    some = Array.prototype.some;\\n} else {\\n    some = function (fun) {\\n        var t = Object(this);\\n        var len = t.length >>> 0;\\n\\n        for (var i = 0; i < len; i++) {\\n            if (i in t && fun.call(this, t[i], i, t)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    };\\n}\\n\\nvar some$1 = some;\\n\\nfunction isValid(m) {\\n    if (m._isValid == null) {\\n        var flags = getParsingFlags(m);\\n        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {\\n            return i != null;\\n        });\\n        var isNowValid = !isNaN(m._d.getTime()) &&\\n            flags.overflow < 0 &&\\n            !flags.empty &&\\n            !flags.invalidMonth &&\\n            !flags.invalidWeekday &&\\n            !flags.nullInput &&\\n            !flags.invalidFormat &&\\n            !flags.userInvalidated &&\\n            (!flags.meridiem || (flags.meridiem && parsedParts));\\n\\n        if (m._strict) {\\n            isNowValid = isNowValid &&\\n                flags.charsLeftOver === 0 &&\\n                flags.unusedTokens.length === 0 &&\\n                flags.bigHour === undefined;\\n        }\\n\\n        if (Object.isFrozen == null || !Object.isFrozen(m)) {\\n            m._isValid = isNowValid;\\n        }\\n        else {\\n            return isNowValid;\\n        }\\n    }\\n    return m._isValid;\\n}\\n\\nfunction createInvalid (flags) {\\n    var m = createUTC(NaN);\\n    if (flags != null) {\\n        extend(getParsingFlags(m), flags);\\n    }\\n    else {\\n        getParsingFlags(m).userInvalidated = true;\\n    }\\n\\n    return m;\\n}\\n\\nfunction isUndefined(input) {\\n    return input === void 0;\\n}\\n\\n// Plugins that add properties should also add the key here (null value),\\n// so we can properly clone ourselves.\\nvar momentProperties = hooks.momentProperties = [];\\n\\nfunction copyConfig(to, from) {\\n    var i, prop, val;\\n\\n    if (!isUndefined(from._isAMomentObject)) {\\n        to._isAMomentObject = from._isAMomentObject;\\n    }\\n    if (!isUndefined(from._i)) {\\n        to._i = from._i;\\n    }\\n    if (!isUndefined(from._f)) {\\n        to._f = from._f;\\n    }\\n    if (!isUndefined(from._l)) {\\n        to._l = from._l;\\n    }\\n    if (!isUndefined(from._strict)) {\\n        to._strict = from._strict;\\n    }\\n    if (!isUndefined(from._tzm)) {\\n        to._tzm = from._tzm;\\n    }\\n    if (!isUndefined(from._isUTC)) {\\n        to._isUTC = from._isUTC;\\n    }\\n    if (!isUndefined(from._offset)) {\\n        to._offset = from._offset;\\n    }\\n    if (!isUndefined(from._pf)) {\\n        to._pf = getParsingFlags(from);\\n    }\\n    if (!isUndefined(from._locale)) {\\n        to._locale = from._locale;\\n    }\\n\\n    if (momentProperties.length > 0) {\\n        for (i in momentProperties) {\\n            prop = momentProperties[i];\\n            val = from[prop];\\n            if (!isUndefined(val)) {\\n                to[prop] = val;\\n            }\\n        }\\n    }\\n\\n    return to;\\n}\\n\\nvar updateInProgress = false;\\n\\n// Moment prototype object\\nfunction Moment(config) {\\n    copyConfig(this, config);\\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\\n    if (!this.isValid()) {\\n        this._d = new Date(NaN);\\n    }\\n    // Prevent infinite loop in case updateOffset creates new moment\\n    // objects.\\n    if (updateInProgress === false) {\\n        updateInProgress = true;\\n        hooks.updateOffset(this);\\n        updateInProgress = false;\\n    }\\n}\\n\\nfunction isMoment (obj) {\\n    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\\n}\\n\\nfunction absFloor (number) {\\n    if (number < 0) {\\n        // -0 -> 0\\n        return Math.ceil(number) || 0;\\n    } else {\\n        return Math.floor(number);\\n    }\\n}\\n\\nfunction toInt(argumentForCoercion) {\\n    var coercedNumber = +argumentForCoercion,\\n        value = 0;\\n\\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\\n        value = absFloor(coercedNumber);\\n    }\\n\\n    return value;\\n}\\n\\n// compare two arrays, return the number of differences\\nfunction compareArrays(array1, array2, dontConvert) {\\n    var len = Math.min(array1.length, array2.length),\\n        lengthDiff = Math.abs(array1.length - array2.length),\\n        diffs = 0,\\n        i;\\n    for (i = 0; i < len; i++) {\\n        if ((dontConvert && array1[i] !== array2[i]) ||\\n            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\\n            diffs++;\\n        }\\n    }\\n    return diffs + lengthDiff;\\n}\\n\\nfunction warn(msg) {\\n    if (hooks.suppressDeprecationWarnings === false &&\\n            (typeof console !==  'undefined') && console.warn) {\\n        console.warn('Deprecation warning: ' + msg);\\n    }\\n}\\n\\nfunction deprecate(msg, fn) {\\n    var firstTime = true;\\n\\n    return extend(function () {\\n        if (hooks.deprecationHandler != null) {\\n            hooks.deprecationHandler(null, msg);\\n        }\\n        if (firstTime) {\\n            var args = [];\\n            var arg;\\n            for (var i = 0; i < arguments.length; i++) {\\n                arg = '';\\n                if (typeof arguments[i] === 'object') {\\n                    arg += '\\\\n[' + i + '] ';\\n                    for (var key in arguments[0]) {\\n                        arg += key + ': ' + arguments[0][key] + ', ';\\n                    }\\n                    arg = arg.slice(0, -2); // Remove trailing comma and space\\n                } else {\\n                    arg = arguments[i];\\n                }\\n                args.push(arg);\\n            }\\n            warn(msg + '\\\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\\\n' + (new Error()).stack);\\n            firstTime = false;\\n        }\\n        return fn.apply(this, arguments);\\n    }, fn);\\n}\\n\\nvar deprecations = {};\\n\\nfunction deprecateSimple(name, msg) {\\n    if (hooks.deprecationHandler != null) {\\n        hooks.deprecationHandler(name, msg);\\n    }\\n    if (!deprecations[name]) {\\n        warn(msg);\\n        deprecations[name] = true;\\n    }\\n}\\n\\nhooks.suppressDeprecationWarnings = false;\\nhooks.deprecationHandler = null;\\n\\nfunction isFunction(input) {\\n    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\\n}\\n\\nfunction set (config) {\\n    var prop, i;\\n    for (i in config) {\\n        prop = config[i];\\n        if (isFunction(prop)) {\\n            this[i] = prop;\\n        } else {\\n            this['_' + i] = prop;\\n        }\\n    }\\n    this._config = config;\\n    // Lenient ordinal parsing accepts just a number in addition to\\n    // number + (possibly) stuff coming from _ordinalParseLenient.\\n    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\\\\d{1,2}/).source);\\n}\\n\\nfunction mergeConfigs(parentConfig, childConfig) {\\n    var res = extend({}, parentConfig), prop;\\n    for (prop in childConfig) {\\n        if (hasOwnProp(childConfig, prop)) {\\n            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\\n                res[prop] = {};\\n                extend(res[prop], parentConfig[prop]);\\n                extend(res[prop], childConfig[prop]);\\n            } else if (childConfig[prop] != null) {\\n                res[prop] = childConfig[prop];\\n            } else {\\n                delete res[prop];\\n            }\\n        }\\n    }\\n    for (prop in parentConfig) {\\n        if (hasOwnProp(parentConfig, prop) &&\\n                !hasOwnProp(childConfig, prop) &&\\n                isObject(parentConfig[prop])) {\\n            // make sure changes to properties don't modify parent config\\n            res[prop] = extend({}, res[prop]);\\n        }\\n    }\\n    return res;\\n}\\n\\nfunction Locale(config) {\\n    if (config != null) {\\n        this.set(config);\\n    }\\n}\\n\\nvar keys;\\n\\nif (Object.keys) {\\n    keys = Object.keys;\\n} else {\\n    keys = function (obj) {\\n        var i, res = [];\\n        for (i in obj) {\\n            if (hasOwnProp(obj, i)) {\\n                res.push(i);\\n            }\\n        }\\n        return res;\\n    };\\n}\\n\\nvar keys$1 = keys;\\n\\nvar defaultCalendar = {\\n    sameDay : '[Today at] LT',\\n    nextDay : '[Tomorrow at] LT',\\n    nextWeek : 'dddd [at] LT',\\n    lastDay : '[Yesterday at] LT',\\n    lastWeek : '[Last] dddd [at] LT',\\n    sameElse : 'L'\\n};\\n\\nfunction calendar (key, mom, now) {\\n    var output = this._calendar[key] || this._calendar['sameElse'];\\n    return isFunction(output) ? output.call(mom, now) : output;\\n}\\n\\nvar defaultLongDateFormat = {\\n    LTS  : 'h:mm:ss A',\\n    LT   : 'h:mm A',\\n    L    : 'MM/DD/YYYY',\\n    LL   : 'MMMM D, YYYY',\\n    LLL  : 'MMMM D, YYYY h:mm A',\\n    LLLL : 'dddd, MMMM D, YYYY h:mm A'\\n};\\n\\nfunction longDateFormat (key) {\\n    var format = this._longDateFormat[key],\\n        formatUpper = this._longDateFormat[key.toUpperCase()];\\n\\n    if (format || !formatUpper) {\\n        return format;\\n    }\\n\\n    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\\n        return val.slice(1);\\n    });\\n\\n    return this._longDateFormat[key];\\n}\\n\\nvar defaultInvalidDate = 'Invalid date';\\n\\nfunction invalidDate () {\\n    return this._invalidDate;\\n}\\n\\nvar defaultOrdinal = '%d';\\nvar defaultOrdinalParse = /\\\\d{1,2}/;\\n\\nfunction ordinal (number) {\\n    return this._ordinal.replace('%d', number);\\n}\\n\\nvar defaultRelativeTime = {\\n    future : 'in %s',\\n    past   : '%s ago',\\n    s  : 'a few seconds',\\n    m  : 'a minute',\\n    mm : '%d minutes',\\n    h  : 'an hour',\\n    hh : '%d hours',\\n    d  : 'a day',\\n    dd : '%d days',\\n    M  : 'a month',\\n    MM : '%d months',\\n    y  : 'a year',\\n    yy : '%d years'\\n};\\n\\nfunction relativeTime (number, withoutSuffix, string, isFuture) {\\n    var output = this._relativeTime[string];\\n    return (isFunction(output)) ?\\n        output(number, withoutSuffix, string, isFuture) :\\n        output.replace(/%d/i, number);\\n}\\n\\nfunction pastFuture (diff, output) {\\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\\n}\\n\\nvar aliases = {};\\n\\nfunction addUnitAlias (unit, shorthand) {\\n    var lowerCase = unit.toLowerCase();\\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\\n}\\n\\nfunction normalizeUnits(units) {\\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\\n}\\n\\nfunction normalizeObjectUnits(inputObject) {\\n    var normalizedInput = {},\\n        normalizedProp,\\n        prop;\\n\\n    for (prop in inputObject) {\\n        if (hasOwnProp(inputObject, prop)) {\\n            normalizedProp = normalizeUnits(prop);\\n            if (normalizedProp) {\\n                normalizedInput[normalizedProp] = inputObject[prop];\\n            }\\n        }\\n    }\\n\\n    return normalizedInput;\\n}\\n\\nvar priorities = {};\\n\\nfunction addUnitPriority(unit, priority) {\\n    priorities[unit] = priority;\\n}\\n\\nfunction getPrioritizedUnits(unitsObj) {\\n    var units = [];\\n    for (var u in unitsObj) {\\n        units.push({unit: u, priority: priorities[u]});\\n    }\\n    units.sort(function (a, b) {\\n        return a.priority - b.priority;\\n    });\\n    return units;\\n}\\n\\nfunction makeGetSet (unit, keepTime) {\\n    return function (value) {\\n        if (value != null) {\\n            set$1(this, unit, value);\\n            hooks.updateOffset(this, keepTime);\\n            return this;\\n        } else {\\n            return get(this, unit);\\n        }\\n    };\\n}\\n\\nfunction get (mom, unit) {\\n    return mom.isValid() ?\\n        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\\n}\\n\\nfunction set$1 (mom, unit, value) {\\n    if (mom.isValid()) {\\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\\n    }\\n}\\n\\n// MOMENTS\\n\\nfunction stringGet (units) {\\n    units = normalizeUnits(units);\\n    if (isFunction(this[units])) {\\n        return this[units]();\\n    }\\n    return this;\\n}\\n\\n\\nfunction stringSet (units, value) {\\n    if (typeof units === 'object') {\\n        units = normalizeObjectUnits(units);\\n        var prioritized = getPrioritizedUnits(units);\\n        for (var i = 0; i < prioritized.length; i++) {\\n            this[prioritized[i].unit](units[prioritized[i].unit]);\\n        }\\n    } else {\\n        units = normalizeUnits(units);\\n        if (isFunction(this[units])) {\\n            return this[units](value);\\n        }\\n    }\\n    return this;\\n}\\n\\nfunction zeroFill(number, targetLength, forceSign) {\\n    var absNumber = '' + Math.abs(number),\\n        zerosToFill = targetLength - absNumber.length,\\n        sign = number >= 0;\\n    return (sign ? (forceSign ? '+' : '') : '-') +\\n        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\\n}\\n\\nvar formattingTokens = /(\\\\[[^\\\\[]*\\\\])|(\\\\\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\\n\\nvar localFormattingTokens = /(\\\\[[^\\\\[]*\\\\])|(\\\\\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\\n\\nvar formatFunctions = {};\\n\\nvar formatTokenFunctions = {};\\n\\n// token:    'M'\\n// padded:   ['MM', 2]\\n// ordinal:  'Mo'\\n// callback: function () { this.month() + 1 }\\nfunction addFormatToken (token, padded, ordinal, callback) {\\n    var func = callback;\\n    if (typeof callback === 'string') {\\n        func = function () {\\n            return this[callback]();\\n        };\\n    }\\n    if (token) {\\n        formatTokenFunctions[token] = func;\\n    }\\n    if (padded) {\\n        formatTokenFunctions[padded[0]] = function () {\\n            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\\n        };\\n    }\\n    if (ordinal) {\\n        formatTokenFunctions[ordinal] = function () {\\n            return this.localeData().ordinal(func.apply(this, arguments), token);\\n        };\\n    }\\n}\\n\\nfunction removeFormattingTokens(input) {\\n    if (input.match(/\\\\[[\\\\s\\\\S]/)) {\\n        return input.replace(/^\\\\[|\\\\]$/g, '');\\n    }\\n    return input.replace(/\\\\\\\\/g, '');\\n}\\n\\nfunction makeFormatFunction(format) {\\n    var array = format.match(formattingTokens), i, length;\\n\\n    for (i = 0, length = array.length; i < length; i++) {\\n        if (formatTokenFunctions[array[i]]) {\\n            array[i] = formatTokenFunctions[array[i]];\\n        } else {\\n            array[i] = removeFormattingTokens(array[i]);\\n        }\\n    }\\n\\n    return function (mom) {\\n        var output = '', i;\\n        for (i = 0; i < length; i++) {\\n            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\\n        }\\n        return output;\\n    };\\n}\\n\\n// format date using native date object\\nfunction formatMoment(m, format) {\\n    if (!m.isValid()) {\\n        return m.localeData().invalidDate();\\n    }\\n\\n    format = expandFormat(format, m.localeData());\\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\\n\\n    return formatFunctions[format](m);\\n}\\n\\nfunction expandFormat(format, locale) {\\n    var i = 5;\\n\\n    function replaceLongDateFormatTokens(input) {\\n        return locale.longDateFormat(input) || input;\\n    }\\n\\n    localFormattingTokens.lastIndex = 0;\\n    while (i >= 0 && localFormattingTokens.test(format)) {\\n        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\\n        localFormattingTokens.lastIndex = 0;\\n        i -= 1;\\n    }\\n\\n    return format;\\n}\\n\\nvar match1         = /\\\\d/;            //       0 - 9\\nvar match2         = /\\\\d\\\\d/;          //      00 - 99\\nvar match3         = /\\\\d{3}/;         //     000 - 999\\nvar match4         = /\\\\d{4}/;         //    0000 - 9999\\nvar match6         = /[+-]?\\\\d{6}/;    // -999999 - 999999\\nvar match1to2      = /\\\\d\\\\d?/;         //       0 - 99\\nvar match3to4      = /\\\\d\\\\d\\\\d\\\\d?/;     //     999 - 9999\\nvar match5to6      = /\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d?/; //   99999 - 999999\\nvar match1to3      = /\\\\d{1,3}/;       //       0 - 999\\nvar match1to4      = /\\\\d{1,4}/;       //       0 - 9999\\nvar match1to6      = /[+-]?\\\\d{1,6}/;  // -999999 - 999999\\n\\nvar matchUnsigned  = /\\\\d+/;           //       0 - inf\\nvar matchSigned    = /[+-]?\\\\d+/;      //    -inf - inf\\n\\nvar matchOffset    = /Z|[+-]\\\\d\\\\d:?\\\\d\\\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\\nvar matchShortOffset = /Z|[+-]\\\\d\\\\d(?::?\\\\d\\\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\\n\\nvar matchTimestamp = /[+-]?\\\\d+(\\\\.\\\\d{1,3})?/; // 123456789 123456789.123\\n\\n// any word (or two) characters or numbers including two/three word month in arabic.\\n// includes scottish gaelic two word and hyphenated months\\nvar matchWord = /[0-9]*['a-z\\\\u00A0-\\\\u05FF\\\\u0700-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]+|[\\\\u0600-\\\\u06FF\\\\/]+(\\\\s*?[\\\\u0600-\\\\u06FF]+){1,2}/i;\\n\\n\\nvar regexes = {};\\n\\nfunction addRegexToken (token, regex, strictRegex) {\\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\\n        return (isStrict && strictRegex) ? strictRegex : regex;\\n    };\\n}\\n\\nfunction getParseRegexForToken (token, config) {\\n    if (!hasOwnProp(regexes, token)) {\\n        return new RegExp(unescapeFormat(token));\\n    }\\n\\n    return regexes[token](config._strict, config._locale);\\n}\\n\\n// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\\nfunction unescapeFormat(s) {\\n    return regexEscape(s.replace('\\\\\\\\', '').replace(/\\\\\\\\(\\\\[)|\\\\\\\\(\\\\])|\\\\[([^\\\\]\\\\[]*)\\\\]|\\\\\\\\(.)/g, function (matched, p1, p2, p3, p4) {\\n        return p1 || p2 || p3 || p4;\\n    }));\\n}\\n\\nfunction regexEscape(s) {\\n    return s.replace(/[-\\\\/\\\\\\\\^$*+?.()|[\\\\]{}]/g, '\\\\\\\\$&');\\n}\\n\\nvar tokens = {};\\n\\nfunction addParseToken (token, callback) {\\n    var i, func = callback;\\n    if (typeof token === 'string') {\\n        token = [token];\\n    }\\n    if (isNumber(callback)) {\\n        func = function (input, array) {\\n            array[callback] = toInt(input);\\n        };\\n    }\\n    for (i = 0; i < token.length; i++) {\\n        tokens[token[i]] = func;\\n    }\\n}\\n\\nfunction addWeekParseToken (token, callback) {\\n    addParseToken(token, function (input, array, config, token) {\\n        config._w = config._w || {};\\n        callback(input, config._w, config, token);\\n    });\\n}\\n\\nfunction addTimeToArrayFromToken(token, input, config) {\\n    if (input != null && hasOwnProp(tokens, token)) {\\n        tokens[token](input, config._a, config, token);\\n    }\\n}\\n\\nvar YEAR = 0;\\nvar MONTH = 1;\\nvar DATE = 2;\\nvar HOUR = 3;\\nvar MINUTE = 4;\\nvar SECOND = 5;\\nvar MILLISECOND = 6;\\nvar WEEK = 7;\\nvar WEEKDAY = 8;\\n\\nvar indexOf;\\n\\nif (Array.prototype.indexOf) {\\n    indexOf = Array.prototype.indexOf;\\n} else {\\n    indexOf = function (o) {\\n        // I know\\n        var i;\\n        for (i = 0; i < this.length; ++i) {\\n            if (this[i] === o) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    };\\n}\\n\\nvar indexOf$1 = indexOf;\\n\\nfunction daysInMonth(year, month) {\\n    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\\n}\\n\\n// FORMATTING\\n\\naddFormatToken('M', ['MM', 2], 'Mo', function () {\\n    return this.month() + 1;\\n});\\n\\naddFormatToken('MMM', 0, 0, function (format) {\\n    return this.localeData().monthsShort(this, format);\\n});\\n\\naddFormatToken('MMMM', 0, 0, function (format) {\\n    return this.localeData().months(this, format);\\n});\\n\\n// ALIASES\\n\\naddUnitAlias('month', 'M');\\n\\n// PRIORITY\\n\\naddUnitPriority('month', 8);\\n\\n// PARSING\\n\\naddRegexToken('M',    match1to2);\\naddRegexToken('MM',   match1to2, match2);\\naddRegexToken('MMM',  function (isStrict, locale) {\\n    return locale.monthsShortRegex(isStrict);\\n});\\naddRegexToken('MMMM', function (isStrict, locale) {\\n    return locale.monthsRegex(isStrict);\\n});\\n\\naddParseToken(['M', 'MM'], function (input, array) {\\n    array[MONTH] = toInt(input) - 1;\\n});\\n\\naddParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\\n    var month = config._locale.monthsParse(input, token, config._strict);\\n    // if we didn't find a month name, mark the date as invalid.\\n    if (month != null) {\\n        array[MONTH] = month;\\n    } else {\\n        getParsingFlags(config).invalidMonth = input;\\n    }\\n});\\n\\n// LOCALES\\n\\nvar MONTHS_IN_FORMAT = /D[oD]?(\\\\[[^\\\\[\\\\]]*\\\\]|\\\\s)+MMMM?/;\\nvar defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\\nfunction localeMonths (m, format) {\\n    if (!m) {\\n        return this._months;\\n    }\\n    return isArray(this._months) ? this._months[m.month()] :\\n        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\\n}\\n\\nvar defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\\nfunction localeMonthsShort (m, format) {\\n    if (!m) {\\n        return this._monthsShort;\\n    }\\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\\n        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\\n}\\n\\nfunction handleStrictParse(monthName, format, strict) {\\n    var i, ii, mom, llc = monthName.toLocaleLowerCase();\\n    if (!this._monthsParse) {\\n        // this is not used\\n        this._monthsParse = [];\\n        this._longMonthsParse = [];\\n        this._shortMonthsParse = [];\\n        for (i = 0; i < 12; ++i) {\\n            mom = createUTC([2000, i]);\\n            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\\n            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\\n        }\\n    }\\n\\n    if (strict) {\\n        if (format === 'MMM') {\\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\\n            return ii !== -1 ? ii : null;\\n        } else {\\n            ii = indexOf$1.call(this._longMonthsParse, llc);\\n            return ii !== -1 ? ii : null;\\n        }\\n    } else {\\n        if (format === 'MMM') {\\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._longMonthsParse, llc);\\n            return ii !== -1 ? ii : null;\\n        } else {\\n            ii = indexOf$1.call(this._longMonthsParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\\n            return ii !== -1 ? ii : null;\\n        }\\n    }\\n}\\n\\nfunction localeMonthsParse (monthName, format, strict) {\\n    var i, mom, regex;\\n\\n    if (this._monthsParseExact) {\\n        return handleStrictParse.call(this, monthName, format, strict);\\n    }\\n\\n    if (!this._monthsParse) {\\n        this._monthsParse = [];\\n        this._longMonthsParse = [];\\n        this._shortMonthsParse = [];\\n    }\\n\\n    // TODO: add sorting\\n    // Sorting makes sure if one month (or abbr) is a prefix of another\\n    // see sorting in computeMonthsParse\\n    for (i = 0; i < 12; i++) {\\n        // make the regex if we don't have it already\\n        mom = createUTC([2000, i]);\\n        if (strict && !this._longMonthsParse[i]) {\\n            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\\n            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\\n        }\\n        if (!strict && !this._monthsParse[i]) {\\n            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\\n            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\\n        }\\n        // test the regex\\n        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\\n            return i;\\n        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\\n            return i;\\n        } else if (!strict && this._monthsParse[i].test(monthName)) {\\n            return i;\\n        }\\n    }\\n}\\n\\n// MOMENTS\\n\\nfunction setMonth (mom, value) {\\n    var dayOfMonth;\\n\\n    if (!mom.isValid()) {\\n        // No op\\n        return mom;\\n    }\\n\\n    if (typeof value === 'string') {\\n        if (/^\\\\d+$/.test(value)) {\\n            value = toInt(value);\\n        } else {\\n            value = mom.localeData().monthsParse(value);\\n            // TODO: Another silent failure?\\n            if (!isNumber(value)) {\\n                return mom;\\n            }\\n        }\\n    }\\n\\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\\n    return mom;\\n}\\n\\nfunction getSetMonth (value) {\\n    if (value != null) {\\n        setMonth(this, value);\\n        hooks.updateOffset(this, true);\\n        return this;\\n    } else {\\n        return get(this, 'Month');\\n    }\\n}\\n\\nfunction getDaysInMonth () {\\n    return daysInMonth(this.year(), this.month());\\n}\\n\\nvar defaultMonthsShortRegex = matchWord;\\nfunction monthsShortRegex (isStrict) {\\n    if (this._monthsParseExact) {\\n        if (!hasOwnProp(this, '_monthsRegex')) {\\n            computeMonthsParse.call(this);\\n        }\\n        if (isStrict) {\\n            return this._monthsShortStrictRegex;\\n        } else {\\n            return this._monthsShortRegex;\\n        }\\n    } else {\\n        if (!hasOwnProp(this, '_monthsShortRegex')) {\\n            this._monthsShortRegex = defaultMonthsShortRegex;\\n        }\\n        return this._monthsShortStrictRegex && isStrict ?\\n            this._monthsShortStrictRegex : this._monthsShortRegex;\\n    }\\n}\\n\\nvar defaultMonthsRegex = matchWord;\\nfunction monthsRegex (isStrict) {\\n    if (this._monthsParseExact) {\\n        if (!hasOwnProp(this, '_monthsRegex')) {\\n            computeMonthsParse.call(this);\\n        }\\n        if (isStrict) {\\n            return this._monthsStrictRegex;\\n        } else {\\n            return this._monthsRegex;\\n        }\\n    } else {\\n        if (!hasOwnProp(this, '_monthsRegex')) {\\n            this._monthsRegex = defaultMonthsRegex;\\n        }\\n        return this._monthsStrictRegex && isStrict ?\\n            this._monthsStrictRegex : this._monthsRegex;\\n    }\\n}\\n\\nfunction computeMonthsParse () {\\n    function cmpLenRev(a, b) {\\n        return b.length - a.length;\\n    }\\n\\n    var shortPieces = [], longPieces = [], mixedPieces = [],\\n        i, mom;\\n    for (i = 0; i < 12; i++) {\\n        // make the regex if we don't have it already\\n        mom = createUTC([2000, i]);\\n        shortPieces.push(this.monthsShort(mom, ''));\\n        longPieces.push(this.months(mom, ''));\\n        mixedPieces.push(this.months(mom, ''));\\n        mixedPieces.push(this.monthsShort(mom, ''));\\n    }\\n    // Sorting makes sure if one month (or abbr) is a prefix of another it\\n    // will match the longer piece.\\n    shortPieces.sort(cmpLenRev);\\n    longPieces.sort(cmpLenRev);\\n    mixedPieces.sort(cmpLenRev);\\n    for (i = 0; i < 12; i++) {\\n        shortPieces[i] = regexEscape(shortPieces[i]);\\n        longPieces[i] = regexEscape(longPieces[i]);\\n    }\\n    for (i = 0; i < 24; i++) {\\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\\n    }\\n\\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\\n    this._monthsShortRegex = this._monthsRegex;\\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\\n}\\n\\n// FORMATTING\\n\\naddFormatToken('Y', 0, 0, function () {\\n    var y = this.year();\\n    return y <= 9999 ? '' + y : '+' + y;\\n});\\n\\naddFormatToken(0, ['YY', 2], 0, function () {\\n    return this.year() % 100;\\n});\\n\\naddFormatToken(0, ['YYYY',   4],       0, 'year');\\naddFormatToken(0, ['YYYYY',  5],       0, 'year');\\naddFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\\n\\n// ALIASES\\n\\naddUnitAlias('year', 'y');\\n\\n// PRIORITIES\\n\\naddUnitPriority('year', 1);\\n\\n// PARSING\\n\\naddRegexToken('Y',      matchSigned);\\naddRegexToken('YY',     match1to2, match2);\\naddRegexToken('YYYY',   match1to4, match4);\\naddRegexToken('YYYYY',  match1to6, match6);\\naddRegexToken('YYYYYY', match1to6, match6);\\n\\naddParseToken(['YYYYY', 'YYYYYY'], YEAR);\\naddParseToken('YYYY', function (input, array) {\\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\\n});\\naddParseToken('YY', function (input, array) {\\n    array[YEAR] = hooks.parseTwoDigitYear(input);\\n});\\naddParseToken('Y', function (input, array) {\\n    array[YEAR] = parseInt(input, 10);\\n});\\n\\n// HELPERS\\n\\nfunction daysInYear(year) {\\n    return isLeapYear(year) ? 366 : 365;\\n}\\n\\nfunction isLeapYear(year) {\\n    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\\n}\\n\\n// HOOKS\\n\\nhooks.parseTwoDigitYear = function (input) {\\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\\n};\\n\\n// MOMENTS\\n\\nvar getSetYear = makeGetSet('FullYear', true);\\n\\nfunction getIsLeapYear () {\\n    return isLeapYear(this.year());\\n}\\n\\nfunction createDate (y, m, d, h, M, s, ms) {\\n    //can't just apply() to create a date:\\n    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\\n    var date = new Date(y, m, d, h, M, s, ms);\\n\\n    //the date constructor remaps years 0-99 to 1900-1999\\n    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\\n        date.setFullYear(y);\\n    }\\n    return date;\\n}\\n\\nfunction createUTCDate (y) {\\n    var date = new Date(Date.UTC.apply(null, arguments));\\n\\n    //the Date.UTC function remaps years 0-99 to 1900-1999\\n    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\\n        date.setUTCFullYear(y);\\n    }\\n    return date;\\n}\\n\\n// start-of-first-week - start-of-year\\nfunction firstWeekOffset(year, dow, doy) {\\n    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\\n        fwd = 7 + dow - doy,\\n        // first-week day local weekday -- which local weekday is fwd\\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\\n\\n    return -fwdlw + fwd - 1;\\n}\\n\\n//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\\nfunction dayOfYearFromWeeks(year, week, weekday, dow, doy) {\\n    var localWeekday = (7 + weekday - dow) % 7,\\n        weekOffset = firstWeekOffset(year, dow, doy),\\n        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\\n        resYear, resDayOfYear;\\n\\n    if (dayOfYear <= 0) {\\n        resYear = year - 1;\\n        resDayOfYear = daysInYear(resYear) + dayOfYear;\\n    } else if (dayOfYear > daysInYear(year)) {\\n        resYear = year + 1;\\n        resDayOfYear = dayOfYear - daysInYear(year);\\n    } else {\\n        resYear = year;\\n        resDayOfYear = dayOfYear;\\n    }\\n\\n    return {\\n        year: resYear,\\n        dayOfYear: resDayOfYear\\n    };\\n}\\n\\nfunction weekOfYear(mom, dow, doy) {\\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\\n        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\\n        resWeek, resYear;\\n\\n    if (week < 1) {\\n        resYear = mom.year() - 1;\\n        resWeek = week + weeksInYear(resYear, dow, doy);\\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\\n        resWeek = week - weeksInYear(mom.year(), dow, doy);\\n        resYear = mom.year() + 1;\\n    } else {\\n        resYear = mom.year();\\n        resWeek = week;\\n    }\\n\\n    return {\\n        week: resWeek,\\n        year: resYear\\n    };\\n}\\n\\nfunction weeksInYear(year, dow, doy) {\\n    var weekOffset = firstWeekOffset(year, dow, doy),\\n        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\\n}\\n\\n// FORMATTING\\n\\naddFormatToken('w', ['ww', 2], 'wo', 'week');\\naddFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\\n\\n// ALIASES\\n\\naddUnitAlias('week', 'w');\\naddUnitAlias('isoWeek', 'W');\\n\\n// PRIORITIES\\n\\naddUnitPriority('week', 5);\\naddUnitPriority('isoWeek', 5);\\n\\n// PARSING\\n\\naddRegexToken('w',  match1to2);\\naddRegexToken('ww', match1to2, match2);\\naddRegexToken('W',  match1to2);\\naddRegexToken('WW', match1to2, match2);\\n\\naddWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\\n    week[token.substr(0, 1)] = toInt(input);\\n});\\n\\n// HELPERS\\n\\n// LOCALES\\n\\nfunction localeWeek (mom) {\\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\\n}\\n\\nvar defaultLocaleWeek = {\\n    dow : 0, // Sunday is the first day of the week.\\n    doy : 6  // The week that contains Jan 1st is the first week of the year.\\n};\\n\\nfunction localeFirstDayOfWeek () {\\n    return this._week.dow;\\n}\\n\\nfunction localeFirstDayOfYear () {\\n    return this._week.doy;\\n}\\n\\n// MOMENTS\\n\\nfunction getSetWeek (input) {\\n    var week = this.localeData().week(this);\\n    return input == null ? week : this.add((input - week) * 7, 'd');\\n}\\n\\nfunction getSetISOWeek (input) {\\n    var week = weekOfYear(this, 1, 4).week;\\n    return input == null ? week : this.add((input - week) * 7, 'd');\\n}\\n\\n// FORMATTING\\n\\naddFormatToken('d', 0, 'do', 'day');\\n\\naddFormatToken('dd', 0, 0, function (format) {\\n    return this.localeData().weekdaysMin(this, format);\\n});\\n\\naddFormatToken('ddd', 0, 0, function (format) {\\n    return this.localeData().weekdaysShort(this, format);\\n});\\n\\naddFormatToken('dddd', 0, 0, function (format) {\\n    return this.localeData().weekdays(this, format);\\n});\\n\\naddFormatToken('e', 0, 0, 'weekday');\\naddFormatToken('E', 0, 0, 'isoWeekday');\\n\\n// ALIASES\\n\\naddUnitAlias('day', 'd');\\naddUnitAlias('weekday', 'e');\\naddUnitAlias('isoWeekday', 'E');\\n\\n// PRIORITY\\naddUnitPriority('day', 11);\\naddUnitPriority('weekday', 11);\\naddUnitPriority('isoWeekday', 11);\\n\\n// PARSING\\n\\naddRegexToken('d',    match1to2);\\naddRegexToken('e',    match1to2);\\naddRegexToken('E',    match1to2);\\naddRegexToken('dd',   function (isStrict, locale) {\\n    return locale.weekdaysMinRegex(isStrict);\\n});\\naddRegexToken('ddd',   function (isStrict, locale) {\\n    return locale.weekdaysShortRegex(isStrict);\\n});\\naddRegexToken('dddd',   function (isStrict, locale) {\\n    return locale.weekdaysRegex(isStrict);\\n});\\n\\naddWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\\n    var weekday = config._locale.weekdaysParse(input, token, config._strict);\\n    // if we didn't get a weekday name, mark the date as invalid\\n    if (weekday != null) {\\n        week.d = weekday;\\n    } else {\\n        getParsingFlags(config).invalidWeekday = input;\\n    }\\n});\\n\\naddWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\\n    week[token] = toInt(input);\\n});\\n\\n// HELPERS\\n\\nfunction parseWeekday(input, locale) {\\n    if (typeof input !== 'string') {\\n        return input;\\n    }\\n\\n    if (!isNaN(input)) {\\n        return parseInt(input, 10);\\n    }\\n\\n    input = locale.weekdaysParse(input);\\n    if (typeof input === 'number') {\\n        return input;\\n    }\\n\\n    return null;\\n}\\n\\nfunction parseIsoWeekday(input, locale) {\\n    if (typeof input === 'string') {\\n        return locale.weekdaysParse(input) % 7 || 7;\\n    }\\n    return isNaN(input) ? null : input;\\n}\\n\\n// LOCALES\\n\\nvar defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\\nfunction localeWeekdays (m, format) {\\n    if (!m) {\\n        return this._weekdays;\\n    }\\n    return isArray(this._weekdays) ? this._weekdays[m.day()] :\\n        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\\n}\\n\\nvar defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\\nfunction localeWeekdaysShort (m) {\\n    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\\n}\\n\\nvar defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\\nfunction localeWeekdaysMin (m) {\\n    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\\n}\\n\\nfunction handleStrictParse$1(weekdayName, format, strict) {\\n    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\\n    if (!this._weekdaysParse) {\\n        this._weekdaysParse = [];\\n        this._shortWeekdaysParse = [];\\n        this._minWeekdaysParse = [];\\n\\n        for (i = 0; i < 7; ++i) {\\n            mom = createUTC([2000, 1]).day(i);\\n            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\\n            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\\n            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\\n        }\\n    }\\n\\n    if (strict) {\\n        if (format === 'dddd') {\\n            ii = indexOf$1.call(this._weekdaysParse, llc);\\n            return ii !== -1 ? ii : null;\\n        } else if (format === 'ddd') {\\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\\n            return ii !== -1 ? ii : null;\\n        } else {\\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\\n            return ii !== -1 ? ii : null;\\n        }\\n    } else {\\n        if (format === 'dddd') {\\n            ii = indexOf$1.call(this._weekdaysParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\\n            return ii !== -1 ? ii : null;\\n        } else if (format === 'ddd') {\\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._weekdaysParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\\n            return ii !== -1 ? ii : null;\\n        } else {\\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._weekdaysParse, llc);\\n            if (ii !== -1) {\\n                return ii;\\n            }\\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\\n            return ii !== -1 ? ii : null;\\n        }\\n    }\\n}\\n\\nfunction localeWeekdaysParse (weekdayName, format, strict) {\\n    var i, mom, regex;\\n\\n    if (this._weekdaysParseExact) {\\n        return handleStrictParse$1.call(this, weekdayName, format, strict);\\n    }\\n\\n    if (!this._weekdaysParse) {\\n        this._weekdaysParse = [];\\n        this._minWeekdaysParse = [];\\n        this._shortWeekdaysParse = [];\\n        this._fullWeekdaysParse = [];\\n    }\\n\\n    for (i = 0; i < 7; i++) {\\n        // make the regex if we don't have it already\\n\\n        mom = createUTC([2000, 1]).day(i);\\n        if (strict && !this._fullWeekdaysParse[i]) {\\n            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\\n            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\\n            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\\n        }\\n        if (!this._weekdaysParse[i]) {\\n            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\\n            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\\n        }\\n        // test the regex\\n        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\\n            return i;\\n        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\\n            return i;\\n        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\\n            return i;\\n        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\\n            return i;\\n        }\\n    }\\n}\\n\\n// MOMENTS\\n\\nfunction getSetDayOfWeek (input) {\\n    if (!this.isValid()) {\\n        return input != null ? this : NaN;\\n    }\\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\\n    if (input != null) {\\n        input = parseWeekday(input, this.localeData());\\n        return this.add(input - day, 'd');\\n    } else {\\n        return day;\\n    }\\n}\\n\\nfunction getSetLocaleDayOfWeek (input) {\\n    if (!this.isValid()) {\\n        return input != null ? this : NaN;\\n    }\\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\\n    return input == null ? weekday : this.add(input - weekday, 'd');\\n}\\n\\nfunction getSetISODayOfWeek (input) {\\n    if (!this.isValid()) {\\n        return input != null ? this : NaN;\\n    }\\n\\n    // behaves the same as moment#day except\\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\\n    // as a setter, sunday should belong to the previous week.\\n\\n    if (input != null) {\\n        var weekday = parseIsoWeekday(input, this.localeData());\\n        return this.day(this.day() % 7 ? weekday : weekday - 7);\\n    } else {\\n        return this.day() || 7;\\n    }\\n}\\n\\nvar defaultWeekdaysRegex = matchWord;\\nfunction weekdaysRegex (isStrict) {\\n    if (this._weekdaysParseExact) {\\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\\n            computeWeekdaysParse.call(this);\\n        }\\n        if (isStrict) {\\n            return this._weekdaysStrictRegex;\\n        } else {\\n            return this._weekdaysRegex;\\n        }\\n    } else {\\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\\n            this._weekdaysRegex = defaultWeekdaysRegex;\\n        }\\n        return this._weekdaysStrictRegex && isStrict ?\\n            this._weekdaysStrictRegex : this._weekdaysRegex;\\n    }\\n}\\n\\nvar defaultWeekdaysShortRegex = matchWord;\\nfunction weekdaysShortRegex (isStrict) {\\n    if (this._weekdaysParseExact) {\\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\\n            computeWeekdaysParse.call(this);\\n        }\\n        if (isStrict) {\\n            return this._weekdaysShortStrictRegex;\\n        } else {\\n            return this._weekdaysShortRegex;\\n        }\\n    } else {\\n        if (!hasOwnProp(this, '_weekdaysShortRegex')) {\\n            this._weekdaysShortRegex = defaultWeekdaysShortRegex;\\n        }\\n        return this._weekdaysShortStrictRegex && isStrict ?\\n            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\\n    }\\n}\\n\\nvar defaultWeekdaysMinRegex = matchWord;\\nfunction weekdaysMinRegex (isStrict) {\\n    if (this._weekdaysParseExact) {\\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\\n            computeWeekdaysParse.call(this);\\n        }\\n        if (isStrict) {\\n            return this._weekdaysMinStrictRegex;\\n        } else {\\n            return this._weekdaysMinRegex;\\n        }\\n    } else {\\n        if (!hasOwnProp(this, '_weekdaysMinRegex')) {\\n            this._weekdaysMinRegex = defaultWeekdaysMinRegex;\\n        }\\n        return this._weekdaysMinStrictRegex && isStrict ?\\n            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\\n    }\\n}\\n\\n\\nfunction computeWeekdaysParse () {\\n    function cmpLenRev(a, b) {\\n        return b.length - a.length;\\n    }\\n\\n    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\\n        i, mom, minp, shortp, longp;\\n    for (i = 0; i < 7; i++) {\\n        // make the regex if we don't have it already\\n        mom = createUTC([2000, 1]).day(i);\\n        minp = this.weekdaysMin(mom, '');\\n        shortp = this.weekdaysShort(mom, '');\\n        longp = this.weekdays(mom, '');\\n        minPieces.push(minp);\\n        shortPieces.push(shortp);\\n        longPieces.push(longp);\\n        mixedPieces.push(minp);\\n        mixedPieces.push(shortp);\\n        mixedPieces.push(longp);\\n    }\\n    // Sorting makes sure if one weekday (or abbr) is a prefix of another it\\n    // will match the longer piece.\\n    minPieces.sort(cmpLenRev);\\n    shortPieces.sort(cmpLenRev);\\n    longPieces.sort(cmpLenRev);\\n    mixedPieces.sort(cmpLenRev);\\n    for (i = 0; i < 7; i++) {\\n        shortPieces[i] = regexEscape(shortPieces[i]);\\n        longPieces[i] = regexEscape(longPieces[i]);\\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\\n    }\\n\\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\\n    this._weekdaysShortRegex = this._weekdaysRegex;\\n    this._weekdaysMinRegex = this._weekdaysRegex;\\n\\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\\n}\\n\\n// FORMATTING\\n\\nfunction hFormat() {\\n    return this.hours() % 12 || 12;\\n}\\n\\nfunction kFormat() {\\n    return this.hours() || 24;\\n}\\n\\naddFormatToken('H', ['HH', 2], 0, 'hour');\\naddFormatToken('h', ['hh', 2], 0, hFormat);\\naddFormatToken('k', ['kk', 2], 0, kFormat);\\n\\naddFormatToken('hmm', 0, 0, function () {\\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\\n});\\n\\naddFormatToken('hmmss', 0, 0, function () {\\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\\n        zeroFill(this.seconds(), 2);\\n});\\n\\naddFormatToken('Hmm', 0, 0, function () {\\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\\n});\\n\\naddFormatToken('Hmmss', 0, 0, function () {\\n    return '' + this.hours() + zeroFill(this.minutes(), 2) +\\n        zeroFill(this.seconds(), 2);\\n});\\n\\nfunction meridiem (token, lowercase) {\\n    addFormatToken(token, 0, 0, function () {\\n        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\\n    });\\n}\\n\\nmeridiem('a', true);\\nmeridiem('A', false);\\n\\n// ALIASES\\n\\naddUnitAlias('hour', 'h');\\n\\n// PRIORITY\\naddUnitPriority('hour', 13);\\n\\n// PARSING\\n\\nfunction matchMeridiem (isStrict, locale) {\\n    return locale._meridiemParse;\\n}\\n\\naddRegexToken('a',  matchMeridiem);\\naddRegexToken('A',  matchMeridiem);\\naddRegexToken('H',  match1to2);\\naddRegexToken('h',  match1to2);\\naddRegexToken('HH', match1to2, match2);\\naddRegexToken('hh', match1to2, match2);\\n\\naddRegexToken('hmm', match3to4);\\naddRegexToken('hmmss', match5to6);\\naddRegexToken('Hmm', match3to4);\\naddRegexToken('Hmmss', match5to6);\\n\\naddParseToken(['H', 'HH'], HOUR);\\naddParseToken(['a', 'A'], function (input, array, config) {\\n    config._isPm = config._locale.isPM(input);\\n    config._meridiem = input;\\n});\\naddParseToken(['h', 'hh'], function (input, array, config) {\\n    array[HOUR] = toInt(input);\\n    getParsingFlags(config).bigHour = true;\\n});\\naddParseToken('hmm', function (input, array, config) {\\n    var pos = input.length - 2;\\n    array[HOUR] = toInt(input.substr(0, pos));\\n    array[MINUTE] = toInt(input.substr(pos));\\n    getParsingFlags(config).bigHour = true;\\n});\\naddParseToken('hmmss', function (input, array, config) {\\n    var pos1 = input.length - 4;\\n    var pos2 = input.length - 2;\\n    array[HOUR] = toInt(input.substr(0, pos1));\\n    array[MINUTE] = toInt(input.substr(pos1, 2));\\n    array[SECOND] = toInt(input.substr(pos2));\\n    getParsingFlags(config).bigHour = true;\\n});\\naddParseToken('Hmm', function (input, array, config) {\\n    var pos = input.length - 2;\\n    array[HOUR] = toInt(input.substr(0, pos));\\n    array[MINUTE] = toInt(input.substr(pos));\\n});\\naddParseToken('Hmmss', function (input, array, config) {\\n    var pos1 = input.length - 4;\\n    var pos2 = input.length - 2;\\n    array[HOUR] = toInt(input.substr(0, pos1));\\n    array[MINUTE] = toInt(input.substr(pos1, 2));\\n    array[SECOND] = toInt(input.substr(pos2));\\n});\\n\\n// LOCALES\\n\\nfunction localeIsPM (input) {\\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\\n    // Using charAt should be more compatible.\\n    return ((input + '').toLowerCase().charAt(0) === 'p');\\n}\\n\\nvar defaultLocaleMeridiemParse = /[ap]\\\\.?m?\\\\.?/i;\\nfunction localeMeridiem (hours, minutes, isLower) {\\n    if (hours > 11) {\\n        return isLower ? 'pm' : 'PM';\\n    } else {\\n        return isLower ? 'am' : 'AM';\\n    }\\n}\\n\\n\\n// MOMENTS\\n\\n// Setting the hour should keep the time, because the user explicitly\\n// specified which hour he wants. So trying to maintain the same hour (in\\n// a new timezone) makes sense. Adding/subtracting hours does not follow\\n// this rule.\\nvar getSetHour = makeGetSet('Hours', true);\\n\\n// months\\n// week\\n// weekdays\\n// meridiem\\nvar baseConfig = {\\n    calendar: defaultCalendar,\\n    longDateFormat: defaultLongDateFormat,\\n    invalidDate: defaultInvalidDate,\\n    ordinal: defaultOrdinal,\\n    ordinalParse: defaultOrdinalParse,\\n    relativeTime: defaultRelativeTime,\\n\\n    months: defaultLocaleMonths,\\n    monthsShort: defaultLocaleMonthsShort,\\n\\n    week: defaultLocaleWeek,\\n\\n    weekdays: defaultLocaleWeekdays,\\n    weekdaysMin: defaultLocaleWeekdaysMin,\\n    weekdaysShort: defaultLocaleWeekdaysShort,\\n\\n    meridiemParse: defaultLocaleMeridiemParse\\n};\\n\\n// internal storage for locale config files\\nvar locales = {};\\nvar localeFamilies = {};\\nvar globalLocale;\\n\\nfunction normalizeLocale(key) {\\n    return key ? key.toLowerCase().replace('_', '-') : key;\\n}\\n\\n// pick the locale from the array\\n// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\\n// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\\nfunction chooseLocale(names) {\\n    var i = 0, j, next, locale, split;\\n\\n    while (i < names.length) {\\n        split = normalizeLocale(names[i]).split('-');\\n        j = split.length;\\n        next = normalizeLocale(names[i + 1]);\\n        next = next ? next.split('-') : null;\\n        while (j > 0) {\\n            locale = loadLocale(split.slice(0, j).join('-'));\\n            if (locale) {\\n                return locale;\\n            }\\n            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\\n                //the next array item is better than a shallower substring of this one\\n                break;\\n            }\\n            j--;\\n        }\\n        i++;\\n    }\\n    return null;\\n}\\n\\nfunction loadLocale(name) {\\n    var oldLocale = null;\\n    // TODO: Find a better way to register and load all the locales in Node\\n    if (!locales[name] && (typeof module !== 'undefined') &&\\n            module && module.exports) {\\n        try {\\n            oldLocale = globalLocale._abbr;\\n            require('./locale/' + name);\\n            // because defineLocale currently also sets the global locale, we\\n            // want to undo that for lazy loaded locales\\n            getSetGlobalLocale(oldLocale);\\n        } catch (e) { }\\n    }\\n    return locales[name];\\n}\\n\\n// This function will load locale and then set the global locale.  If\\n// no arguments are passed in, it will simply return the current global\\n// locale key.\\nfunction getSetGlobalLocale (key, values) {\\n    var data;\\n    if (key) {\\n        if (isUndefined(values)) {\\n            data = getLocale(key);\\n        }\\n        else {\\n            data = defineLocale(key, values);\\n        }\\n\\n        if (data) {\\n            // moment.duration._locale = moment._locale = data;\\n            globalLocale = data;\\n        }\\n    }\\n\\n    return globalLocale._abbr;\\n}\\n\\nfunction defineLocale (name, config) {\\n    if (config !== null) {\\n        var parentConfig = baseConfig;\\n        config.abbr = name;\\n        if (locales[name] != null) {\\n            deprecateSimple('defineLocaleOverride',\\n                    'use moment.updateLocale(localeName, config) to change ' +\\n                    'an existing locale. moment.defineLocale(localeName, ' +\\n                    'config) should only be used for creating a new locale ' +\\n                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\\n            parentConfig = locales[name]._config;\\n        } else if (config.parentLocale != null) {\\n            if (locales[config.parentLocale] != null) {\\n                parentConfig = locales[config.parentLocale]._config;\\n            } else {\\n                if (!localeFamilies[config.parentLocale]) {\\n                    localeFamilies[config.parentLocale] = [];\\n                }\\n                localeFamilies[config.parentLocale].push({\\n                    name: name,\\n                    config: config\\n                });\\n                return null;\\n            }\\n        }\\n        locales[name] = new Locale(mergeConfigs(parentConfig, config));\\n\\n        if (localeFamilies[name]) {\\n            localeFamilies[name].forEach(function (x) {\\n                defineLocale(x.name, x.config);\\n            });\\n        }\\n\\n        // backwards compat for now: also set the locale\\n        // make sure we set the locale AFTER all child locales have been\\n        // created, so we won't end up with the child locale set.\\n        getSetGlobalLocale(name);\\n\\n\\n        return locales[name];\\n    } else {\\n        // useful for testing\\n        delete locales[name];\\n        return null;\\n    }\\n}\\n\\nfunction updateLocale(name, config) {\\n    if (config != null) {\\n        var locale, parentConfig = baseConfig;\\n        // MERGE\\n        if (locales[name] != null) {\\n            parentConfig = locales[name]._config;\\n        }\\n        config = mergeConfigs(parentConfig, config);\\n        locale = new Locale(config);\\n        locale.parentLocale = locales[name];\\n        locales[name] = locale;\\n\\n        // backwards compat for now: also set the locale\\n        getSetGlobalLocale(name);\\n    } else {\\n        // pass null for config to unupdate, useful for tests\\n        if (locales[name] != null) {\\n            if (locales[name].parentLocale != null) {\\n                locales[name] = locales[name].parentLocale;\\n            } else if (locales[name] != null) {\\n                delete locales[name];\\n            }\\n        }\\n    }\\n    return locales[name];\\n}\\n\\n// returns locale data\\nfunction getLocale (key) {\\n    var locale;\\n\\n    if (key && key._locale && key._locale._abbr) {\\n        key = key._locale._abbr;\\n    }\\n\\n    if (!key) {\\n        return globalLocale;\\n    }\\n\\n    if (!isArray(key)) {\\n        //short-circuit everything else\\n        locale = loadLocale(key);\\n        if (locale) {\\n            return locale;\\n        }\\n        key = [key];\\n    }\\n\\n    return chooseLocale(key);\\n}\\n\\nfunction listLocales() {\\n    return keys$1(locales);\\n}\\n\\nfunction checkOverflow (m) {\\n    var overflow;\\n    var a = m._a;\\n\\n    if (a && getParsingFlags(m).overflow === -2) {\\n        overflow =\\n            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\\n            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\\n            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\\n            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\\n            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\\n            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\\n            -1;\\n\\n        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\\n            overflow = DATE;\\n        }\\n        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\\n            overflow = WEEK;\\n        }\\n        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\\n            overflow = WEEKDAY;\\n        }\\n\\n        getParsingFlags(m).overflow = overflow;\\n    }\\n\\n    return m;\\n}\\n\\n// iso 8601 regex\\n// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\\nvar extendedIsoRegex = /^\\\\s*((?:[+-]\\\\d{6}|\\\\d{4})-(?:\\\\d\\\\d-\\\\d\\\\d|W\\\\d\\\\d-\\\\d|W\\\\d\\\\d|\\\\d\\\\d\\\\d|\\\\d\\\\d))(?:(T| )(\\\\d\\\\d(?::\\\\d\\\\d(?::\\\\d\\\\d(?:[.,]\\\\d+)?)?)?)([\\\\+\\\\-]\\\\d\\\\d(?::?\\\\d\\\\d)?|\\\\s*Z)?)?$/;\\nvar basicIsoRegex = /^\\\\s*((?:[+-]\\\\d{6}|\\\\d{4})(?:\\\\d\\\\d\\\\d\\\\d|W\\\\d\\\\d\\\\d|W\\\\d\\\\d|\\\\d\\\\d\\\\d|\\\\d\\\\d))(?:(T| )(\\\\d\\\\d(?:\\\\d\\\\d(?:\\\\d\\\\d(?:[.,]\\\\d+)?)?)?)([\\\\+\\\\-]\\\\d\\\\d(?::?\\\\d\\\\d)?|\\\\s*Z)?)?$/;\\n\\nvar tzRegex = /Z|[+-]\\\\d\\\\d(?::?\\\\d\\\\d)?/;\\n\\nvar isoDates = [\\n    ['YYYYYY-MM-DD', /[+-]\\\\d{6}-\\\\d\\\\d-\\\\d\\\\d/],\\n    ['YYYY-MM-DD', /\\\\d{4}-\\\\d\\\\d-\\\\d\\\\d/],\\n    ['GGGG-[W]WW-E', /\\\\d{4}-W\\\\d\\\\d-\\\\d/],\\n    ['GGGG-[W]WW', /\\\\d{4}-W\\\\d\\\\d/, false],\\n    ['YYYY-DDD', /\\\\d{4}-\\\\d{3}/],\\n    ['YYYY-MM', /\\\\d{4}-\\\\d\\\\d/, false],\\n    ['YYYYYYMMDD', /[+-]\\\\d{10}/],\\n    ['YYYYMMDD', /\\\\d{8}/],\\n    // YYYYMM is NOT allowed by the standard\\n    ['GGGG[W]WWE', /\\\\d{4}W\\\\d{3}/],\\n    ['GGGG[W]WW', /\\\\d{4}W\\\\d{2}/, false],\\n    ['YYYYDDD', /\\\\d{7}/]\\n];\\n\\n// iso time formats and regexes\\nvar isoTimes = [\\n    ['HH:mm:ss.SSSS', /\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d\\\\.\\\\d+/],\\n    ['HH:mm:ss,SSSS', /\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d,\\\\d+/],\\n    ['HH:mm:ss', /\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d/],\\n    ['HH:mm', /\\\\d\\\\d:\\\\d\\\\d/],\\n    ['HHmmss.SSSS', /\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\.\\\\d+/],\\n    ['HHmmss,SSSS', /\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d,\\\\d+/],\\n    ['HHmmss', /\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d/],\\n    ['HHmm', /\\\\d\\\\d\\\\d\\\\d/],\\n    ['HH', /\\\\d\\\\d/]\\n];\\n\\nvar aspNetJsonRegex = /^\\\\/?Date\\\\((\\\\-?\\\\d+)/i;\\n\\n// date from iso format\\nfunction configFromISO(config) {\\n    var i, l,\\n        string = config._i,\\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\\n        allowTime, dateFormat, timeFormat, tzFormat;\\n\\n    if (match) {\\n        getParsingFlags(config).iso = true;\\n\\n        for (i = 0, l = isoDates.length; i < l; i++) {\\n            if (isoDates[i][1].exec(match[1])) {\\n                dateFormat = isoDates[i][0];\\n                allowTime = isoDates[i][2] !== false;\\n                break;\\n            }\\n        }\\n        if (dateFormat == null) {\\n            config._isValid = false;\\n            return;\\n        }\\n        if (match[3]) {\\n            for (i = 0, l = isoTimes.length; i < l; i++) {\\n                if (isoTimes[i][1].exec(match[3])) {\\n                    // match[2] should be 'T' or space\\n                    timeFormat = (match[2] || ' ') + isoTimes[i][0];\\n                    break;\\n                }\\n            }\\n            if (timeFormat == null) {\\n                config._isValid = false;\\n                return;\\n            }\\n        }\\n        if (!allowTime && timeFormat != null) {\\n            config._isValid = false;\\n            return;\\n        }\\n        if (match[4]) {\\n            if (tzRegex.exec(match[4])) {\\n                tzFormat = 'Z';\\n            } else {\\n                config._isValid = false;\\n                return;\\n            }\\n        }\\n        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\\n        configFromStringAndFormat(config);\\n    } else {\\n        config._isValid = false;\\n    }\\n}\\n\\n// date from iso format or fallback\\nfunction configFromString(config) {\\n    var matched = aspNetJsonRegex.exec(config._i);\\n\\n    if (matched !== null) {\\n        config._d = new Date(+matched[1]);\\n        return;\\n    }\\n\\n    configFromISO(config);\\n    if (config._isValid === false) {\\n        delete config._isValid;\\n        hooks.createFromInputFallback(config);\\n    }\\n}\\n\\nhooks.createFromInputFallback = deprecate(\\n    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +\\n    'which is not reliable across all browsers and versions. Non ISO date formats are ' +\\n    'discouraged and will be removed in an upcoming major release. Please refer to ' +\\n    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\\n    function (config) {\\n        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\\n    }\\n);\\n\\n// Pick the first defined of two or three arguments.\\nfunction defaults(a, b, c) {\\n    if (a != null) {\\n        return a;\\n    }\\n    if (b != null) {\\n        return b;\\n    }\\n    return c;\\n}\\n\\nfunction currentDateArray(config) {\\n    // hooks is actually the exported moment object\\n    var nowValue = new Date(hooks.now());\\n    if (config._useUTC) {\\n        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\\n    }\\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\\n}\\n\\n// convert an array to a date.\\n// the array should mirror the parameters below\\n// note: all values past the year are optional and will default to the lowest possible value.\\n// [year, month, day , hour, minute, second, millisecond]\\nfunction configFromArray (config) {\\n    var i, date, input = [], currentDate, yearToUse;\\n\\n    if (config._d) {\\n        return;\\n    }\\n\\n    currentDate = currentDateArray(config);\\n\\n    //compute day of the year from weeks and weekdays\\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\\n        dayOfYearFromWeekInfo(config);\\n    }\\n\\n    //if the day of the year is set, figure out what it is\\n    if (config._dayOfYear) {\\n        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\\n\\n        if (config._dayOfYear > daysInYear(yearToUse)) {\\n            getParsingFlags(config)._overflowDayOfYear = true;\\n        }\\n\\n        date = createUTCDate(yearToUse, 0, config._dayOfYear);\\n        config._a[MONTH] = date.getUTCMonth();\\n        config._a[DATE] = date.getUTCDate();\\n    }\\n\\n    // Default to current date.\\n    // * if no year, month, day of month are given, default to today\\n    // * if day of month is given, default month and year\\n    // * if month is given, default only year\\n    // * if year is given, don't default anything\\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\\n        config._a[i] = input[i] = currentDate[i];\\n    }\\n\\n    // Zero out whatever was not defaulted, including time\\n    for (; i < 7; i++) {\\n        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\\n    }\\n\\n    // Check for 24:00:00.000\\n    if (config._a[HOUR] === 24 &&\\n            config._a[MINUTE] === 0 &&\\n            config._a[SECOND] === 0 &&\\n            config._a[MILLISECOND] === 0) {\\n        config._nextDay = true;\\n        config._a[HOUR] = 0;\\n    }\\n\\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\\n    // Apply timezone offset from input. The actual utcOffset can be changed\\n    // with parseZone.\\n    if (config._tzm != null) {\\n        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\\n    }\\n\\n    if (config._nextDay) {\\n        config._a[HOUR] = 24;\\n    }\\n}\\n\\nfunction dayOfYearFromWeekInfo(config) {\\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\\n\\n    w = config._w;\\n    if (w.GG != null || w.W != null || w.E != null) {\\n        dow = 1;\\n        doy = 4;\\n\\n        // TODO: We need to take the current isoWeekYear, but that depends on\\n        // how we interpret now (local, utc, fixed offset). So create\\n        // a now version of current config (take local/utc/offset flags, and\\n        // create now).\\n        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\\n        week = defaults(w.W, 1);\\n        weekday = defaults(w.E, 1);\\n        if (weekday < 1 || weekday > 7) {\\n            weekdayOverflow = true;\\n        }\\n    } else {\\n        dow = config._locale._week.dow;\\n        doy = config._locale._week.doy;\\n\\n        var curWeek = weekOfYear(createLocal(), dow, doy);\\n\\n        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\\n\\n        // Default to current week.\\n        week = defaults(w.w, curWeek.week);\\n\\n        if (w.d != null) {\\n            // weekday -- low day numbers are considered next week\\n            weekday = w.d;\\n            if (weekday < 0 || weekday > 6) {\\n                weekdayOverflow = true;\\n            }\\n        } else if (w.e != null) {\\n            // local weekday -- counting starts from begining of week\\n            weekday = w.e + dow;\\n            if (w.e < 0 || w.e > 6) {\\n                weekdayOverflow = true;\\n            }\\n        } else {\\n            // default to begining of week\\n            weekday = dow;\\n        }\\n    }\\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\\n        getParsingFlags(config)._overflowWeeks = true;\\n    } else if (weekdayOverflow != null) {\\n        getParsingFlags(config)._overflowWeekday = true;\\n    } else {\\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\\n        config._a[YEAR] = temp.year;\\n        config._dayOfYear = temp.dayOfYear;\\n    }\\n}\\n\\n// constant that refers to the ISO standard\\nhooks.ISO_8601 = function () {};\\n\\n// date from string and format string\\nfunction configFromStringAndFormat(config) {\\n    // TODO: Move this to another part of the creation flow to prevent circular deps\\n    if (config._f === hooks.ISO_8601) {\\n        configFromISO(config);\\n        return;\\n    }\\n\\n    config._a = [];\\n    getParsingFlags(config).empty = true;\\n\\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\\n    var string = '' + config._i,\\n        i, parsedInput, tokens, token, skipped,\\n        stringLength = string.length,\\n        totalParsedInputLength = 0;\\n\\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\\n\\n    for (i = 0; i < tokens.length; i++) {\\n        token = tokens[i];\\n        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\\n        // console.log('token', token, 'parsedInput', parsedInput,\\n        //         'regex', getParseRegexForToken(token, config));\\n        if (parsedInput) {\\n            skipped = string.substr(0, string.indexOf(parsedInput));\\n            if (skipped.length > 0) {\\n                getParsingFlags(config).unusedInput.push(skipped);\\n            }\\n            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\\n            totalParsedInputLength += parsedInput.length;\\n        }\\n        // don't parse if it's not a known token\\n        if (formatTokenFunctions[token]) {\\n            if (parsedInput) {\\n                getParsingFlags(config).empty = false;\\n            }\\n            else {\\n                getParsingFlags(config).unusedTokens.push(token);\\n            }\\n            addTimeToArrayFromToken(token, parsedInput, config);\\n        }\\n        else if (config._strict && !parsedInput) {\\n            getParsingFlags(config).unusedTokens.push(token);\\n        }\\n    }\\n\\n    // add remaining unparsed input length to the string\\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\\n    if (string.length > 0) {\\n        getParsingFlags(config).unusedInput.push(string);\\n    }\\n\\n    // clear _12h flag if hour is <= 12\\n    if (config._a[HOUR] <= 12 &&\\n        getParsingFlags(config).bigHour === true &&\\n        config._a[HOUR] > 0) {\\n        getParsingFlags(config).bigHour = undefined;\\n    }\\n\\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\\n    getParsingFlags(config).meridiem = config._meridiem;\\n    // handle meridiem\\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\\n\\n    configFromArray(config);\\n    checkOverflow(config);\\n}\\n\\n\\nfunction meridiemFixWrap (locale, hour, meridiem) {\\n    var isPm;\\n\\n    if (meridiem == null) {\\n        // nothing to do\\n        return hour;\\n    }\\n    if (locale.meridiemHour != null) {\\n        return locale.meridiemHour(hour, meridiem);\\n    } else if (locale.isPM != null) {\\n        // Fallback\\n        isPm = locale.isPM(meridiem);\\n        if (isPm && hour < 12) {\\n            hour += 12;\\n        }\\n        if (!isPm && hour === 12) {\\n            hour = 0;\\n        }\\n        return hour;\\n    } else {\\n        // this is not supposed to happen\\n        return hour;\\n    }\\n}\\n\\n// date from string and array of format strings\\nfunction configFromStringAndArray(config) {\\n    var tempConfig,\\n        bestMoment,\\n\\n        scoreToBeat,\\n        i,\\n        currentScore;\\n\\n    if (config._f.length === 0) {\\n        getParsingFlags(config).invalidFormat = true;\\n        config._d = new Date(NaN);\\n        return;\\n    }\\n\\n    for (i = 0; i < config._f.length; i++) {\\n        currentScore = 0;\\n        tempConfig = copyConfig({}, config);\\n        if (config._useUTC != null) {\\n            tempConfig._useUTC = config._useUTC;\\n        }\\n        tempConfig._f = config._f[i];\\n        configFromStringAndFormat(tempConfig);\\n\\n        if (!isValid(tempConfig)) {\\n            continue;\\n        }\\n\\n        // if there is any input that was not parsed add a penalty for that format\\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\\n\\n        //or tokens\\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\\n\\n        getParsingFlags(tempConfig).score = currentScore;\\n\\n        if (scoreToBeat == null || currentScore < scoreToBeat) {\\n            scoreToBeat = currentScore;\\n            bestMoment = tempConfig;\\n        }\\n    }\\n\\n    extend(config, bestMoment || tempConfig);\\n}\\n\\nfunction configFromObject(config) {\\n    if (config._d) {\\n        return;\\n    }\\n\\n    var i = normalizeObjectUnits(config._i);\\n    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\\n        return obj && parseInt(obj, 10);\\n    });\\n\\n    configFromArray(config);\\n}\\n\\nfunction createFromConfig (config) {\\n    var res = new Moment(checkOverflow(prepareConfig(config)));\\n    if (res._nextDay) {\\n        // Adding is smart enough around DST\\n        res.add(1, 'd');\\n        res._nextDay = undefined;\\n    }\\n\\n    return res;\\n}\\n\\nfunction prepareConfig (config) {\\n    var input = config._i,\\n        format = config._f;\\n\\n    config._locale = config._locale || getLocale(config._l);\\n\\n    if (input === null || (format === undefined && input === '')) {\\n        return createInvalid({nullInput: true});\\n    }\\n\\n    if (typeof input === 'string') {\\n        config._i = input = config._locale.preparse(input);\\n    }\\n\\n    if (isMoment(input)) {\\n        return new Moment(checkOverflow(input));\\n    } else if (isDate(input)) {\\n        config._d = input;\\n    } else if (isArray(format)) {\\n        configFromStringAndArray(config);\\n    } else if (format) {\\n        configFromStringAndFormat(config);\\n    }  else {\\n        configFromInput(config);\\n    }\\n\\n    if (!isValid(config)) {\\n        config._d = null;\\n    }\\n\\n    return config;\\n}\\n\\nfunction configFromInput(config) {\\n    var input = config._i;\\n    if (input === undefined) {\\n        config._d = new Date(hooks.now());\\n    } else if (isDate(input)) {\\n        config._d = new Date(input.valueOf());\\n    } else if (typeof input === 'string') {\\n        configFromString(config);\\n    } else if (isArray(input)) {\\n        config._a = map(input.slice(0), function (obj) {\\n            return parseInt(obj, 10);\\n        });\\n        configFromArray(config);\\n    } else if (typeof(input) === 'object') {\\n        configFromObject(config);\\n    } else if (isNumber(input)) {\\n        // from milliseconds\\n        config._d = new Date(input);\\n    } else {\\n        hooks.createFromInputFallback(config);\\n    }\\n}\\n\\nfunction createLocalOrUTC (input, format, locale, strict, isUTC) {\\n    var c = {};\\n\\n    if (locale === true || locale === false) {\\n        strict = locale;\\n        locale = undefined;\\n    }\\n\\n    if ((isObject(input) && isObjectEmpty(input)) ||\\n            (isArray(input) && input.length === 0)) {\\n        input = undefined;\\n    }\\n    // object construction must be done this way.\\n    // https://github.com/moment/moment/issues/1423\\n    c._isAMomentObject = true;\\n    c._useUTC = c._isUTC = isUTC;\\n    c._l = locale;\\n    c._i = input;\\n    c._f = format;\\n    c._strict = strict;\\n\\n    return createFromConfig(c);\\n}\\n\\nfunction createLocal (input, format, locale, strict) {\\n    return createLocalOrUTC(input, format, locale, strict, false);\\n}\\n\\nvar prototypeMin = deprecate(\\n    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\\n    function () {\\n        var other = createLocal.apply(null, arguments);\\n        if (this.isValid() && other.isValid()) {\\n            return other < this ? this : other;\\n        } else {\\n            return createInvalid();\\n        }\\n    }\\n);\\n\\nvar prototypeMax = deprecate(\\n    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\\n    function () {\\n        var other = createLocal.apply(null, arguments);\\n        if (this.isValid() && other.isValid()) {\\n            return other > this ? this : other;\\n        } else {\\n            return createInvalid();\\n        }\\n    }\\n);\\n\\n// Pick a moment m from moments so that m[fn](other) is true for all\\n// other. This relies on the function fn to be transitive.\\n//\\n// moments should either be an array of moment objects or an array, whose\\n// first element is an array of moment objects.\\nfunction pickBy(fn, moments) {\\n    var res, i;\\n    if (moments.length === 1 && isArray(moments[0])) {\\n        moments = moments[0];\\n    }\\n    if (!moments.length) {\\n        return createLocal();\\n    }\\n    res = moments[0];\\n    for (i = 1; i < moments.length; ++i) {\\n        if (!moments[i].isValid() || moments[i][fn](res)) {\\n            res = moments[i];\\n        }\\n    }\\n    return res;\\n}\\n\\n// TODO: Use [].sort instead?\\nfunction min () {\\n    var args = [].slice.call(arguments, 0);\\n\\n    return pickBy('isBefore', args);\\n}\\n\\nfunction max () {\\n    var args = [].slice.call(arguments, 0);\\n\\n    return pickBy('isAfter', args);\\n}\\n\\nvar now = function () {\\n    return Date.now ? Date.now() : +(new Date());\\n};\\n\\nfunction Duration (duration) {\\n    var normalizedInput = normalizeObjectUnits(duration),\\n        years = normalizedInput.year || 0,\\n        quarters = normalizedInput.quarter || 0,\\n        months = normalizedInput.month || 0,\\n        weeks = normalizedInput.week || 0,\\n        days = normalizedInput.day || 0,\\n        hours = normalizedInput.hour || 0,\\n        minutes = normalizedInput.minute || 0,\\n        seconds = normalizedInput.second || 0,\\n        milliseconds = normalizedInput.millisecond || 0;\\n\\n    // representation for dateAddRemove\\n    this._milliseconds = +milliseconds +\\n        seconds * 1e3 + // 1000\\n        minutes * 6e4 + // 1000 * 60\\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\\n    // Because of dateAddRemove treats 24 hours as different from a\\n    // day when working around DST, we need to store them separately\\n    this._days = +days +\\n        weeks * 7;\\n    // It is impossible translate months into days without knowing\\n    // which months you are are talking about, so we have to store\\n    // it separately.\\n    this._months = +months +\\n        quarters * 3 +\\n        years * 12;\\n\\n    this._data = {};\\n\\n    this._locale = getLocale();\\n\\n    this._bubble();\\n}\\n\\nfunction isDuration (obj) {\\n    return obj instanceof Duration;\\n}\\n\\nfunction absRound (number) {\\n    if (number < 0) {\\n        return Math.round(-1 * number) * -1;\\n    } else {\\n        return Math.round(number);\\n    }\\n}\\n\\n// FORMATTING\\n\\nfunction offset (token, separator) {\\n    addFormatToken(token, 0, 0, function () {\\n        var offset = this.utcOffset();\\n        var sign = '+';\\n        if (offset < 0) {\\n            offset = -offset;\\n            sign = '-';\\n        }\\n        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\\n    });\\n}\\n\\noffset('Z', ':');\\noffset('ZZ', '');\\n\\n// PARSING\\n\\naddRegexToken('Z',  matchShortOffset);\\naddRegexToken('ZZ', matchShortOffset);\\naddParseToken(['Z', 'ZZ'], function (input, array, config) {\\n    config._useUTC = true;\\n    config._tzm = offsetFromString(matchShortOffset, input);\\n});\\n\\n// HELPERS\\n\\n// timezone chunker\\n// '+10:00' > ['10',  '00']\\n// '-1530'  > ['-15', '30']\\nvar chunkOffset = /([\\\\+\\\\-]|\\\\d\\\\d)/gi;\\n\\nfunction offsetFromString(matcher, string) {\\n    var matches = (string || '').match(matcher);\\n\\n    if (matches === null) {\\n        return null;\\n    }\\n\\n    var chunk   = matches[matches.length - 1] || [];\\n    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\\n    var minutes = +(parts[1] * 60) + toInt(parts[2]);\\n\\n    return minutes === 0 ?\\n      0 :\\n      parts[0] === '+' ? minutes : -minutes;\\n}\\n\\n// Return a moment from input, that is local/utc/zone equivalent to model.\\nfunction cloneWithOffset(input, model) {\\n    var res, diff;\\n    if (model._isUTC) {\\n        res = model.clone();\\n        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\\n        // Use low-level api, because this fn is low-level api.\\n        res._d.setTime(res._d.valueOf() + diff);\\n        hooks.updateOffset(res, false);\\n        return res;\\n    } else {\\n        return createLocal(input).local();\\n    }\\n}\\n\\nfunction getDateOffset (m) {\\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\\n    // https://github.com/moment/moment/pull/1871\\n    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\\n}\\n\\n// HOOKS\\n\\n// This function will be called whenever a moment is mutated.\\n// It is intended to keep the offset in sync with the timezone.\\nhooks.updateOffset = function () {};\\n\\n// MOMENTS\\n\\n// keepLocalTime = true means only change the timezone, without\\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\\n// +0200, so we adjust the time as needed, to be valid.\\n//\\n// Keeping the time actually adds/subtracts (one hour)\\n// from the actual represented time. That is why we call updateOffset\\n// a second time. In case it wants us to change the offset again\\n// _changeInProgress == true case, then we have to adjust, because\\n// there is no such time in the given timezone.\\nfunction getSetOffset (input, keepLocalTime) {\\n    var offset = this._offset || 0,\\n        localAdjust;\\n    if (!this.isValid()) {\\n        return input != null ? this : NaN;\\n    }\\n    if (input != null) {\\n        if (typeof input === 'string') {\\n            input = offsetFromString(matchShortOffset, input);\\n            if (input === null) {\\n                return this;\\n            }\\n        } else if (Math.abs(input) < 16) {\\n            input = input * 60;\\n        }\\n        if (!this._isUTC && keepLocalTime) {\\n            localAdjust = getDateOffset(this);\\n        }\\n        this._offset = input;\\n        this._isUTC = true;\\n        if (localAdjust != null) {\\n            this.add(localAdjust, 'm');\\n        }\\n        if (offset !== input) {\\n            if (!keepLocalTime || this._changeInProgress) {\\n                addSubtract(this, createDuration(input - offset, 'm'), 1, false);\\n            } else if (!this._changeInProgress) {\\n                this._changeInProgress = true;\\n                hooks.updateOffset(this, true);\\n                this._changeInProgress = null;\\n            }\\n        }\\n        return this;\\n    } else {\\n        return this._isUTC ? offset : getDateOffset(this);\\n    }\\n}\\n\\nfunction getSetZone (input, keepLocalTime) {\\n    if (input != null) {\\n        if (typeof input !== 'string') {\\n            input = -input;\\n        }\\n\\n        this.utcOffset(input, keepLocalTime);\\n\\n        return this;\\n    } else {\\n        return -this.utcOffset();\\n    }\\n}\\n\\nfunction setOffsetToUTC (keepLocalTime) {\\n    return this.utcOffset(0, keepLocalTime);\\n}\\n\\nfunction setOffsetToLocal (keepLocalTime) {\\n    if (this._isUTC) {\\n        this.utcOffset(0, keepLocalTime);\\n        this._isUTC = false;\\n\\n        if (keepLocalTime) {\\n            this.subtract(getDateOffset(this), 'm');\\n        }\\n    }\\n    return this;\\n}\\n\\nfunction setOffsetToParsedOffset () {\\n    if (this._tzm != null) {\\n        this.utcOffset(this._tzm);\\n    } else if (typeof this._i === 'string') {\\n        var tZone = offsetFromString(matchOffset, this._i);\\n        if (tZone != null) {\\n            this.utcOffset(tZone);\\n        }\\n        else {\\n            this.utcOffset(0, true);\\n        }\\n    }\\n    return this;\\n}\\n\\nfunction hasAlignedHourOffset (input) {\\n    if (!this.isValid()) {\\n        return false;\\n    }\\n    input = input ? createLocal(input).utcOffset() : 0;\\n\\n    return (this.utcOffset() - input) % 60 === 0;\\n}\\n\\nfunction isDaylightSavingTime () {\\n    return (\\n        this.utcOffset() > this.clone().month(0).utcOffset() ||\\n        this.utcOffset() > this.clone().month(5).utcOffset()\\n    );\\n}\\n\\nfunction isDaylightSavingTimeShifted () {\\n    if (!isUndefined(this._isDSTShifted)) {\\n        return this._isDSTShifted;\\n    }\\n\\n    var c = {};\\n\\n    copyConfig(c, this);\\n    c = prepareConfig(c);\\n\\n    if (c._a) {\\n        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\\n        this._isDSTShifted = this.isValid() &&\\n            compareArrays(c._a, other.toArray()) > 0;\\n    } else {\\n        this._isDSTShifted = false;\\n    }\\n\\n    return this._isDSTShifted;\\n}\\n\\nfunction isLocal () {\\n    return this.isValid() ? !this._isUTC : false;\\n}\\n\\nfunction isUtcOffset () {\\n    return this.isValid() ? this._isUTC : false;\\n}\\n\\nfunction isUtc () {\\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\\n}\\n\\n// ASP.NET json date format regex\\nvar aspNetRegex = /^(\\\\-)?(?:(\\\\d*)[. ])?(\\\\d+)\\\\:(\\\\d+)(?:\\\\:(\\\\d+)(\\\\.\\\\d*)?)?$/;\\n\\n// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\\n// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\\n// and further modified to allow for strings containing both week and day\\nvar isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;\\n\\nfunction createDuration (input, key) {\\n    var duration = input,\\n        // matching against regexp is expensive, do it on demand\\n        match = null,\\n        sign,\\n        ret,\\n        diffRes;\\n\\n    if (isDuration(input)) {\\n        duration = {\\n            ms : input._milliseconds,\\n            d  : input._days,\\n            M  : input._months\\n        };\\n    } else if (isNumber(input)) {\\n        duration = {};\\n        if (key) {\\n            duration[key] = input;\\n        } else {\\n            duration.milliseconds = input;\\n        }\\n    } else if (!!(match = aspNetRegex.exec(input))) {\\n        sign = (match[1] === '-') ? -1 : 1;\\n        duration = {\\n            y  : 0,\\n            d  : toInt(match[DATE])                         * sign,\\n            h  : toInt(match[HOUR])                         * sign,\\n            m  : toInt(match[MINUTE])                       * sign,\\n            s  : toInt(match[SECOND])                       * sign,\\n            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\\n        };\\n    } else if (!!(match = isoRegex.exec(input))) {\\n        sign = (match[1] === '-') ? -1 : 1;\\n        duration = {\\n            y : parseIso(match[2], sign),\\n            M : parseIso(match[3], sign),\\n            w : parseIso(match[4], sign),\\n            d : parseIso(match[5], sign),\\n            h : parseIso(match[6], sign),\\n            m : parseIso(match[7], sign),\\n            s : parseIso(match[8], sign)\\n        };\\n    } else if (duration == null) {// checks for null or undefined\\n        duration = {};\\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\\n        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\\n\\n        duration = {};\\n        duration.ms = diffRes.milliseconds;\\n        duration.M = diffRes.months;\\n    }\\n\\n    ret = new Duration(duration);\\n\\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\\n        ret._locale = input._locale;\\n    }\\n\\n    return ret;\\n}\\n\\ncreateDuration.fn = Duration.prototype;\\n\\nfunction parseIso (inp, sign) {\\n    // We'd normally use ~~inp for this, but unfortunately it also\\n    // converts floats to ints.\\n    // inp may be undefined, so careful calling replace on it.\\n    var res = inp && parseFloat(inp.replace(',', '.'));\\n    // apply sign while we're at it\\n    return (isNaN(res) ? 0 : res) * sign;\\n}\\n\\nfunction positiveMomentsDifference(base, other) {\\n    var res = {milliseconds: 0, months: 0};\\n\\n    res.months = other.month() - base.month() +\\n        (other.year() - base.year()) * 12;\\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\\n        --res.months;\\n    }\\n\\n    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\\n\\n    return res;\\n}\\n\\nfunction momentsDifference(base, other) {\\n    var res;\\n    if (!(base.isValid() && other.isValid())) {\\n        return {milliseconds: 0, months: 0};\\n    }\\n\\n    other = cloneWithOffset(other, base);\\n    if (base.isBefore(other)) {\\n        res = positiveMomentsDifference(base, other);\\n    } else {\\n        res = positiveMomentsDifference(other, base);\\n        res.milliseconds = -res.milliseconds;\\n        res.months = -res.months;\\n    }\\n\\n    return res;\\n}\\n\\n// TODO: remove 'name' arg after deprecation is removed\\nfunction createAdder(direction, name) {\\n    return function (val, period) {\\n        var dur, tmp;\\n        //invert the arguments, but complain about it\\n        if (period !== null && !isNaN(+period)) {\\n            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\\n            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\\n            tmp = val; val = period; period = tmp;\\n        }\\n\\n        val = typeof val === 'string' ? +val : val;\\n        dur = createDuration(val, period);\\n        addSubtract(this, dur, direction);\\n        return this;\\n    };\\n}\\n\\nfunction addSubtract (mom, duration, isAdding, updateOffset) {\\n    var milliseconds = duration._milliseconds,\\n        days = absRound(duration._days),\\n        months = absRound(duration._months);\\n\\n    if (!mom.isValid()) {\\n        // No op\\n        return;\\n    }\\n\\n    updateOffset = updateOffset == null ? true : updateOffset;\\n\\n    if (milliseconds) {\\n        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\\n    }\\n    if (days) {\\n        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\\n    }\\n    if (months) {\\n        setMonth(mom, get(mom, 'Month') + months * isAdding);\\n    }\\n    if (updateOffset) {\\n        hooks.updateOffset(mom, days || months);\\n    }\\n}\\n\\nvar add      = createAdder(1, 'add');\\nvar subtract = createAdder(-1, 'subtract');\\n\\nfunction getCalendarFormat(myMoment, now) {\\n    var diff = myMoment.diff(now, 'days', true);\\n    return diff < -6 ? 'sameElse' :\\n            diff < -1 ? 'lastWeek' :\\n            diff < 0 ? 'lastDay' :\\n            diff < 1 ? 'sameDay' :\\n            diff < 2 ? 'nextDay' :\\n            diff < 7 ? 'nextWeek' : 'sameElse';\\n}\\n\\nfunction calendar$1 (time, formats) {\\n    // We want to compare the start of today, vs this.\\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\\n    var now = time || createLocal(),\\n        sod = cloneWithOffset(now, this).startOf('day'),\\n        format = hooks.calendarFormat(this, sod) || 'sameElse';\\n\\n    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\\n\\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\\n}\\n\\nfunction clone () {\\n    return new Moment(this);\\n}\\n\\nfunction isAfter (input, units) {\\n    var localInput = isMoment(input) ? input : createLocal(input);\\n    if (!(this.isValid() && localInput.isValid())) {\\n        return false;\\n    }\\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\\n    if (units === 'millisecond') {\\n        return this.valueOf() > localInput.valueOf();\\n    } else {\\n        return localInput.valueOf() < this.clone().startOf(units).valueOf();\\n    }\\n}\\n\\nfunction isBefore (input, units) {\\n    var localInput = isMoment(input) ? input : createLocal(input);\\n    if (!(this.isValid() && localInput.isValid())) {\\n        return false;\\n    }\\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\\n    if (units === 'millisecond') {\\n        return this.valueOf() < localInput.valueOf();\\n    } else {\\n        return this.clone().endOf(units).valueOf() < localInput.valueOf();\\n    }\\n}\\n\\nfunction isBetween (from, to, units, inclusivity) {\\n    inclusivity = inclusivity || '()';\\n    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\\n        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\\n}\\n\\nfunction isSame (input, units) {\\n    var localInput = isMoment(input) ? input : createLocal(input),\\n        inputMs;\\n    if (!(this.isValid() && localInput.isValid())) {\\n        return false;\\n    }\\n    units = normalizeUnits(units || 'millisecond');\\n    if (units === 'millisecond') {\\n        return this.valueOf() === localInput.valueOf();\\n    } else {\\n        inputMs = localInput.valueOf();\\n        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\\n    }\\n}\\n\\nfunction isSameOrAfter (input, units) {\\n    return this.isSame(input, units) || this.isAfter(input,units);\\n}\\n\\nfunction isSameOrBefore (input, units) {\\n    return this.isSame(input, units) || this.isBefore(input,units);\\n}\\n\\nfunction diff (input, units, asFloat) {\\n    var that,\\n        zoneDelta,\\n        delta, output;\\n\\n    if (!this.isValid()) {\\n        return NaN;\\n    }\\n\\n    that = cloneWithOffset(input, this);\\n\\n    if (!that.isValid()) {\\n        return NaN;\\n    }\\n\\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\\n\\n    units = normalizeUnits(units);\\n\\n    if (units === 'year' || units === 'month' || units === 'quarter') {\\n        output = monthDiff(this, that);\\n        if (units === 'quarter') {\\n            output = output / 3;\\n        } else if (units === 'year') {\\n            output = output / 12;\\n        }\\n    } else {\\n        delta = this - that;\\n        output = units === 'second' ? delta / 1e3 : // 1000\\n            units === 'minute' ? delta / 6e4 : // 1000 * 60\\n            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\\n            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\\n            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\\n            delta;\\n    }\\n    return asFloat ? output : absFloor(output);\\n}\\n\\nfunction monthDiff (a, b) {\\n    // difference in months\\n    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\\n        // b is in (anchor - 1 month, anchor + 1 month)\\n        anchor = a.clone().add(wholeMonthDiff, 'months'),\\n        anchor2, adjust;\\n\\n    if (b - anchor < 0) {\\n        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\\n        // linear across the month\\n        adjust = (b - anchor) / (anchor - anchor2);\\n    } else {\\n        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\\n        // linear across the month\\n        adjust = (b - anchor) / (anchor2 - anchor);\\n    }\\n\\n    //check for negative zero, return zero if negative zero\\n    return -(wholeMonthDiff + adjust) || 0;\\n}\\n\\nhooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\\nhooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\\n\\nfunction toString () {\\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\\n}\\n\\nfunction toISOString () {\\n    var m = this.clone().utc();\\n    if (0 < m.year() && m.year() <= 9999) {\\n        if (isFunction(Date.prototype.toISOString)) {\\n            // native implementation is ~50x faster, use it when we can\\n            return this.toDate().toISOString();\\n        } else {\\n            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\\n        }\\n    } else {\\n        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\\n    }\\n}\\n\\n/**\\n * Return a human readable representation of a moment that can\\n * also be evaluated to get a new moment which is the same\\n *\\n * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\\n */\\nfunction inspect () {\\n    if (!this.isValid()) {\\n        return 'moment.invalid(/* ' + this._i + ' */)';\\n    }\\n    var func = 'moment';\\n    var zone = '';\\n    if (!this.isLocal()) {\\n        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\\n        zone = 'Z';\\n    }\\n    var prefix = '[' + func + '(\\\"]';\\n    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\\n    var datetime = '-MM-DD[T]HH:mm:ss.SSS';\\n    var suffix = zone + '[\\\")]';\\n\\n    return this.format(prefix + year + datetime + suffix);\\n}\\n\\nfunction format (inputString) {\\n    if (!inputString) {\\n        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\\n    }\\n    var output = formatMoment(this, inputString);\\n    return this.localeData().postformat(output);\\n}\\n\\nfunction from (time, withoutSuffix) {\\n    if (this.isValid() &&\\n            ((isMoment(time) && time.isValid()) ||\\n             createLocal(time).isValid())) {\\n        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\\n    } else {\\n        return this.localeData().invalidDate();\\n    }\\n}\\n\\nfunction fromNow (withoutSuffix) {\\n    return this.from(createLocal(), withoutSuffix);\\n}\\n\\nfunction to (time, withoutSuffix) {\\n    if (this.isValid() &&\\n            ((isMoment(time) && time.isValid()) ||\\n             createLocal(time).isValid())) {\\n        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\\n    } else {\\n        return this.localeData().invalidDate();\\n    }\\n}\\n\\nfunction toNow (withoutSuffix) {\\n    return this.to(createLocal(), withoutSuffix);\\n}\\n\\n// If passed a locale key, it will set the locale for this\\n// instance.  Otherwise, it will return the locale configuration\\n// variables for this instance.\\nfunction locale (key) {\\n    var newLocaleData;\\n\\n    if (key === undefined) {\\n        return this._locale._abbr;\\n    } else {\\n        newLocaleData = getLocale(key);\\n        if (newLocaleData != null) {\\n            this._locale = newLocaleData;\\n        }\\n        return this;\\n    }\\n}\\n\\nvar lang = deprecate(\\n    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\\n    function (key) {\\n        if (key === undefined) {\\n            return this.localeData();\\n        } else {\\n            return this.locale(key);\\n        }\\n    }\\n);\\n\\nfunction localeData () {\\n    return this._locale;\\n}\\n\\nfunction startOf (units) {\\n    units = normalizeUnits(units);\\n    // the following switch intentionally omits break keywords\\n    // to utilize falling through the cases.\\n    switch (units) {\\n        case 'year':\\n            this.month(0);\\n            /* falls through */\\n        case 'quarter':\\n        case 'month':\\n            this.date(1);\\n            /* falls through */\\n        case 'week':\\n        case 'isoWeek':\\n        case 'day':\\n        case 'date':\\n            this.hours(0);\\n            /* falls through */\\n        case 'hour':\\n            this.minutes(0);\\n            /* falls through */\\n        case 'minute':\\n            this.seconds(0);\\n            /* falls through */\\n        case 'second':\\n            this.milliseconds(0);\\n    }\\n\\n    // weeks are a special case\\n    if (units === 'week') {\\n        this.weekday(0);\\n    }\\n    if (units === 'isoWeek') {\\n        this.isoWeekday(1);\\n    }\\n\\n    // quarters are also special\\n    if (units === 'quarter') {\\n        this.month(Math.floor(this.month() / 3) * 3);\\n    }\\n\\n    return this;\\n}\\n\\nfunction endOf (units) {\\n    units = normalizeUnits(units);\\n    if (units === undefined || units === 'millisecond') {\\n        return this;\\n    }\\n\\n    // 'date' is an alias for 'day', so it should be considered as such.\\n    if (units === 'date') {\\n        units = 'day';\\n    }\\n\\n    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\\n}\\n\\nfunction valueOf () {\\n    return this._d.valueOf() - ((this._offset || 0) * 60000);\\n}\\n\\nfunction unix () {\\n    return Math.floor(this.valueOf() / 1000);\\n}\\n\\nfunction toDate () {\\n    return new Date(this.valueOf());\\n}\\n\\nfunction toArray () {\\n    var m = this;\\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\\n}\\n\\nfunction toObject () {\\n    var m = this;\\n    return {\\n        years: m.year(),\\n        months: m.month(),\\n        date: m.date(),\\n        hours: m.hours(),\\n        minutes: m.minutes(),\\n        seconds: m.seconds(),\\n        milliseconds: m.milliseconds()\\n    };\\n}\\n\\nfunction toJSON () {\\n    // new Date(NaN).toJSON() === null\\n    return this.isValid() ? this.toISOString() : null;\\n}\\n\\nfunction isValid$1 () {\\n    return isValid(this);\\n}\\n\\nfunction parsingFlags () {\\n    return extend({}, getParsingFlags(this));\\n}\\n\\nfunction invalidAt () {\\n    return getParsingFlags(this).overflow;\\n}\\n\\nfunction creationData() {\\n    return {\\n        input: this._i,\\n        format: this._f,\\n        locale: this._locale,\\n        isUTC: this._isUTC,\\n        strict: this._strict\\n    };\\n}\\n\\n// FORMATTING\\n\\naddFormatToken(0, ['gg', 2], 0, function () {\\n    return this.weekYear() % 100;\\n});\\n\\naddFormatToken(0, ['GG', 2], 0, function () {\\n    return this.isoWeekYear() % 100;\\n});\\n\\nfunction addWeekYearFormatToken (token, getter) {\\n    addFormatToken(0, [token, token.length], 0, getter);\\n}\\n\\naddWeekYearFormatToken('gggg',     'weekYear');\\naddWeekYearFormatToken('ggggg',    'weekYear');\\naddWeekYearFormatToken('GGGG',  'isoWeekYear');\\naddWeekYearFormatToken('GGGGG', 'isoWeekYear');\\n\\n// ALIASES\\n\\naddUnitAlias('weekYear', 'gg');\\naddUnitAlias('isoWeekYear', 'GG');\\n\\n// PRIORITY\\n\\naddUnitPriority('weekYear', 1);\\naddUnitPriority('isoWeekYear', 1);\\n\\n\\n// PARSING\\n\\naddRegexToken('G',      matchSigned);\\naddRegexToken('g',      matchSigned);\\naddRegexToken('GG',     match1to2, match2);\\naddRegexToken('gg',     match1to2, match2);\\naddRegexToken('GGGG',   match1to4, match4);\\naddRegexToken('gggg',   match1to4, match4);\\naddRegexToken('GGGGG',  match1to6, match6);\\naddRegexToken('ggggg',  match1to6, match6);\\n\\naddWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\\n    week[token.substr(0, 2)] = toInt(input);\\n});\\n\\naddWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\\n    week[token] = hooks.parseTwoDigitYear(input);\\n});\\n\\n// MOMENTS\\n\\nfunction getSetWeekYear (input) {\\n    return getSetWeekYearHelper.call(this,\\n            input,\\n            this.week(),\\n            this.weekday(),\\n            this.localeData()._week.dow,\\n            this.localeData()._week.doy);\\n}\\n\\nfunction getSetISOWeekYear (input) {\\n    return getSetWeekYearHelper.call(this,\\n            input, this.isoWeek(), this.isoWeekday(), 1, 4);\\n}\\n\\nfunction getISOWeeksInYear () {\\n    return weeksInYear(this.year(), 1, 4);\\n}\\n\\nfunction getWeeksInYear () {\\n    var weekInfo = this.localeData()._week;\\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\\n}\\n\\nfunction getSetWeekYearHelper(input, week, weekday, dow, doy) {\\n    var weeksTarget;\\n    if (input == null) {\\n        return weekOfYear(this, dow, doy).year;\\n    } else {\\n        weeksTarget = weeksInYear(input, dow, doy);\\n        if (week > weeksTarget) {\\n            week = weeksTarget;\\n        }\\n        return setWeekAll.call(this, input, week, weekday, dow, doy);\\n    }\\n}\\n\\nfunction setWeekAll(weekYear, week, weekday, dow, doy) {\\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\\n        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\\n\\n    this.year(date.getUTCFullYear());\\n    this.month(date.getUTCMonth());\\n    this.date(date.getUTCDate());\\n    return this;\\n}\\n\\n// FORMATTING\\n\\naddFormatToken('Q', 0, 'Qo', 'quarter');\\n\\n// ALIASES\\n\\naddUnitAlias('quarter', 'Q');\\n\\n// PRIORITY\\n\\naddUnitPriority('quarter', 7);\\n\\n// PARSING\\n\\naddRegexToken('Q', match1);\\naddParseToken('Q', function (input, array) {\\n    array[MONTH] = (toInt(input) - 1) * 3;\\n});\\n\\n// MOMENTS\\n\\nfunction getSetQuarter (input) {\\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\\n}\\n\\n// FORMATTING\\n\\naddFormatToken('D', ['DD', 2], 'Do', 'date');\\n\\n// ALIASES\\n\\naddUnitAlias('date', 'D');\\n\\n// PRIOROITY\\naddUnitPriority('date', 9);\\n\\n// PARSING\\n\\naddRegexToken('D',  match1to2);\\naddRegexToken('DD', match1to2, match2);\\naddRegexToken('Do', function (isStrict, locale) {\\n    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;\\n});\\n\\naddParseToken(['D', 'DD'], DATE);\\naddParseToken('Do', function (input, array) {\\n    array[DATE] = toInt(input.match(match1to2)[0], 10);\\n});\\n\\n// MOMENTS\\n\\nvar getSetDayOfMonth = makeGetSet('Date', true);\\n\\n// FORMATTING\\n\\naddFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\\n\\n// ALIASES\\n\\naddUnitAlias('dayOfYear', 'DDD');\\n\\n// PRIORITY\\naddUnitPriority('dayOfYear', 4);\\n\\n// PARSING\\n\\naddRegexToken('DDD',  match1to3);\\naddRegexToken('DDDD', match3);\\naddParseToken(['DDD', 'DDDD'], function (input, array, config) {\\n    config._dayOfYear = toInt(input);\\n});\\n\\n// HELPERS\\n\\n// MOMENTS\\n\\nfunction getSetDayOfYear (input) {\\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\\n    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\\n}\\n\\n// FORMATTING\\n\\naddFormatToken('m', ['mm', 2], 0, 'minute');\\n\\n// ALIASES\\n\\naddUnitAlias('minute', 'm');\\n\\n// PRIORITY\\n\\naddUnitPriority('minute', 14);\\n\\n// PARSING\\n\\naddRegexToken('m',  match1to2);\\naddRegexToken('mm', match1to2, match2);\\naddParseToken(['m', 'mm'], MINUTE);\\n\\n// MOMENTS\\n\\nvar getSetMinute = makeGetSet('Minutes', false);\\n\\n// FORMATTING\\n\\naddFormatToken('s', ['ss', 2], 0, 'second');\\n\\n// ALIASES\\n\\naddUnitAlias('second', 's');\\n\\n// PRIORITY\\n\\naddUnitPriority('second', 15);\\n\\n// PARSING\\n\\naddRegexToken('s',  match1to2);\\naddRegexToken('ss', match1to2, match2);\\naddParseToken(['s', 'ss'], SECOND);\\n\\n// MOMENTS\\n\\nvar getSetSecond = makeGetSet('Seconds', false);\\n\\n// FORMATTING\\n\\naddFormatToken('S', 0, 0, function () {\\n    return ~~(this.millisecond() / 100);\\n});\\n\\naddFormatToken(0, ['SS', 2], 0, function () {\\n    return ~~(this.millisecond() / 10);\\n});\\n\\naddFormatToken(0, ['SSS', 3], 0, 'millisecond');\\naddFormatToken(0, ['SSSS', 4], 0, function () {\\n    return this.millisecond() * 10;\\n});\\naddFormatToken(0, ['SSSSS', 5], 0, function () {\\n    return this.millisecond() * 100;\\n});\\naddFormatToken(0, ['SSSSSS', 6], 0, function () {\\n    return this.millisecond() * 1000;\\n});\\naddFormatToken(0, ['SSSSSSS', 7], 0, function () {\\n    return this.millisecond() * 10000;\\n});\\naddFormatToken(0, ['SSSSSSSS', 8], 0, function () {\\n    return this.millisecond() * 100000;\\n});\\naddFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\\n    return this.millisecond() * 1000000;\\n});\\n\\n\\n// ALIASES\\n\\naddUnitAlias('millisecond', 'ms');\\n\\n// PRIORITY\\n\\naddUnitPriority('millisecond', 16);\\n\\n// PARSING\\n\\naddRegexToken('S',    match1to3, match1);\\naddRegexToken('SS',   match1to3, match2);\\naddRegexToken('SSS',  match1to3, match3);\\n\\nvar token;\\nfor (token = 'SSSS'; token.length <= 9; token += 'S') {\\n    addRegexToken(token, matchUnsigned);\\n}\\n\\nfunction parseMs(input, array) {\\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\\n}\\n\\nfor (token = 'S'; token.length <= 9; token += 'S') {\\n    addParseToken(token, parseMs);\\n}\\n// MOMENTS\\n\\nvar getSetMillisecond = makeGetSet('Milliseconds', false);\\n\\n// FORMATTING\\n\\naddFormatToken('z',  0, 0, 'zoneAbbr');\\naddFormatToken('zz', 0, 0, 'zoneName');\\n\\n// MOMENTS\\n\\nfunction getZoneAbbr () {\\n    return this._isUTC ? 'UTC' : '';\\n}\\n\\nfunction getZoneName () {\\n    return this._isUTC ? 'Coordinated Universal Time' : '';\\n}\\n\\nvar proto = Moment.prototype;\\n\\nproto.add               = add;\\nproto.calendar          = calendar$1;\\nproto.clone             = clone;\\nproto.diff              = diff;\\nproto.endOf             = endOf;\\nproto.format            = format;\\nproto.from              = from;\\nproto.fromNow           = fromNow;\\nproto.to                = to;\\nproto.toNow             = toNow;\\nproto.get               = stringGet;\\nproto.invalidAt         = invalidAt;\\nproto.isAfter           = isAfter;\\nproto.isBefore          = isBefore;\\nproto.isBetween         = isBetween;\\nproto.isSame            = isSame;\\nproto.isSameOrAfter     = isSameOrAfter;\\nproto.isSameOrBefore    = isSameOrBefore;\\nproto.isValid           = isValid$1;\\nproto.lang              = lang;\\nproto.locale            = locale;\\nproto.localeData        = localeData;\\nproto.max               = prototypeMax;\\nproto.min               = prototypeMin;\\nproto.parsingFlags      = parsingFlags;\\nproto.set               = stringSet;\\nproto.startOf           = startOf;\\nproto.subtract          = subtract;\\nproto.toArray           = toArray;\\nproto.toObject          = toObject;\\nproto.toDate            = toDate;\\nproto.toISOString       = toISOString;\\nproto.inspect           = inspect;\\nproto.toJSON            = toJSON;\\nproto.toString          = toString;\\nproto.unix              = unix;\\nproto.valueOf           = valueOf;\\nproto.creationData      = creationData;\\n\\n// Year\\nproto.year       = getSetYear;\\nproto.isLeapYear = getIsLeapYear;\\n\\n// Week Year\\nproto.weekYear    = getSetWeekYear;\\nproto.isoWeekYear = getSetISOWeekYear;\\n\\n// Quarter\\nproto.quarter = proto.quarters = getSetQuarter;\\n\\n// Month\\nproto.month       = getSetMonth;\\nproto.daysInMonth = getDaysInMonth;\\n\\n// Week\\nproto.week           = proto.weeks        = getSetWeek;\\nproto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\\nproto.weeksInYear    = getWeeksInYear;\\nproto.isoWeeksInYear = getISOWeeksInYear;\\n\\n// Day\\nproto.date       = getSetDayOfMonth;\\nproto.day        = proto.days             = getSetDayOfWeek;\\nproto.weekday    = getSetLocaleDayOfWeek;\\nproto.isoWeekday = getSetISODayOfWeek;\\nproto.dayOfYear  = getSetDayOfYear;\\n\\n// Hour\\nproto.hour = proto.hours = getSetHour;\\n\\n// Minute\\nproto.minute = proto.minutes = getSetMinute;\\n\\n// Second\\nproto.second = proto.seconds = getSetSecond;\\n\\n// Millisecond\\nproto.millisecond = proto.milliseconds = getSetMillisecond;\\n\\n// Offset\\nproto.utcOffset            = getSetOffset;\\nproto.utc                  = setOffsetToUTC;\\nproto.local                = setOffsetToLocal;\\nproto.parseZone            = setOffsetToParsedOffset;\\nproto.hasAlignedHourOffset = hasAlignedHourOffset;\\nproto.isDST                = isDaylightSavingTime;\\nproto.isLocal              = isLocal;\\nproto.isUtcOffset          = isUtcOffset;\\nproto.isUtc                = isUtc;\\nproto.isUTC                = isUtc;\\n\\n// Timezone\\nproto.zoneAbbr = getZoneAbbr;\\nproto.zoneName = getZoneName;\\n\\n// Deprecations\\nproto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\\nproto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\\nproto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\\nproto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\\nproto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\\n\\nfunction createUnix (input) {\\n    return createLocal(input * 1000);\\n}\\n\\nfunction createInZone () {\\n    return createLocal.apply(null, arguments).parseZone();\\n}\\n\\nfunction preParsePostFormat (string) {\\n    return string;\\n}\\n\\nvar proto$1 = Locale.prototype;\\n\\nproto$1.calendar        = calendar;\\nproto$1.longDateFormat  = longDateFormat;\\nproto$1.invalidDate     = invalidDate;\\nproto$1.ordinal         = ordinal;\\nproto$1.preparse        = preParsePostFormat;\\nproto$1.postformat      = preParsePostFormat;\\nproto$1.relativeTime    = relativeTime;\\nproto$1.pastFuture      = pastFuture;\\nproto$1.set             = set;\\n\\n// Month\\nproto$1.months            =        localeMonths;\\nproto$1.monthsShort       =        localeMonthsShort;\\nproto$1.monthsParse       =        localeMonthsParse;\\nproto$1.monthsRegex       = monthsRegex;\\nproto$1.monthsShortRegex  = monthsShortRegex;\\n\\n// Week\\nproto$1.week = localeWeek;\\nproto$1.firstDayOfYear = localeFirstDayOfYear;\\nproto$1.firstDayOfWeek = localeFirstDayOfWeek;\\n\\n// Day of Week\\nproto$1.weekdays       =        localeWeekdays;\\nproto$1.weekdaysMin    =        localeWeekdaysMin;\\nproto$1.weekdaysShort  =        localeWeekdaysShort;\\nproto$1.weekdaysParse  =        localeWeekdaysParse;\\n\\nproto$1.weekdaysRegex       =        weekdaysRegex;\\nproto$1.weekdaysShortRegex  =        weekdaysShortRegex;\\nproto$1.weekdaysMinRegex    =        weekdaysMinRegex;\\n\\n// Hours\\nproto$1.isPM = localeIsPM;\\nproto$1.meridiem = localeMeridiem;\\n\\nfunction get$1 (format, index, field, setter) {\\n    var locale = getLocale();\\n    var utc = createUTC().set(setter, index);\\n    return locale[field](utc, format);\\n}\\n\\nfunction listMonthsImpl (format, index, field) {\\n    if (isNumber(format)) {\\n        index = format;\\n        format = undefined;\\n    }\\n\\n    format = format || '';\\n\\n    if (index != null) {\\n        return get$1(format, index, field, 'month');\\n    }\\n\\n    var i;\\n    var out = [];\\n    for (i = 0; i < 12; i++) {\\n        out[i] = get$1(format, i, field, 'month');\\n    }\\n    return out;\\n}\\n\\n// ()\\n// (5)\\n// (fmt, 5)\\n// (fmt)\\n// (true)\\n// (true, 5)\\n// (true, fmt, 5)\\n// (true, fmt)\\nfunction listWeekdaysImpl (localeSorted, format, index, field) {\\n    if (typeof localeSorted === 'boolean') {\\n        if (isNumber(format)) {\\n            index = format;\\n            format = undefined;\\n        }\\n\\n        format = format || '';\\n    } else {\\n        format = localeSorted;\\n        index = format;\\n        localeSorted = false;\\n\\n        if (isNumber(format)) {\\n            index = format;\\n            format = undefined;\\n        }\\n\\n        format = format || '';\\n    }\\n\\n    var locale = getLocale(),\\n        shift = localeSorted ? locale._week.dow : 0;\\n\\n    if (index != null) {\\n        return get$1(format, (index + shift) % 7, field, 'day');\\n    }\\n\\n    var i;\\n    var out = [];\\n    for (i = 0; i < 7; i++) {\\n        out[i] = get$1(format, (i + shift) % 7, field, 'day');\\n    }\\n    return out;\\n}\\n\\nfunction listMonths (format, index) {\\n    return listMonthsImpl(format, index, 'months');\\n}\\n\\nfunction listMonthsShort (format, index) {\\n    return listMonthsImpl(format, index, 'monthsShort');\\n}\\n\\nfunction listWeekdays (localeSorted, format, index) {\\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\\n}\\n\\nfunction listWeekdaysShort (localeSorted, format, index) {\\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\\n}\\n\\nfunction listWeekdaysMin (localeSorted, format, index) {\\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\\n}\\n\\ngetSetGlobalLocale('en', {\\n    ordinalParse: /\\\\d{1,2}(th|st|nd|rd)/,\\n    ordinal : function (number) {\\n        var b = number % 10,\\n            output = (toInt(number % 100 / 10) === 1) ? 'th' :\\n            (b === 1) ? 'st' :\\n            (b === 2) ? 'nd' :\\n            (b === 3) ? 'rd' : 'th';\\n        return number + output;\\n    }\\n});\\n\\n// Side effect imports\\nhooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\\nhooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\\n\\nvar mathAbs = Math.abs;\\n\\nfunction abs () {\\n    var data           = this._data;\\n\\n    this._milliseconds = mathAbs(this._milliseconds);\\n    this._days         = mathAbs(this._days);\\n    this._months       = mathAbs(this._months);\\n\\n    data.milliseconds  = mathAbs(data.milliseconds);\\n    data.seconds       = mathAbs(data.seconds);\\n    data.minutes       = mathAbs(data.minutes);\\n    data.hours         = mathAbs(data.hours);\\n    data.months        = mathAbs(data.months);\\n    data.years         = mathAbs(data.years);\\n\\n    return this;\\n}\\n\\nfunction addSubtract$1 (duration, input, value, direction) {\\n    var other = createDuration(input, value);\\n\\n    duration._milliseconds += direction * other._milliseconds;\\n    duration._days         += direction * other._days;\\n    duration._months       += direction * other._months;\\n\\n    return duration._bubble();\\n}\\n\\n// supports only 2.0-style add(1, 's') or add(duration)\\nfunction add$1 (input, value) {\\n    return addSubtract$1(this, input, value, 1);\\n}\\n\\n// supports only 2.0-style subtract(1, 's') or subtract(duration)\\nfunction subtract$1 (input, value) {\\n    return addSubtract$1(this, input, value, -1);\\n}\\n\\nfunction absCeil (number) {\\n    if (number < 0) {\\n        return Math.floor(number);\\n    } else {\\n        return Math.ceil(number);\\n    }\\n}\\n\\nfunction bubble () {\\n    var milliseconds = this._milliseconds;\\n    var days         = this._days;\\n    var months       = this._months;\\n    var data         = this._data;\\n    var seconds, minutes, hours, years, monthsFromDays;\\n\\n    // if we have a mix of positive and negative values, bubble down first\\n    // check: https://github.com/moment/moment/issues/2166\\n    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\\n            (milliseconds <= 0 && days <= 0 && months <= 0))) {\\n        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\\n        days = 0;\\n        months = 0;\\n    }\\n\\n    // The following code bubbles up values, see the tests for\\n    // examples of what that means.\\n    data.milliseconds = milliseconds % 1000;\\n\\n    seconds           = absFloor(milliseconds / 1000);\\n    data.seconds      = seconds % 60;\\n\\n    minutes           = absFloor(seconds / 60);\\n    data.minutes      = minutes % 60;\\n\\n    hours             = absFloor(minutes / 60);\\n    data.hours        = hours % 24;\\n\\n    days += absFloor(hours / 24);\\n\\n    // convert days to months\\n    monthsFromDays = absFloor(daysToMonths(days));\\n    months += monthsFromDays;\\n    days -= absCeil(monthsToDays(monthsFromDays));\\n\\n    // 12 months -> 1 year\\n    years = absFloor(months / 12);\\n    months %= 12;\\n\\n    data.days   = days;\\n    data.months = months;\\n    data.years  = years;\\n\\n    return this;\\n}\\n\\nfunction daysToMonths (days) {\\n    // 400 years have 146097 days (taking into account leap year rules)\\n    // 400 years have 12 months === 4800\\n    return days * 4800 / 146097;\\n}\\n\\nfunction monthsToDays (months) {\\n    // the reverse of daysToMonths\\n    return months * 146097 / 4800;\\n}\\n\\nfunction as (units) {\\n    var days;\\n    var months;\\n    var milliseconds = this._milliseconds;\\n\\n    units = normalizeUnits(units);\\n\\n    if (units === 'month' || units === 'year') {\\n        days   = this._days   + milliseconds / 864e5;\\n        months = this._months + daysToMonths(days);\\n        return units === 'month' ? months : months / 12;\\n    } else {\\n        // handle milliseconds separately because of floating point math errors (issue #1867)\\n        days = this._days + Math.round(monthsToDays(this._months));\\n        switch (units) {\\n            case 'week'   : return days / 7     + milliseconds / 6048e5;\\n            case 'day'    : return days         + milliseconds / 864e5;\\n            case 'hour'   : return days * 24    + milliseconds / 36e5;\\n            case 'minute' : return days * 1440  + milliseconds / 6e4;\\n            case 'second' : return days * 86400 + milliseconds / 1000;\\n            // Math.floor prevents floating point math errors here\\n            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\\n            default: throw new Error('Unknown unit ' + units);\\n        }\\n    }\\n}\\n\\n// TODO: Use this.as('ms')?\\nfunction valueOf$1 () {\\n    return (\\n        this._milliseconds +\\n        this._days * 864e5 +\\n        (this._months % 12) * 2592e6 +\\n        toInt(this._months / 12) * 31536e6\\n    );\\n}\\n\\nfunction makeAs (alias) {\\n    return function () {\\n        return this.as(alias);\\n    };\\n}\\n\\nvar asMilliseconds = makeAs('ms');\\nvar asSeconds      = makeAs('s');\\nvar asMinutes      = makeAs('m');\\nvar asHours        = makeAs('h');\\nvar asDays         = makeAs('d');\\nvar asWeeks        = makeAs('w');\\nvar asMonths       = makeAs('M');\\nvar asYears        = makeAs('y');\\n\\nfunction get$2 (units) {\\n    units = normalizeUnits(units);\\n    return this[units + 's']();\\n}\\n\\nfunction makeGetter(name) {\\n    return function () {\\n        return this._data[name];\\n    };\\n}\\n\\nvar milliseconds = makeGetter('milliseconds');\\nvar seconds      = makeGetter('seconds');\\nvar minutes      = makeGetter('minutes');\\nvar hours        = makeGetter('hours');\\nvar days         = makeGetter('days');\\nvar months       = makeGetter('months');\\nvar years        = makeGetter('years');\\n\\nfunction weeks () {\\n    return absFloor(this.days() / 7);\\n}\\n\\nvar round = Math.round;\\nvar thresholds = {\\n    s: 45,  // seconds to minute\\n    m: 45,  // minutes to hour\\n    h: 22,  // hours to day\\n    d: 26,  // days to month\\n    M: 11   // months to year\\n};\\n\\n// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\\nfunction substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\\n}\\n\\nfunction relativeTime$1 (posNegDuration, withoutSuffix, locale) {\\n    var duration = createDuration(posNegDuration).abs();\\n    var seconds  = round(duration.as('s'));\\n    var minutes  = round(duration.as('m'));\\n    var hours    = round(duration.as('h'));\\n    var days     = round(duration.as('d'));\\n    var months   = round(duration.as('M'));\\n    var years    = round(duration.as('y'));\\n\\n    var a = seconds < thresholds.s && ['s', seconds]  ||\\n            minutes <= 1           && ['m']           ||\\n            minutes < thresholds.m && ['mm', minutes] ||\\n            hours   <= 1           && ['h']           ||\\n            hours   < thresholds.h && ['hh', hours]   ||\\n            days    <= 1           && ['d']           ||\\n            days    < thresholds.d && ['dd', days]    ||\\n            months  <= 1           && ['M']           ||\\n            months  < thresholds.M && ['MM', months]  ||\\n            years   <= 1           && ['y']           || ['yy', years];\\n\\n    a[2] = withoutSuffix;\\n    a[3] = +posNegDuration > 0;\\n    a[4] = locale;\\n    return substituteTimeAgo.apply(null, a);\\n}\\n\\n// This function allows you to set the rounding function for relative time strings\\nfunction getSetRelativeTimeRounding (roundingFunction) {\\n    if (roundingFunction === undefined) {\\n        return round;\\n    }\\n    if (typeof(roundingFunction) === 'function') {\\n        round = roundingFunction;\\n        return true;\\n    }\\n    return false;\\n}\\n\\n// This function allows you to set a threshold for relative time strings\\nfunction getSetRelativeTimeThreshold (threshold, limit) {\\n    if (thresholds[threshold] === undefined) {\\n        return false;\\n    }\\n    if (limit === undefined) {\\n        return thresholds[threshold];\\n    }\\n    thresholds[threshold] = limit;\\n    return true;\\n}\\n\\nfunction humanize (withSuffix) {\\n    var locale = this.localeData();\\n    var output = relativeTime$1(this, !withSuffix, locale);\\n\\n    if (withSuffix) {\\n        output = locale.pastFuture(+this, output);\\n    }\\n\\n    return locale.postformat(output);\\n}\\n\\nvar abs$1 = Math.abs;\\n\\nfunction toISOString$1() {\\n    // for ISO strings we do not use the normal bubbling rules:\\n    //  * milliseconds bubble up until they become hours\\n    //  * days do not bubble at all\\n    //  * months bubble up until they become years\\n    // This is because there is no context-free conversion between hours and days\\n    // (think of clock changes)\\n    // and also not between days and months (28-31 days per month)\\n    var seconds = abs$1(this._milliseconds) / 1000;\\n    var days         = abs$1(this._days);\\n    var months       = abs$1(this._months);\\n    var minutes, hours, years;\\n\\n    // 3600 seconds -> 60 minutes -> 1 hour\\n    minutes           = absFloor(seconds / 60);\\n    hours             = absFloor(minutes / 60);\\n    seconds %= 60;\\n    minutes %= 60;\\n\\n    // 12 months -> 1 year\\n    years  = absFloor(months / 12);\\n    months %= 12;\\n\\n\\n    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\\n    var Y = years;\\n    var M = months;\\n    var D = days;\\n    var h = hours;\\n    var m = minutes;\\n    var s = seconds;\\n    var total = this.asSeconds();\\n\\n    if (!total) {\\n        // this is the same as C#'s (Noda) and python (isodate)...\\n        // but not other JS (goog.date)\\n        return 'P0D';\\n    }\\n\\n    return (total < 0 ? '-' : '') +\\n        'P' +\\n        (Y ? Y + 'Y' : '') +\\n        (M ? M + 'M' : '') +\\n        (D ? D + 'D' : '') +\\n        ((h || m || s) ? 'T' : '') +\\n        (h ? h + 'H' : '') +\\n        (m ? m + 'M' : '') +\\n        (s ? s + 'S' : '');\\n}\\n\\nvar proto$2 = Duration.prototype;\\n\\nproto$2.abs            = abs;\\nproto$2.add            = add$1;\\nproto$2.subtract       = subtract$1;\\nproto$2.as             = as;\\nproto$2.asMilliseconds = asMilliseconds;\\nproto$2.asSeconds      = asSeconds;\\nproto$2.asMinutes      = asMinutes;\\nproto$2.asHours        = asHours;\\nproto$2.asDays         = asDays;\\nproto$2.asWeeks        = asWeeks;\\nproto$2.asMonths       = asMonths;\\nproto$2.asYears        = asYears;\\nproto$2.valueOf        = valueOf$1;\\nproto$2._bubble        = bubble;\\nproto$2.get            = get$2;\\nproto$2.milliseconds   = milliseconds;\\nproto$2.seconds        = seconds;\\nproto$2.minutes        = minutes;\\nproto$2.hours          = hours;\\nproto$2.days           = days;\\nproto$2.weeks          = weeks;\\nproto$2.months         = months;\\nproto$2.years          = years;\\nproto$2.humanize       = humanize;\\nproto$2.toISOString    = toISOString$1;\\nproto$2.toString       = toISOString$1;\\nproto$2.toJSON         = toISOString$1;\\nproto$2.locale         = locale;\\nproto$2.localeData     = localeData;\\n\\n// Deprecations\\nproto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\\nproto$2.lang = lang;\\n\\n// Side effect imports\\n\\n// FORMATTING\\n\\naddFormatToken('X', 0, 0, 'unix');\\naddFormatToken('x', 0, 0, 'valueOf');\\n\\n// PARSING\\n\\naddRegexToken('x', matchSigned);\\naddRegexToken('X', matchTimestamp);\\naddParseToken('X', function (input, array, config) {\\n    config._d = new Date(parseFloat(input, 10) * 1000);\\n});\\naddParseToken('x', function (input, array, config) {\\n    config._d = new Date(toInt(input));\\n});\\n\\n// Side effect imports\\n\\n\\nhooks.version = '2.17.1';\\n\\nsetHookCallback(createLocal);\\n\\nhooks.fn                    = proto;\\nhooks.min                   = min;\\nhooks.max                   = max;\\nhooks.now                   = now;\\nhooks.utc                   = createUTC;\\nhooks.unix                  = createUnix;\\nhooks.months                = listMonths;\\nhooks.isDate                = isDate;\\nhooks.locale                = getSetGlobalLocale;\\nhooks.invalid               = createInvalid;\\nhooks.duration              = createDuration;\\nhooks.isMoment              = isMoment;\\nhooks.weekdays              = listWeekdays;\\nhooks.parseZone             = createInZone;\\nhooks.localeData            = getLocale;\\nhooks.isDuration            = isDuration;\\nhooks.monthsShort           = listMonthsShort;\\nhooks.weekdaysMin           = listWeekdaysMin;\\nhooks.defineLocale          = defineLocale;\\nhooks.updateLocale          = updateLocale;\\nhooks.locales               = listLocales;\\nhooks.weekdaysShort         = listWeekdaysShort;\\nhooks.normalizeUnits        = normalizeUnits;\\nhooks.relativeTimeRounding = getSetRelativeTimeRounding;\\nhooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\\nhooks.calendarFormat        = getCalendarFormat;\\nhooks.prototype             = proto;\\n\\nreturn hooks;\\n\\n})));\\n\\n},{}],7:[function(require,module,exports){\\n/**\\n * @namespace Chart\\n */\\nvar Chart = require(28)();\\n\\nrequire(26)(Chart);\\nrequire(42)(Chart);\\nrequire(22)(Chart);\\nrequire(31)(Chart);\\nrequire(25)(Chart);\\nrequire(21)(Chart);\\nrequire(23)(Chart);\\nrequire(24)(Chart);\\nrequire(29)(Chart);\\nrequire(33)(Chart);\\nrequire(34)(Chart);\\nrequire(32)(Chart);\\nrequire(35)(Chart);\\nrequire(30)(Chart);\\nrequire(27)(Chart);\\nrequire(36)(Chart);\\n\\nrequire(37)(Chart);\\nrequire(38)(Chart);\\nrequire(39)(Chart);\\nrequire(40)(Chart);\\n\\nrequire(45)(Chart);\\nrequire(43)(Chart);\\nrequire(44)(Chart);\\nrequire(46)(Chart);\\nrequire(47)(Chart);\\nrequire(48)(Chart);\\n\\n// Controllers must be loaded after elements\\n// See Chart.core.datasetController.dataElementType\\nrequire(15)(Chart);\\nrequire(16)(Chart);\\nrequire(17)(Chart);\\nrequire(18)(Chart);\\nrequire(19)(Chart);\\nrequire(20)(Chart);\\n\\nrequire(8)(Chart);\\nrequire(9)(Chart);\\nrequire(10)(Chart);\\nrequire(11)(Chart);\\nrequire(12)(Chart);\\nrequire(13)(Chart);\\nrequire(14)(Chart);\\n\\nwindow.Chart = module.exports = Chart;\\n\\n},{\\\"10\\\":10,\\\"11\\\":11,\\\"12\\\":12,\\\"13\\\":13,\\\"14\\\":14,\\\"15\\\":15,\\\"16\\\":16,\\\"17\\\":17,\\\"18\\\":18,\\\"19\\\":19,\\\"20\\\":20,\\\"21\\\":21,\\\"22\\\":22,\\\"23\\\":23,\\\"24\\\":24,\\\"25\\\":25,\\\"26\\\":26,\\\"27\\\":27,\\\"28\\\":28,\\\"29\\\":29,\\\"30\\\":30,\\\"31\\\":31,\\\"32\\\":32,\\\"33\\\":33,\\\"34\\\":34,\\\"35\\\":35,\\\"36\\\":36,\\\"37\\\":37,\\\"38\\\":38,\\\"39\\\":39,\\\"40\\\":40,\\\"42\\\":42,\\\"43\\\":43,\\\"44\\\":44,\\\"45\\\":45,\\\"46\\\":46,\\\"47\\\":47,\\\"48\\\":48,\\\"8\\\":8,\\\"9\\\":9}],8:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Bar = function(context, config) {\\n\\t\\tconfig.type = 'bar';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],9:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Bubble = function(context, config) {\\n\\t\\tconfig.type = 'bubble';\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],10:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Doughnut = function(context, config) {\\n\\t\\tconfig.type = 'doughnut';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],11:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Line = function(context, config) {\\n\\t\\tconfig.type = 'line';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],12:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.PolarArea = function(context, config) {\\n\\t\\tconfig.type = 'polarArea';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],13:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tChart.Radar = function(context, config) {\\n\\t\\tconfig.type = 'radar';\\n\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],14:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar defaultConfig = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'linear', // scatter should not use a category axis\\n\\t\\t\\t\\tposition: 'bottom',\\n\\t\\t\\t\\tid: 'x-axis-1' // need an ID so datasets can reference the scale\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tposition: 'left',\\n\\t\\t\\t\\tid: 'y-axis-1'\\n\\t\\t\\t}]\\n\\t\\t},\\n\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\t// Title doesn't make sense for scatter since we format the data as a point\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem) {\\n\\t\\t\\t\\t\\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t// Register the default config for this type\\n\\tChart.defaults.scatter = defaultConfig;\\n\\n\\t// Scatter charts use line controllers\\n\\tChart.controllers.scatter = Chart.controllers.line;\\n\\n\\tChart.Scatter = function(context, config) {\\n\\t\\tconfig.type = 'scatter';\\n\\t\\treturn new Chart(context, config);\\n\\t};\\n\\n};\\n\\n},{}],15:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.bar = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'label'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'category',\\n\\n\\t\\t\\t\\t// Specific to Bar Controller\\n\\t\\t\\t\\tcategoryPercentage: 0.8,\\n\\t\\t\\t\\tbarPercentage: 0.9,\\n\\n\\t\\t\\t\\t// grid line settings\\n\\t\\t\\t\\tgridLines: {\\n\\t\\t\\t\\t\\toffsetGridLines: true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear'\\n\\t\\t\\t}]\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.bar = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Rectangle,\\n\\n\\t\\tinitialize: function(chart, datasetIndex) {\\n\\t\\t\\tChart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\\n\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\n\\t\\t\\tmeta.stack = dataset.stack;\\n\\t\\t\\t// Use this to indicate that this is a bar dataset.\\n\\t\\t\\tmeta.bar = true;\\n\\t\\t},\\n\\n\\t\\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackCount: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\n\\t\\t\\tvar stacks = [];\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&\\n\\t\\t\\t\\t\\t(yScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\treturn stacks.length;\\n\\t\\t},\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\thelpers.each(me.getMeta().data, function(rectangle, index) {\\n\\t\\t\\t\\tme.updateElement(rectangle, index, reset);\\n\\t\\t\\t}, me);\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(rectangle, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar scaleBase = yScale.getBasePixel();\\n\\t\\t\\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\n\\t\\t\\trectangle._xScale = xScale;\\n\\t\\t\\trectangle._yScale = yScale;\\n\\t\\t\\trectangle._datasetIndex = me.index;\\n\\t\\t\\trectangle._index = index;\\n\\n\\t\\t\\tvar ruler = me.getRuler(index); // The index argument for compatible\\n\\t\\t\\trectangle._model = {\\n\\t\\t\\t\\tx: me.calculateBarX(index, me.index, ruler),\\n\\t\\t\\t\\ty: reset ? scaleBase : me.calculateBarY(index, me.index),\\n\\n\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\tlabel: me.chart.data.labels[index],\\n\\t\\t\\t\\tdatasetLabel: dataset.label,\\n\\n\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\thorizontal: false,\\n\\t\\t\\t\\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\\n\\t\\t\\t\\twidth: me.calculateBarWidth(ruler),\\n\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\\n\\t\\t\\t\\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\\n\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\\n\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\\n\\t\\t\\t};\\n\\n\\t\\t\\trectangle.pivot();\\n\\t\\t},\\n\\n\\t\\tcalculateBarBase: function(datasetIndex, index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar base = yScale.getBaseValue();\\n\\t\\t\\tvar original = base;\\n\\n\\t\\t\\tif ((yScale.options.stacked === true) ||\\n\\t\\t\\t\\t(yScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\t\\tvar datasets = chart.data.datasets;\\n\\t\\t\\t\\tvar value = Number(datasets[datasetIndex].data[index]);\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar currentDs = datasets[i];\\n\\t\\t\\t\\t\\tvar currentDsMeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === currentDsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar currentVal = Number(currentDs.data[index]);\\n\\t\\t\\t\\t\\t\\tbase += value < 0 ? Math.min(currentVal, original) : Math.max(currentVal, original);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn yScale.getPixelForValue(base);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getBasePixel();\\n\\t\\t},\\n\\n\\t\\tgetRuler: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar stackCount = me.getStackCount();\\n\\n\\t\\t\\tvar tickWidth = xScale.width / xScale.ticks.length;\\n\\t\\t\\tvar categoryWidth = tickWidth * xScale.options.categoryPercentage;\\n\\t\\t\\tvar categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;\\n\\t\\t\\tvar fullBarWidth = categoryWidth / stackCount;\\n\\n\\t\\t\\tvar barWidth = fullBarWidth * xScale.options.barPercentage;\\n\\t\\t\\tvar barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstackCount: stackCount,\\n\\t\\t\\t\\ttickWidth: tickWidth,\\n\\t\\t\\t\\tcategoryWidth: categoryWidth,\\n\\t\\t\\t\\tcategorySpacing: categorySpacing,\\n\\t\\t\\t\\tfullBarWidth: fullBarWidth,\\n\\t\\t\\t\\tbarWidth: barWidth,\\n\\t\\t\\t\\tbarSpacing: barSpacing\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tcalculateBarWidth: function(ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tif (xScale.options.barThickness) {\\n\\t\\t\\t\\treturn xScale.options.barThickness;\\n\\t\\t\\t}\\n\\t\\t\\treturn ruler.barWidth;\\n\\t\\t},\\n\\n\\t\\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackIndex: function(datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar dsMeta, j;\\n\\t\\t\\tvar stacks = [meta.stack];\\n\\n\\t\\t\\tfor (j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tdsMeta = this.chart.getDatasetMeta(j);\\n\\t\\t\\t\\tif (dsMeta.bar && this.chart.isDatasetVisible(j) &&\\n\\t\\t\\t\\t\\t(yScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stacks.length - 1;\\n\\t\\t},\\n\\n\\t\\tcalculateBarX: function(index, datasetIndex, ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar stackIndex = me.getStackIndex(datasetIndex);\\n\\t\\t\\tvar leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\\n\\t\\t\\tleftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;\\n\\n\\t\\t\\treturn leftTick +\\n\\t\\t\\t\\t(ruler.barWidth / 2) +\\n\\t\\t\\t\\truler.categorySpacing +\\n\\t\\t\\t\\t(ruler.barWidth * stackIndex) +\\n\\t\\t\\t\\t(ruler.barSpacing / 2) +\\n\\t\\t\\t\\t(ruler.barSpacing * stackIndex);\\n\\t\\t},\\n\\n\\t\\tcalculateBarY: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar value = Number(me.getDataset().data[index]);\\n\\n\\t\\t\\tif (yScale.options.stacked ||\\n\\t\\t\\t\\t(yScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar base = yScale.getBaseValue();\\n\\t\\t\\t\\tvar sumPos = base,\\n\\t\\t\\t\\t\\tsumNeg = base;\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar ds = me.chart.data.datasets[i];\\n\\t\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === dsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar stackedVal = Number(ds.data[index]);\\n\\t\\t\\t\\t\\t\\tif (stackedVal < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (value < 0) {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumNeg + value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn yScale.getPixelForValue(sumPos + value);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\tvar metaData = me.getMeta().data;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar i, len;\\n\\n\\t\\t\\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\\n\\t\\t\\tfor (i = 0, len = metaData.length; i < len; ++i) {\\n\\t\\t\\t\\tvar d = dataset.data[i];\\n\\t\\t\\t\\tif (d !== null && d !== undefined && !isNaN(d)) {\\n\\t\\t\\t\\t\\tmetaData[i].transition(easingDecimal).draw();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(rectangle) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\\n\\t\\t\\tvar index = rectangle._index;\\n\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar model = rectangle._model;\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(rectangle) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\\n\\t\\t\\tvar index = rectangle._index;\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar model = rectangle._model;\\n\\t\\t\\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\\n\\n\\t\\t\\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\\n\\t\\t\\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\\n\\t\\t\\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\\n\\t\\t}\\n\\n\\t});\\n\\n\\n\\t// including horizontalBar in the bar file, instead of a file of its own\\n\\t// it extends bar (like pie extends doughnut)\\n\\tChart.defaults.horizontalBar = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'label'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tposition: 'bottom'\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\tposition: 'left',\\n\\t\\t\\t\\ttype: 'category',\\n\\n\\t\\t\\t\\t// Specific to Horizontal Bar Controller\\n\\t\\t\\t\\tcategoryPercentage: 0.8,\\n\\t\\t\\t\\tbarPercentage: 0.9,\\n\\n\\t\\t\\t\\t// grid line settings\\n\\t\\t\\t\\tgridLines: {\\n\\t\\t\\t\\t\\toffsetGridLines: true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}]\\n\\t\\t},\\n\\t\\telements: {\\n\\t\\t\\trectangle: {\\n\\t\\t\\t\\tborderSkipped: 'left'\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function(tooltipItems, data) {\\n\\t\\t\\t\\t\\t// Pick first xLabel for now\\n\\t\\t\\t\\t\\tvar title = '';\\n\\n\\t\\t\\t\\t\\tif (tooltipItems.length > 0) {\\n\\t\\t\\t\\t\\t\\tif (tooltipItems[0].yLabel) {\\n\\t\\t\\t\\t\\t\\t\\ttitle = tooltipItems[0].yLabel;\\n\\t\\t\\t\\t\\t\\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\\n\\t\\t\\t\\t\\t\\t\\ttitle = data.labels[tooltipItems[0].index];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn title;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\\n\\t\\t\\t\\t\\treturn datasetLabel + ': ' + tooltipItem.xLabel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\\n\\n\\t\\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackCount: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\n\\t\\t\\tvar stacks = [];\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&\\n\\t\\t\\t\\t\\t(xScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\treturn stacks.length;\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(rectangle, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar scaleBase = xScale.getBasePixel();\\n\\t\\t\\tvar custom = rectangle.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\\n\\n\\t\\t\\trectangle._xScale = xScale;\\n\\t\\t\\trectangle._yScale = yScale;\\n\\t\\t\\trectangle._datasetIndex = me.index;\\n\\t\\t\\trectangle._index = index;\\n\\n\\t\\t\\tvar ruler = me.getRuler(index); // The index argument for compatible\\n\\t\\t\\trectangle._model = {\\n\\t\\t\\t\\tx: reset ? scaleBase : me.calculateBarX(index, me.index),\\n\\t\\t\\t\\ty: me.calculateBarY(index, me.index, ruler),\\n\\n\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\tlabel: me.chart.data.labels[index],\\n\\t\\t\\t\\tdatasetLabel: dataset.label,\\n\\n\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\thorizontal: true,\\n\\t\\t\\t\\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\\n\\t\\t\\t\\theight: me.calculateBarHeight(ruler),\\n\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\\n\\t\\t\\t\\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\\n\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\\n\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\\n\\t\\t\\t};\\n\\n\\t\\t\\trectangle.pivot();\\n\\t\\t},\\n\\n\\t\\tcalculateBarBase: function(datasetIndex, index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar base = xScale.getBaseValue();\\n\\t\\t\\tvar originalBase = base;\\n\\n\\t\\t\\tif (xScale.options.stacked ||\\n\\t\\t\\t\\t(xScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\t\\tvar datasets = chart.data.datasets;\\n\\t\\t\\t\\tvar value = Number(datasets[datasetIndex].data[index]);\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar currentDs = datasets[i];\\n\\t\\t\\t\\t\\tvar currentDsMeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === currentDsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar currentVal = Number(currentDs.data[index]);\\n\\t\\t\\t\\t\\t\\tbase += value < 0 ? Math.min(currentVal, originalBase) : Math.max(currentVal, originalBase);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn xScale.getPixelForValue(base);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn xScale.getBasePixel();\\n\\t\\t},\\n\\n\\t\\tgetRuler: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar stackCount = me.getStackCount();\\n\\n\\t\\t\\tvar tickHeight = yScale.height / yScale.ticks.length;\\n\\t\\t\\tvar categoryHeight = tickHeight * yScale.options.categoryPercentage;\\n\\t\\t\\tvar categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;\\n\\t\\t\\tvar fullBarHeight = categoryHeight / stackCount;\\n\\n\\t\\t\\tvar barHeight = fullBarHeight * yScale.options.barPercentage;\\n\\t\\t\\tvar barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstackCount: stackCount,\\n\\t\\t\\t\\ttickHeight: tickHeight,\\n\\t\\t\\t\\tcategoryHeight: categoryHeight,\\n\\t\\t\\t\\tcategorySpacing: categorySpacing,\\n\\t\\t\\t\\tfullBarHeight: fullBarHeight,\\n\\t\\t\\t\\tbarHeight: barHeight,\\n\\t\\t\\t\\tbarSpacing: barSpacing\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tcalculateBarHeight: function(ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tif (yScale.options.barThickness) {\\n\\t\\t\\t\\treturn yScale.options.barThickness;\\n\\t\\t\\t}\\n\\t\\t\\treturn ruler.barHeight;\\n\\t\\t},\\n\\n\\t\\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\\n\\t\\tgetStackIndex: function(datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar dsMeta, j;\\n\\t\\t\\tvar stacks = [meta.stack];\\n\\n\\t\\t\\tfor (j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tdsMeta = this.chart.getDatasetMeta(j);\\n\\t\\t\\t\\tif (dsMeta.bar && this.chart.isDatasetVisible(j) &&\\n\\t\\t\\t\\t\\t(xScale.options.stacked === false ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\\n\\t\\t\\t\\t\\t(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\\n\\t\\t\\t\\t\\tstacks.push(dsMeta.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn stacks.length - 1;\\n\\t\\t},\\n\\n\\t\\tcalculateBarX: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar value = Number(me.getDataset().data[index]);\\n\\n\\t\\t\\tif (xScale.options.stacked ||\\n\\t\\t\\t\\t(xScale.options.stacked === undefined && meta.stack !== undefined)) {\\n\\t\\t\\t\\tvar base = xScale.getBaseValue();\\n\\t\\t\\t\\tvar sumPos = base,\\n\\t\\t\\t\\t\\tsumNeg = base;\\n\\n\\t\\t\\t\\tfor (var i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tvar ds = me.chart.data.datasets[i];\\n\\t\\t\\t\\t\\tvar dsMeta = me.chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack === dsMeta.stack) {\\n\\t\\t\\t\\t\\t\\tvar stackedVal = Number(ds.data[index]);\\n\\t\\t\\t\\t\\t\\tif (stackedVal < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += stackedVal || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (value < 0) {\\n\\t\\t\\t\\t\\treturn xScale.getPixelForValue(sumNeg + value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn xScale.getPixelForValue(sumPos + value);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn xScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tcalculateBarY: function(index, datasetIndex, ruler) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar stackIndex = me.getStackIndex(datasetIndex);\\n\\t\\t\\tvar topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\\n\\t\\t\\ttopTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;\\n\\n\\t\\t\\treturn topTick +\\n\\t\\t\\t\\t(ruler.barHeight / 2) +\\n\\t\\t\\t\\truler.categorySpacing +\\n\\t\\t\\t\\t(ruler.barHeight * stackIndex) +\\n\\t\\t\\t\\t(ruler.barSpacing / 2) +\\n\\t\\t\\t\\t(ruler.barSpacing * stackIndex);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],16:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.bubble = {\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'linear', // bubble should probably use a linear scale by default\\n\\t\\t\\t\\tposition: 'bottom',\\n\\t\\t\\t\\tid: 'x-axis-0' // need an ID so datasets can reference the scale\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tposition: 'left',\\n\\t\\t\\t\\tid: 'y-axis-0'\\n\\t\\t\\t}]\\n\\t\\t},\\n\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\t// Title doesn't make sense for scatter since we format the data as a point\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\\n\\t\\t\\t\\t\\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\\n\\t\\t\\t\\t\\treturn datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.bubble = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Point,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar points = meta.data;\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\thelpers.each(points, function(point, index) {\\n\\t\\t\\t\\tme.updateElement(point, index, reset);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar data = dataset.data[index];\\n\\t\\t\\tvar pointElementOptions = me.chart.options.elements.point;\\n\\t\\t\\tvar dsIndex = me.index;\\n\\n\\t\\t\\thelpers.extend(point, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_xScale: xScale,\\n\\t\\t\\t\\t_yScale: yScale,\\n\\t\\t\\t\\t_datasetIndex: dsIndex,\\n\\t\\t\\t\\t_index: index,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\\n\\t\\t\\t\\t\\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\\n\\n\\t\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\t\\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Trick to reset the styles of the point\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\\n\\n\\t\\t\\tvar model = point._model;\\n\\t\\t\\tmodel.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\\n\\n\\t\\t\\tpoint.pivot();\\n\\t\\t},\\n\\n\\t\\tgetRadius: function(value) {\\n\\t\\t\\treturn value.r || this.chart.options.elements.point.radius;\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tChart.DatasetController.prototype.setHoverStyle.call(me, point);\\n\\n\\t\\t\\t// Radius\\n\\t\\t\\tvar dataset = me.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\t\\t\\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\\n\\n\\t\\t\\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],17:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tdefaults = Chart.defaults;\\n\\n\\tdefaults.doughnut = {\\n\\t\\tanimation: {\\n\\t\\t\\t// Boolean - Whether we animate the rotation of the Doughnut\\n\\t\\t\\tanimateRotate: true,\\n\\t\\t\\t// Boolean - Whether we animate scaling the Doughnut from the centre\\n\\t\\t\\tanimateScale: false\\n\\t\\t},\\n\\t\\taspectRatio: 1,\\n\\t\\thover: {\\n\\t\\t\\tmode: 'single'\\n\\t\\t},\\n\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\tvar text = [];\\n\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar labels = data.labels;\\n\\n\\t\\t\\tif (datasets.length) {\\n\\t\\t\\t\\tfor (var i = 0; i < datasets[0].data.length; ++i) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + datasets[0].backgroundColor[i] + '\\\"></span>');\\n\\t\\t\\t\\t\\tif (labels[i]) {\\n\\t\\t\\t\\t\\t\\ttext.push(labels[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttext.push('</ul>');\\n\\t\\t\\treturn text.join('');\\n\\t\\t},\\n\\t\\tlegend: {\\n\\t\\t\\tlabels: {\\n\\t\\t\\t\\tgenerateLabels: function(chart) {\\n\\t\\t\\t\\t\\tvar data = chart.data;\\n\\t\\t\\t\\t\\tif (data.labels.length && data.datasets.length) {\\n\\t\\t\\t\\t\\t\\treturn data.labels.map(function(label, i) {\\n\\t\\t\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(0);\\n\\t\\t\\t\\t\\t\\t\\tvar ds = data.datasets[0];\\n\\t\\t\\t\\t\\t\\t\\tvar arc = meta.data[i];\\n\\t\\t\\t\\t\\t\\t\\tvar custom = arc && arc.custom || {};\\n\\t\\t\\t\\t\\t\\t\\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\t\\t\\t\\t\\t\\t\\tvar arcOpts = chart.options.elements.arc;\\n\\t\\t\\t\\t\\t\\t\\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\\n\\t\\t\\t\\t\\t\\t\\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\\n\\t\\t\\t\\t\\t\\t\\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\\n\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\ttext: label,\\n\\t\\t\\t\\t\\t\\t\\t\\tfillStyle: fill,\\n\\t\\t\\t\\t\\t\\t\\t\\tstrokeStyle: stroke,\\n\\t\\t\\t\\t\\t\\t\\t\\tlineWidth: bw,\\n\\t\\t\\t\\t\\t\\t\\t\\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Extra data used for toggling the correct item\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\t\\tvar index = legendItem.index;\\n\\t\\t\\t\\tvar chart = this.chart;\\n\\t\\t\\t\\tvar i, ilen, meta;\\n\\n\\t\\t\\t\\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tmeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\t// toggle visibility of index if exists\\n\\t\\t\\t\\t\\tif (meta.data[index]) {\\n\\t\\t\\t\\t\\t\\tmeta.data[index].hidden = !meta.data[index].hidden;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tchart.update();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// The percentage of the chart that we cut out of the middle.\\n\\t\\tcutoutPercentage: 50,\\n\\n\\t\\t// The rotation of the chart, where the first data arc begins.\\n\\t\\trotation: Math.PI * -0.5,\\n\\n\\t\\t// The total circumference of the chart.\\n\\t\\tcircumference: Math.PI * 2.0,\\n\\n\\t\\t// Need to override these to give a nice default\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\tvar dataLabel = data.labels[tooltipItem.index];\\n\\t\\t\\t\\t\\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\\n\\n\\t\\t\\t\\t\\tif (helpers.isArray(dataLabel)) {\\n\\t\\t\\t\\t\\t\\t// show value on first line of multiline label\\n\\t\\t\\t\\t\\t\\t// need to clone because we are changing the value\\n\\t\\t\\t\\t\\t\\tdataLabel = dataLabel.slice();\\n\\t\\t\\t\\t\\t\\tdataLabel[0] += value;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tdataLabel += value;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn dataLabel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tdefaults.pie = helpers.clone(defaults.doughnut);\\n\\thelpers.extend(defaults.pie, {\\n\\t\\tcutoutPercentage: 0\\n\\t});\\n\\n\\n\\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Arc,\\n\\n\\t\\tlinkScales: helpers.noop,\\n\\n\\t\\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\\n\\t\\tgetRingIndex: function(datasetIndex) {\\n\\t\\t\\tvar ringIndex = 0;\\n\\n\\t\\t\\tfor (var j = 0; j < datasetIndex; ++j) {\\n\\t\\t\\t\\tif (this.chart.isDatasetVisible(j)) {\\n\\t\\t\\t\\t\\t++ringIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ringIndex;\\n\\t\\t},\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart,\\n\\t\\t\\t\\tchartArea = chart.chartArea,\\n\\t\\t\\t\\topts = chart.options,\\n\\t\\t\\t\\tarcOpts = opts.elements.arc,\\n\\t\\t\\t\\tavailableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\\n\\t\\t\\t\\tavailableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\\n\\t\\t\\t\\tminSize = Math.min(availableWidth, availableHeight),\\n\\t\\t\\t\\toffset = {\\n\\t\\t\\t\\t\\tx: 0,\\n\\t\\t\\t\\t\\ty: 0\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tmeta = me.getMeta(),\\n\\t\\t\\t\\tcutoutPercentage = opts.cutoutPercentage,\\n\\t\\t\\t\\tcircumference = opts.circumference;\\n\\n\\t\\t\\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\\n\\t\\t\\tif (circumference < Math.PI * 2.0) {\\n\\t\\t\\t\\tvar startAngle = opts.rotation % (Math.PI * 2.0);\\n\\t\\t\\t\\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\\n\\t\\t\\t\\tvar endAngle = startAngle + circumference;\\n\\t\\t\\t\\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\\n\\t\\t\\t\\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\\n\\t\\t\\t\\tvar contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\\n\\t\\t\\t\\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\\n\\t\\t\\t\\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\\n\\t\\t\\t\\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\\n\\t\\t\\t\\tvar cutout = cutoutPercentage / 100.0;\\n\\t\\t\\t\\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\\n\\t\\t\\t\\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\\n\\t\\t\\t\\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\\n\\t\\t\\t\\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\\n\\t\\t\\t\\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\\n\\t\\t\\t}\\n\\n\\t\\t\\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\\n\\t\\t\\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\\n\\t\\t\\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\\n\\t\\t\\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\\n\\t\\t\\tchart.offsetX = offset.x * chart.outerRadius;\\n\\t\\t\\tchart.offsetY = offset.y * chart.outerRadius;\\n\\n\\t\\t\\tmeta.total = me.calculateTotal();\\n\\n\\t\\t\\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\\n\\t\\t\\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\\n\\n\\t\\t\\thelpers.each(meta.data, function(arc, index) {\\n\\t\\t\\t\\tme.updateElement(arc, index, reset);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(arc, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart,\\n\\t\\t\\t\\tchartArea = chart.chartArea,\\n\\t\\t\\t\\topts = chart.options,\\n\\t\\t\\t\\tanimationOpts = opts.animation,\\n\\t\\t\\t\\tcenterX = (chartArea.left + chartArea.right) / 2,\\n\\t\\t\\t\\tcenterY = (chartArea.top + chartArea.bottom) / 2,\\n\\t\\t\\t\\tstartAngle = opts.rotation, // non reset case handled later\\n\\t\\t\\t\\tendAngle = opts.rotation, // non reset case handled later\\n\\t\\t\\t\\tdataset = me.getDataset(),\\n\\t\\t\\t\\tcircumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\\n\\t\\t\\t\\tinnerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\\n\\t\\t\\t\\touterRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\\n\\t\\t\\t\\tvalueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\n\\t\\t\\thelpers.extend(arc, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: centerX + chart.offsetX,\\n\\t\\t\\t\\t\\ty: centerY + chart.offsetY,\\n\\t\\t\\t\\t\\tstartAngle: startAngle,\\n\\t\\t\\t\\t\\tendAngle: endAngle,\\n\\t\\t\\t\\t\\tcircumference: circumference,\\n\\t\\t\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\t\\t\\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tvar model = arc._model;\\n\\t\\t\\t// Resets the visual styles\\n\\t\\t\\tthis.removeHoverStyle(arc);\\n\\n\\t\\t\\t// Set correct angles if not resetting\\n\\t\\t\\tif (!reset || !animationOpts.animateRotate) {\\n\\t\\t\\t\\tif (index === 0) {\\n\\t\\t\\t\\t\\tmodel.startAngle = opts.rotation;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmodel.endAngle = model.startAngle + model.circumference;\\n\\t\\t\\t}\\n\\n\\t\\t\\tarc.pivot();\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(arc) {\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\\n\\t\\t},\\n\\n\\t\\tcalculateTotal: function() {\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar meta = this.getMeta();\\n\\t\\t\\tvar total = 0;\\n\\t\\t\\tvar value;\\n\\n\\t\\t\\thelpers.each(meta.data, function(element, index) {\\n\\t\\t\\t\\tvalue = dataset.data[index];\\n\\t\\t\\t\\tif (!isNaN(value) && !element.hidden) {\\n\\t\\t\\t\\t\\ttotal += Math.abs(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t/* if (total === 0) {\\n\\t\\t\\t\\ttotal = NaN;\\n\\t\\t\\t}*/\\n\\n\\t\\t\\treturn total;\\n\\t\\t},\\n\\n\\t\\tcalculateCircumference: function(value) {\\n\\t\\t\\tvar total = this.getMeta().total;\\n\\t\\t\\tif (total > 0 && !isNaN(value)) {\\n\\t\\t\\t\\treturn (Math.PI * 2.0) * (value / total);\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t},\\n\\n\\t\\t// gets the max border or hover width to properly scale pie charts\\n\\t\\tgetMaxBorderWidth: function(elements) {\\n\\t\\t\\tvar max = 0,\\n\\t\\t\\t\\tindex = this.index,\\n\\t\\t\\t\\tlength = elements.length,\\n\\t\\t\\t\\tborderWidth,\\n\\t\\t\\t\\thoverWidth;\\n\\n\\t\\t\\tfor (var i = 0; i < length; i++) {\\n\\t\\t\\t\\tborderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\\n\\t\\t\\t\\thoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\\n\\n\\t\\t\\t\\tmax = borderWidth > max ? borderWidth : max;\\n\\t\\t\\t\\tmax = hoverWidth > max ? hoverWidth : max;\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],18:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.line = {\\n\\t\\tshowLines: true,\\n\\t\\tspanGaps: false,\\n\\n\\t\\thover: {\\n\\t\\t\\tmode: 'label'\\n\\t\\t},\\n\\n\\t\\tscales: {\\n\\t\\t\\txAxes: [{\\n\\t\\t\\t\\ttype: 'category',\\n\\t\\t\\t\\tid: 'x-axis-0'\\n\\t\\t\\t}],\\n\\t\\t\\tyAxes: [{\\n\\t\\t\\t\\ttype: 'linear',\\n\\t\\t\\t\\tid: 'y-axis-0'\\n\\t\\t\\t}]\\n\\t\\t}\\n\\t};\\n\\n\\tfunction lineEnabled(dataset, options) {\\n\\t\\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);\\n\\t}\\n\\n\\tChart.controllers.line = Chart.DatasetController.extend({\\n\\n\\t\\tdatasetElementType: Chart.elements.Line,\\n\\n\\t\\tdataElementType: Chart.elements.Point,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar line = meta.dataset;\\n\\t\\t\\tvar points = meta.data || [];\\n\\t\\t\\tvar options = me.chart.options;\\n\\t\\t\\tvar lineElementOptions = options.elements.line;\\n\\t\\t\\tvar scale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar i, ilen, custom;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar showLine = lineEnabled(dataset, options);\\n\\n\\t\\t\\t// Update Line\\n\\t\\t\\tif (showLine) {\\n\\t\\t\\t\\tcustom = line.custom || {};\\n\\n\\t\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\t\\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\\n\\t\\t\\t\\t\\tdataset.lineTension = dataset.tension;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\tline._scale = scale;\\n\\t\\t\\t\\tline._datasetIndex = me.index;\\n\\t\\t\\t\\t// Data\\n\\t\\t\\t\\tline._children = points;\\n\\t\\t\\t\\t// Model\\n\\t\\t\\t\\tline._model = {\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\t// The default behavior of lines is to break at null values, according\\n\\t\\t\\t\\t\\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\\n\\t\\t\\t\\t\\t// This option gives lines the ability to span gaps\\n\\t\\t\\t\\t\\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\\n\\t\\t\\t\\t\\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\\n\\t\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\\n\\t\\t\\t\\t\\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\\n\\t\\t\\t\\t\\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\\n\\t\\t\\t\\t\\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\\n\\t\\t\\t\\t\\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\\n\\t\\t\\t\\t\\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\\n\\t\\t\\t\\t\\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\\n\\t\\t\\t\\t\\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\\n\\t\\t\\t\\t\\t// Scale\\n\\t\\t\\t\\t\\tscaleTop: scale.top,\\n\\t\\t\\t\\t\\tscaleBottom: scale.bottom,\\n\\t\\t\\t\\t\\tscaleZero: scale.getBasePixel()\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tline.pivot();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tme.updateElement(points[i], i, reset);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (showLine && line._model.tension !== 0) {\\n\\t\\t\\t\\tme.updateBezierControlPoints();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Now pivot the point for animation\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tpoints[i].pivot();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tgetPointBackgroundColor: function(point, index) {\\n\\t\\t\\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\n\\t\\t\\tif (custom.backgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = custom.backgroundColor;\\n\\t\\t\\t} else if (dataset.pointBackgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\\n\\t\\t\\t} else if (dataset.backgroundColor) {\\n\\t\\t\\t\\tbackgroundColor = dataset.backgroundColor;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn backgroundColor;\\n\\t\\t},\\n\\n\\t\\tgetPointBorderColor: function(point, index) {\\n\\t\\t\\tvar borderColor = this.chart.options.elements.point.borderColor;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\n\\t\\t\\tif (custom.borderColor) {\\n\\t\\t\\t\\tborderColor = custom.borderColor;\\n\\t\\t\\t} else if (dataset.pointBorderColor) {\\n\\t\\t\\t\\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\\n\\t\\t\\t} else if (dataset.borderColor) {\\n\\t\\t\\t\\tborderColor = dataset.borderColor;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn borderColor;\\n\\t\\t},\\n\\n\\t\\tgetPointBorderWidth: function(point, index) {\\n\\t\\t\\tvar borderWidth = this.chart.options.elements.point.borderWidth;\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\n\\t\\t\\tif (!isNaN(custom.borderWidth)) {\\n\\t\\t\\t\\tborderWidth = custom.borderWidth;\\n\\t\\t\\t} else if (!isNaN(dataset.pointBorderWidth)) {\\n\\t\\t\\t\\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\\n\\t\\t\\t} else if (!isNaN(dataset.borderWidth)) {\\n\\t\\t\\t\\tborderWidth = dataset.borderWidth;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn borderWidth;\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar datasetIndex = me.index;\\n\\t\\t\\tvar value = dataset.data[index];\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar xScale = me.getScaleForId(meta.xAxisID);\\n\\t\\t\\tvar pointOptions = me.chart.options.elements.point;\\n\\t\\t\\tvar x, y;\\n\\t\\t\\tvar labels = me.chart.data.labels || [];\\n\\t\\t\\tvar includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\\n\\n\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\\n\\t\\t\\t\\tdataset.pointRadius = dataset.radius;\\n\\t\\t\\t}\\n\\t\\t\\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\\n\\t\\t\\t\\tdataset.pointHitRadius = dataset.hitRadius;\\n\\t\\t\\t}\\n\\n\\t\\t\\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\\n\\t\\t\\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\\n\\n\\t\\t\\t// Utility\\n\\t\\t\\tpoint._xScale = xScale;\\n\\t\\t\\tpoint._yScale = yScale;\\n\\t\\t\\tpoint._datasetIndex = datasetIndex;\\n\\t\\t\\tpoint._index = index;\\n\\n\\t\\t\\t// Desired view properties\\n\\t\\t\\tpoint._model = {\\n\\t\\t\\t\\tx: x,\\n\\t\\t\\t\\ty: y,\\n\\t\\t\\t\\tskip: custom.skip || isNaN(x) || isNaN(y),\\n\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\\n\\t\\t\\t\\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\\n\\t\\t\\t\\tbackgroundColor: me.getPointBackgroundColor(point, index),\\n\\t\\t\\t\\tborderColor: me.getPointBorderColor(point, index),\\n\\t\\t\\t\\tborderWidth: me.getPointBorderWidth(point, index),\\n\\t\\t\\t\\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\\n\\t\\t\\t\\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\\n\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tcalculatePointY: function(value, index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar yScale = me.getScaleForId(meta.yAxisID);\\n\\t\\t\\tvar sumPos = 0;\\n\\t\\t\\tvar sumNeg = 0;\\n\\t\\t\\tvar i, ds, dsMeta;\\n\\n\\t\\t\\tif (yScale.options.stacked) {\\n\\t\\t\\t\\tfor (i = 0; i < datasetIndex; i++) {\\n\\t\\t\\t\\t\\tds = chart.data.datasets[i];\\n\\t\\t\\t\\t\\tdsMeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\\n\\t\\t\\t\\t\\t\\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\\n\\t\\t\\t\\t\\t\\tif (stackedRightValue < 0) {\\n\\t\\t\\t\\t\\t\\t\\tsumNeg += stackedRightValue || 0;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsumPos += stackedRightValue || 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar rightValue = Number(yScale.getRightValue(value));\\n\\t\\t\\t\\tif (rightValue < 0) {\\n\\t\\t\\t\\t\\treturn yScale.getPixelForValue(sumNeg + rightValue);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn yScale.getPixelForValue(sumPos + rightValue);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn yScale.getPixelForValue(value);\\n\\t\\t},\\n\\n\\t\\tupdateBezierControlPoints: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar area = me.chart.chartArea;\\n\\t\\t\\tvar points = (meta.data || []);\\n\\t\\t\\tvar i, ilen, point, model, controlPoints;\\n\\n\\t\\t\\t// Only consider points that are drawn in case the spanGaps option is used\\n\\t\\t\\tif (meta.dataset._model.spanGaps) {\\n\\t\\t\\t\\tpoints = points.filter(function(pt) {\\n\\t\\t\\t\\t\\treturn !pt._model.skip;\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction capControlPoint(pt, min, max) {\\n\\t\\t\\t\\treturn Math.max(Math.min(pt, max), min);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\\n\\t\\t\\t\\thelpers.splineCurveMonotone(points);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tpoint = points[i];\\n\\t\\t\\t\\t\\tmodel = point._model;\\n\\t\\t\\t\\t\\tcontrolPoints = helpers.splineCurve(\\n\\t\\t\\t\\t\\t\\thelpers.previousItem(points, i)._model,\\n\\t\\t\\t\\t\\t\\tmodel,\\n\\t\\t\\t\\t\\t\\thelpers.nextItem(points, i)._model,\\n\\t\\t\\t\\t\\t\\tmeta.dataset._model.tension\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousX = controlPoints.previous.x;\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousY = controlPoints.previous.y;\\n\\t\\t\\t\\t\\tmodel.controlPointNextX = controlPoints.next.x;\\n\\t\\t\\t\\t\\tmodel.controlPointNextY = controlPoints.next.y;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.chart.options.elements.line.capBezierPoints) {\\n\\t\\t\\t\\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tmodel = points[i]._model;\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\\n\\t\\t\\t\\t\\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\\n\\t\\t\\t\\t\\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\\n\\t\\t\\t\\t\\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar points = meta.data || [];\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\tvar i, ilen;\\n\\n\\t\\t\\t// Transition Point Locations\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tpoints[i].transition(easingDecimal);\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\\n\\t\\t\\t// Transition and Draw the line\\n\\t\\t\\tif (lineEnabled(me.getDataset(), me.chart.options)) {\\n\\t\\t\\t\\tmeta.dataset.transition(easingDecimal).draw();\\n\\t\\t\\t}\\n\\t\\t\\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\\n\\n\\t\\t\\t// Draw the points\\n\\t\\t\\tfor (i=0, ilen=points.length; i<ilen; ++i) {\\n\\t\\t\\t\\tpoints[i].draw(me.chart.chartArea);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\t// Point\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar dataset = me.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\\n\\t\\t\\t\\tdataset.pointRadius = dataset.radius;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\\n\\t\\t\\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\\n\\t\\t\\tmodel.borderColor = me.getPointBorderColor(point, index);\\n\\t\\t\\tmodel.borderWidth = me.getPointBorderWidth(point, index);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],19:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.polarArea = {\\n\\n\\t\\tscale: {\\n\\t\\t\\ttype: 'radialLinear',\\n\\t\\t\\tlineArc: true, // so that lines are circular\\n\\t\\t\\tticks: {\\n\\t\\t\\t\\tbeginAtZero: true\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Boolean - Whether to animate the rotation of the chart\\n\\t\\tanimation: {\\n\\t\\t\\tanimateRotate: true,\\n\\t\\t\\tanimateScale: true\\n\\t\\t},\\n\\n\\t\\tstartAngle: -0.5 * Math.PI,\\n\\t\\taspectRatio: 1,\\n\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\tvar text = [];\\n\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar labels = data.labels;\\n\\n\\t\\t\\tif (datasets.length) {\\n\\t\\t\\t\\tfor (var i = 0; i < datasets[0].data.length; ++i) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + datasets[0].backgroundColor[i] + '\\\"></span>');\\n\\t\\t\\t\\t\\tif (labels[i]) {\\n\\t\\t\\t\\t\\t\\ttext.push(labels[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttext.push('</ul>');\\n\\t\\t\\treturn text.join('');\\n\\t\\t},\\n\\t\\tlegend: {\\n\\t\\t\\tlabels: {\\n\\t\\t\\t\\tgenerateLabels: function(chart) {\\n\\t\\t\\t\\t\\tvar data = chart.data;\\n\\t\\t\\t\\t\\tif (data.labels.length && data.datasets.length) {\\n\\t\\t\\t\\t\\t\\treturn data.labels.map(function(label, i) {\\n\\t\\t\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(0);\\n\\t\\t\\t\\t\\t\\t\\tvar ds = data.datasets[0];\\n\\t\\t\\t\\t\\t\\t\\tvar arc = meta.data[i];\\n\\t\\t\\t\\t\\t\\t\\tvar custom = arc.custom || {};\\n\\t\\t\\t\\t\\t\\t\\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\t\\t\\t\\t\\t\\t\\tvar arcOpts = chart.options.elements.arc;\\n\\t\\t\\t\\t\\t\\t\\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\\n\\t\\t\\t\\t\\t\\t\\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\\n\\t\\t\\t\\t\\t\\t\\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\\n\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\ttext: label,\\n\\t\\t\\t\\t\\t\\t\\t\\tfillStyle: fill,\\n\\t\\t\\t\\t\\t\\t\\t\\tstrokeStyle: stroke,\\n\\t\\t\\t\\t\\t\\t\\t\\tlineWidth: bw,\\n\\t\\t\\t\\t\\t\\t\\t\\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Extra data used for toggling the correct item\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\t\\tvar index = legendItem.index;\\n\\t\\t\\t\\tvar chart = this.chart;\\n\\t\\t\\t\\tvar i, ilen, meta;\\n\\n\\t\\t\\t\\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\\n\\t\\t\\t\\t\\tmeta = chart.getDatasetMeta(i);\\n\\t\\t\\t\\t\\tmeta.data[index].hidden = !meta.data[index].hidden;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tchart.update();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Need to override these to give a nice default\\n\\t\\ttooltips: {\\n\\t\\t\\tcallbacks: {\\n\\t\\t\\t\\ttitle: function() {\\n\\t\\t\\t\\t\\treturn '';\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\t\\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.polarArea = Chart.DatasetController.extend({\\n\\n\\t\\tdataElementType: Chart.elements.Arc,\\n\\n\\t\\tlinkScales: helpers.noop,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar chartArea = chart.chartArea;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar opts = chart.options;\\n\\t\\t\\tvar arcOpts = opts.elements.arc;\\n\\t\\t\\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\\n\\t\\t\\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\\n\\t\\t\\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\\n\\t\\t\\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\\n\\n\\t\\t\\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\\n\\t\\t\\tme.innerRadius = me.outerRadius - chart.radiusLength;\\n\\n\\t\\t\\tmeta.count = me.countVisibleElements();\\n\\n\\t\\t\\thelpers.each(meta.data, function(arc, index) {\\n\\t\\t\\t\\tme.updateElement(arc, index, reset);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateElement: function(arc, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar opts = chart.options;\\n\\t\\t\\tvar animationOpts = opts.animation;\\n\\t\\t\\tvar scale = chart.scale;\\n\\t\\t\\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\\n\\t\\t\\tvar labels = chart.data.labels;\\n\\n\\t\\t\\tvar circumference = me.calculateCircumference(dataset.data[index]);\\n\\t\\t\\tvar centerX = scale.xCenter;\\n\\t\\t\\tvar centerY = scale.yCenter;\\n\\n\\t\\t\\t// If there is NaN data before us, we need to calculate the starting angle correctly.\\n\\t\\t\\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\\n\\t\\t\\tvar visibleCount = 0;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tfor (var i = 0; i < index; ++i) {\\n\\t\\t\\t\\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\\n\\t\\t\\t\\t\\t++visibleCount;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// var negHalfPI = -0.5 * Math.PI;\\n\\t\\t\\tvar datasetStartAngle = opts.startAngle;\\n\\t\\t\\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\\n\\t\\t\\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\\n\\t\\t\\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\\n\\n\\t\\t\\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\\n\\n\\t\\t\\thelpers.extend(arc, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index,\\n\\t\\t\\t\\t_scale: scale,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: centerX,\\n\\t\\t\\t\\t\\ty: centerY,\\n\\t\\t\\t\\t\\tinnerRadius: 0,\\n\\t\\t\\t\\t\\touterRadius: reset ? resetRadius : distance,\\n\\t\\t\\t\\t\\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\\n\\t\\t\\t\\t\\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\\n\\t\\t\\t\\t\\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Apply border and fill style\\n\\t\\t\\tme.removeHoverStyle(arc);\\n\\n\\t\\t\\tarc.pivot();\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(arc) {\\n\\t\\t\\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\\n\\t\\t},\\n\\n\\t\\tcountVisibleElements: function() {\\n\\t\\t\\tvar dataset = this.getDataset();\\n\\t\\t\\tvar meta = this.getMeta();\\n\\t\\t\\tvar count = 0;\\n\\n\\t\\t\\thelpers.each(meta.data, function(element, index) {\\n\\t\\t\\t\\tif (!isNaN(dataset.data[index]) && !element.hidden) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn count;\\n\\t\\t},\\n\\n\\t\\tcalculateCircumference: function(value) {\\n\\t\\t\\tvar count = this.getMeta().count;\\n\\t\\t\\tif (count > 0 && !isNaN(value)) {\\n\\t\\t\\t\\treturn (2 * Math.PI) / count;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],20:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.radar = {\\n\\t\\taspectRatio: 1,\\n\\t\\tscale: {\\n\\t\\t\\ttype: 'radialLinear'\\n\\t\\t},\\n\\t\\telements: {\\n\\t\\t\\tline: {\\n\\t\\t\\t\\ttension: 0 // no bezier in radar\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.controllers.radar = Chart.DatasetController.extend({\\n\\n\\t\\tdatasetElementType: Chart.elements.Line,\\n\\n\\t\\tdataElementType: Chart.elements.Point,\\n\\n\\t\\tlinkScales: helpers.noop,\\n\\n\\t\\tupdate: function(reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar line = meta.dataset;\\n\\t\\t\\tvar points = meta.data;\\n\\t\\t\\tvar custom = line.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar lineElementOptions = me.chart.options.elements.line;\\n\\t\\t\\tvar scale = me.chart.scale;\\n\\n\\t\\t\\t// Compatibility: If the properties are defined with only the old name, use those values\\n\\t\\t\\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\\n\\t\\t\\t\\tdataset.lineTension = dataset.tension;\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.extend(meta.dataset, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t// Data\\n\\t\\t\\t\\t_children: points,\\n\\t\\t\\t\\t_loop: true,\\n\\t\\t\\t\\t// Model\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\\n\\t\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\\n\\t\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\\n\\t\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\\n\\t\\t\\t\\t\\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\\n\\t\\t\\t\\t\\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\\n\\t\\t\\t\\t\\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\\n\\t\\t\\t\\t\\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\\n\\t\\t\\t\\t\\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\\n\\n\\t\\t\\t\\t\\t// Scale\\n\\t\\t\\t\\t\\tscaleTop: scale.top,\\n\\t\\t\\t\\t\\tscaleBottom: scale.bottom,\\n\\t\\t\\t\\t\\tscaleZero: scale.getBasePosition()\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tmeta.dataset.pivot();\\n\\n\\t\\t\\t// Update Points\\n\\t\\t\\thelpers.each(points, function(point, index) {\\n\\t\\t\\t\\tme.updateElement(point, index, reset);\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\t// Update bezier control points\\n\\t\\t\\tme.updateBezierControlPoints();\\n\\t\\t},\\n\\t\\tupdateElement: function(point, index, reset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar scale = me.chart.scale;\\n\\t\\t\\tvar pointElementOptions = me.chart.options.elements.point;\\n\\t\\t\\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\\n\\n\\t\\t\\thelpers.extend(point, {\\n\\t\\t\\t\\t// Utility\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index,\\n\\t\\t\\t\\t_scale: scale,\\n\\n\\t\\t\\t\\t// Desired view properties\\n\\t\\t\\t\\t_model: {\\n\\t\\t\\t\\t\\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\\n\\t\\t\\t\\t\\ty: reset ? scale.yCenter : pointPosition.y,\\n\\n\\t\\t\\t\\t\\t// Appearance\\n\\t\\t\\t\\t\\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\\n\\t\\t\\t\\t\\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\\n\\t\\t\\t\\t\\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\\n\\t\\t\\t\\t\\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\\n\\t\\t\\t\\t\\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\\n\\t\\t\\t\\t\\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\\n\\n\\t\\t\\t\\t\\t// Tooltip\\n\\t\\t\\t\\t\\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\\n\\t\\t},\\n\\t\\tupdateBezierControlPoints: function() {\\n\\t\\t\\tvar chartArea = this.chart.chartArea;\\n\\t\\t\\tvar meta = this.getMeta();\\n\\n\\t\\t\\thelpers.each(meta.data, function(point, index) {\\n\\t\\t\\t\\tvar model = point._model;\\n\\t\\t\\t\\tvar controlPoints = helpers.splineCurve(\\n\\t\\t\\t\\t\\thelpers.previousItem(meta.data, index, true)._model,\\n\\t\\t\\t\\t\\tmodel,\\n\\t\\t\\t\\t\\thelpers.nextItem(meta.data, index, true)._model,\\n\\t\\t\\t\\t\\tmodel.tension\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Prevent the bezier going outside of the bounds of the graph\\n\\t\\t\\t\\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\\n\\t\\t\\t\\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\\n\\n\\t\\t\\t\\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\\n\\t\\t\\t\\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\\n\\n\\t\\t\\t\\t// Now pivot the point for animation\\n\\t\\t\\t\\tpoint.pivot();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar meta = this.getMeta();\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\n\\t\\t\\t// Transition Point Locations\\n\\t\\t\\thelpers.each(meta.data, function(point) {\\n\\t\\t\\t\\tpoint.transition(easingDecimal);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Transition and Draw the line\\n\\t\\t\\tmeta.dataset.transition(easingDecimal).draw();\\n\\n\\t\\t\\t// Draw the points\\n\\t\\t\\thelpers.each(meta.data, function(point) {\\n\\t\\t\\t\\tpoint.draw();\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(point) {\\n\\t\\t\\t// Point\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar model = point._model;\\n\\n\\t\\t\\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(point) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[point._datasetIndex];\\n\\t\\t\\tvar custom = point.custom || {};\\n\\t\\t\\tvar index = point._index;\\n\\t\\t\\tvar model = point._model;\\n\\t\\t\\tvar pointElementOptions = this.chart.options.elements.point;\\n\\n\\t\\t\\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);\\n\\t\\t\\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\\n\\t\\t\\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\\n\\t\\t\\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],21:[function(require,module,exports){\\n/* global window: false */\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.global.animation = {\\n\\t\\tduration: 1000,\\n\\t\\teasing: 'easeOutQuart',\\n\\t\\tonProgress: helpers.noop,\\n\\t\\tonComplete: helpers.noop\\n\\t};\\n\\n\\tChart.Animation = Chart.Element.extend({\\n\\t\\tcurrentStep: null, // the current animation step\\n\\t\\tnumSteps: 60, // default number of steps\\n\\t\\teasing: '', // the easing to use for this animation\\n\\t\\trender: null, // render function used by the animation service\\n\\n\\t\\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\\n\\t\\tonAnimationComplete: null // user specified callback to fire when the animation finishes\\n\\t});\\n\\n\\tChart.animationService = {\\n\\t\\tframeDuration: 17,\\n\\t\\tanimations: [],\\n\\t\\tdropFrames: 0,\\n\\t\\trequest: null,\\n\\n\\t\\t/**\\n\\t\\t * @function Chart.animationService.addAnimation\\n\\t\\t * @param chartInstance {ChartController} the chart to animate\\n\\t\\t * @param animationObject {IAnimation} the animation that we will animate\\n\\t\\t * @param duration {Number} length of animation in ms\\n\\t\\t * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions\\n\\t\\t */\\n\\t\\taddAnimation: function(chartInstance, animationObject, duration, lazy) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (!lazy) {\\n\\t\\t\\t\\tchartInstance.animating = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (var index = 0; index < me.animations.length; ++index) {\\n\\t\\t\\t\\tif (me.animations[index].chartInstance === chartInstance) {\\n\\t\\t\\t\\t\\t// replacing an in progress animation\\n\\t\\t\\t\\t\\tme.animations[index].animationObject = animationObject;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.animations.push({\\n\\t\\t\\t\\tchartInstance: chartInstance,\\n\\t\\t\\t\\tanimationObject: animationObject\\n\\t\\t\\t});\\n\\n\\t\\t\\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\\n\\t\\t\\tif (me.animations.length === 1) {\\n\\t\\t\\t\\tme.requestAnimationFrame();\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\t// Cancel the animation for a given chart instance\\n\\t\\tcancelAnimation: function(chartInstance) {\\n\\t\\t\\tvar index = helpers.findIndex(this.animations, function(animationWrapper) {\\n\\t\\t\\t\\treturn animationWrapper.chartInstance === chartInstance;\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (index !== -1) {\\n\\t\\t\\t\\tthis.animations.splice(index, 1);\\n\\t\\t\\t\\tchartInstance.animating = false;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\trequestAnimationFrame: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.request === null) {\\n\\t\\t\\t\\t// Skip animation frame requests until the active one is executed.\\n\\t\\t\\t\\t// This can happen when processing mouse events, e.g. 'mousemove'\\n\\t\\t\\t\\t// and 'mouseout' events will trigger multiple renders.\\n\\t\\t\\t\\tme.request = helpers.requestAnimFrame.call(window, function() {\\n\\t\\t\\t\\t\\tme.request = null;\\n\\t\\t\\t\\t\\tme.startDigest();\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tstartDigest: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tvar startTime = Date.now();\\n\\t\\t\\tvar framesToDrop = 0;\\n\\n\\t\\t\\tif (me.dropFrames > 1) {\\n\\t\\t\\t\\tframesToDrop = Math.floor(me.dropFrames);\\n\\t\\t\\t\\tme.dropFrames = me.dropFrames % 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\twhile (i < me.animations.length) {\\n\\t\\t\\t\\tif (me.animations[i].animationObject.currentStep === null) {\\n\\t\\t\\t\\t\\tme.animations[i].animationObject.currentStep = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.animations[i].animationObject.currentStep += 1 + framesToDrop;\\n\\n\\t\\t\\t\\tif (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\\n\\t\\t\\t\\t\\tme.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\\n\\t\\t\\t\\tif (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\\n\\t\\t\\t\\t\\tme.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\\n\\t\\t\\t\\t\\tif (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\\n\\t\\t\\t\\t\\t\\tme.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// executed the last frame. Remove the animation.\\n\\t\\t\\t\\t\\tme.animations[i].chartInstance.animating = false;\\n\\n\\t\\t\\t\\t\\tme.animations.splice(i, 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar endTime = Date.now();\\n\\t\\t\\tvar dropFrames = (endTime - startTime) / me.frameDuration;\\n\\n\\t\\t\\tme.dropFrames += dropFrames;\\n\\n\\t\\t\\t// Do we have more stuff to animate?\\n\\t\\t\\tif (me.animations.length > 0) {\\n\\t\\t\\t\\tme.requestAnimationFrame();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],22:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\t// Global Chart canvas helpers object for drawing items to canvas\\n\\tvar helpers = Chart.canvasHelpers = {};\\n\\n\\thelpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\\n\\t\\tvar type, edgeLength, xOffset, yOffset, height, size;\\n\\n\\t\\tif (typeof pointStyle === 'object') {\\n\\t\\t\\ttype = pointStyle.toString();\\n\\t\\t\\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\\n\\t\\t\\t\\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isNaN(radius) || radius <= 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tswitch (pointStyle) {\\n\\t\\t// Default includes circle\\n\\t\\tdefault:\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.arc(x, y, radius, 0, Math.PI * 2);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'triangle':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tedgeLength = 3 * radius / Math.sqrt(3);\\n\\t\\t\\theight = edgeLength * Math.sqrt(3) / 2;\\n\\t\\t\\tctx.moveTo(x - edgeLength / 2, y + height / 3);\\n\\t\\t\\tctx.lineTo(x + edgeLength / 2, y + height / 3);\\n\\t\\t\\tctx.lineTo(x, y - 2 * height / 3);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'rect':\\n\\t\\t\\tsize = 1 / Math.SQRT2 * radius;\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\\n\\t\\t\\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\\n\\t\\t\\tbreak;\\n\\t\\tcase 'rectRounded':\\n\\t\\t\\tvar offset = radius / Math.SQRT2;\\n\\t\\t\\tvar leftX = x - offset;\\n\\t\\t\\tvar topY = y - offset;\\n\\t\\t\\tvar sideSize = Math.SQRT2 * radius;\\n\\t\\t\\tChart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'rectRot':\\n\\t\\t\\tsize = 1 / Math.SQRT2 * radius;\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x - size, y);\\n\\t\\t\\tctx.lineTo(x, y + size);\\n\\t\\t\\tctx.lineTo(x + size, y);\\n\\t\\t\\tctx.lineTo(x, y - size);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'cross':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x, y + radius);\\n\\t\\t\\tctx.lineTo(x, y - radius);\\n\\t\\t\\tctx.moveTo(x - radius, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'crossRot':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\txOffset = Math.cos(Math.PI / 4) * radius;\\n\\t\\t\\tyOffset = Math.sin(Math.PI / 4) * radius;\\n\\t\\t\\tctx.moveTo(x - xOffset, y - yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y + yOffset);\\n\\t\\t\\tctx.moveTo(x - xOffset, y + yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y - yOffset);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'star':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x, y + radius);\\n\\t\\t\\tctx.lineTo(x, y - radius);\\n\\t\\t\\tctx.moveTo(x - radius, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\txOffset = Math.cos(Math.PI / 4) * radius;\\n\\t\\t\\tyOffset = Math.sin(Math.PI / 4) * radius;\\n\\t\\t\\tctx.moveTo(x - xOffset, y - yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y + yOffset);\\n\\t\\t\\tctx.moveTo(x - xOffset, y + yOffset);\\n\\t\\t\\tctx.lineTo(x + xOffset, y - yOffset);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'line':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x - radius, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\tcase 'dash':\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x, y);\\n\\t\\t\\tctx.lineTo(x + radius, y);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tctx.stroke();\\n\\t};\\n\\n\\thelpers.clipArea = function(ctx, clipArea) {\\n\\t\\tctx.save();\\n\\t\\tctx.beginPath();\\n\\t\\tctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);\\n\\t\\tctx.clip();\\n\\t};\\n\\n\\thelpers.unclipArea = function(ctx) {\\n\\t\\tctx.restore();\\n\\t};\\n\\n};\\n\\n},{}],23:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar plugins = Chart.plugins;\\n\\tvar platform = Chart.platform;\\n\\n\\t// Create a dictionary of chart types, to allow for extension of existing types\\n\\tChart.types = {};\\n\\n\\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\\n\\t// Destroy method on the chart will remove the instance of the chart from this reference.\\n\\tChart.instances = {};\\n\\n\\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\\n\\tChart.controllers = {};\\n\\n\\t/**\\n\\t * Initializes the given config with global and chart default values.\\n\\t */\\n\\tfunction initConfig(config) {\\n\\t\\tconfig = config || {};\\n\\n\\t\\t// Do NOT use configMerge() for the data object because this method merges arrays\\n\\t\\t// and so would change references to labels and datasets, preventing data updates.\\n\\t\\tvar data = config.data = config.data || {};\\n\\t\\tdata.datasets = data.datasets || [];\\n\\t\\tdata.labels = data.labels || [];\\n\\n\\t\\tconfig.options = helpers.configMerge(\\n\\t\\t\\tChart.defaults.global,\\n\\t\\t\\tChart.defaults[config.type],\\n\\t\\t\\tconfig.options || {});\\n\\n\\t\\treturn config;\\n\\t}\\n\\n\\t/**\\n\\t * Updates the config of the chart\\n\\t * @param chart {Chart.Controller} chart to update the options for\\n\\t */\\n\\tfunction updateConfig(chart) {\\n\\t\\tvar newOptions = chart.options;\\n\\n\\t\\t// Update Scale(s) with options\\n\\t\\tif (newOptions.scale) {\\n\\t\\t\\tchart.scale.options = newOptions.scale;\\n\\t\\t} else if (newOptions.scales) {\\n\\t\\t\\tnewOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {\\n\\t\\t\\t\\tchart.scales[scaleOptions.id].options = scaleOptions;\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t// Tooltip\\n\\t\\tchart.tooltip._options = newOptions.tooltips;\\n\\t}\\n\\n\\t/**\\n\\t * @class Chart.Controller\\n\\t * The main controller of a chart.\\n\\t */\\n\\tChart.Controller = function(item, config, instance) {\\n\\t\\tvar me = this;\\n\\n\\t\\tconfig = initConfig(config);\\n\\n\\t\\tvar context = platform.acquireContext(item, config);\\n\\t\\tvar canvas = context && context.canvas;\\n\\t\\tvar height = canvas && canvas.height;\\n\\t\\tvar width = canvas && canvas.width;\\n\\n\\t\\tinstance.ctx = context;\\n\\t\\tinstance.canvas = canvas;\\n\\t\\tinstance.config = config;\\n\\t\\tinstance.width = width;\\n\\t\\tinstance.height = height;\\n\\t\\tinstance.aspectRatio = height? width / height : null;\\n\\n\\t\\tme.id = helpers.uid();\\n\\t\\tme.chart = instance;\\n\\t\\tme.config = config;\\n\\t\\tme.options = config.options;\\n\\t\\tme._bufferedRender = false;\\n\\n\\t\\t// Add the chart instance to the global namespace\\n\\t\\tChart.instances[me.id] = me;\\n\\n\\t\\tObject.defineProperty(me, 'data', {\\n\\t\\t\\tget: function() {\\n\\t\\t\\t\\treturn me.config.data;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tif (!context || !canvas) {\\n\\t\\t\\t// The given item is not a compatible context2d element, let's return before finalizing\\n\\t\\t\\t// the chart initialization but after setting basic chart / controller properties that\\n\\t\\t\\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\\n\\t\\t\\t// https://github.com/chartjs/Chart.js/issues/2807\\n\\t\\t\\tconsole.error(\\\"Failed to create chart: can't acquire context from the given item\\\");\\n\\t\\t\\treturn me;\\n\\t\\t}\\n\\n\\t\\tme.initialize();\\n\\t\\tme.update();\\n\\n\\t\\treturn me;\\n\\t};\\n\\n\\thelpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller.prototype */ {\\n\\t\\tinitialize: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Before init plugin notification\\n\\t\\t\\tplugins.notify(me, 'beforeInit');\\n\\n\\t\\t\\thelpers.retinaScale(me.chart);\\n\\n\\t\\t\\tme.bindEvents();\\n\\n\\t\\t\\tif (me.options.responsive) {\\n\\t\\t\\t\\t// Initial resize before chart draws (must be silent to preserve initial animations).\\n\\t\\t\\t\\tme.resize(true);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure scales have IDs and are built before we build any controllers.\\n\\t\\t\\tme.ensureScalesHaveIDs();\\n\\t\\t\\tme.buildScales();\\n\\t\\t\\tme.initToolTip();\\n\\n\\t\\t\\t// After init plugin notification\\n\\t\\t\\tplugins.notify(me, 'afterInit');\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\tclear: function() {\\n\\t\\t\\thelpers.clear(this.chart);\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tstop: function() {\\n\\t\\t\\t// Stops any current animation loop occurring\\n\\t\\t\\tChart.animationService.cancelAnimation(this);\\n\\t\\t\\treturn this;\\n\\t\\t},\\n\\n\\t\\tresize: function(silent) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar options = me.options;\\n\\t\\t\\tvar canvas = chart.canvas;\\n\\t\\t\\tvar aspectRatio = (options.maintainAspectRatio && chart.aspectRatio) || null;\\n\\n\\t\\t\\t// the canvas render width and height will be casted to integers so make sure that\\n\\t\\t\\t// the canvas display style uses the same integer values to avoid blurring effect.\\n\\t\\t\\tvar newWidth = Math.floor(helpers.getMaximumWidth(canvas));\\n\\t\\t\\tvar newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\\n\\n\\t\\t\\tif (chart.width === newWidth && chart.height === newHeight) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcanvas.width = chart.width = newWidth;\\n\\t\\t\\tcanvas.height = chart.height = newHeight;\\n\\t\\t\\tcanvas.style.width = newWidth + 'px';\\n\\t\\t\\tcanvas.style.height = newHeight + 'px';\\n\\n\\t\\t\\thelpers.retinaScale(chart);\\n\\n\\t\\t\\tif (!silent) {\\n\\t\\t\\t\\t// Notify any plugins about the resize\\n\\t\\t\\t\\tvar newSize = {width: newWidth, height: newHeight};\\n\\t\\t\\t\\tplugins.notify(me, 'resize', [newSize]);\\n\\n\\t\\t\\t\\t// Notify of resize\\n\\t\\t\\t\\tif (me.options.onResize) {\\n\\t\\t\\t\\t\\tme.options.onResize(me, newSize);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.stop();\\n\\t\\t\\t\\tme.update(me.options.responsiveAnimationDuration);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tensureScalesHaveIDs: function() {\\n\\t\\t\\tvar options = this.options;\\n\\t\\t\\tvar scalesOptions = options.scales || {};\\n\\t\\t\\tvar scaleOptions = options.scale;\\n\\n\\t\\t\\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\\n\\t\\t\\t\\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\\n\\t\\t\\t\\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (scaleOptions) {\\n\\t\\t\\t\\tscaleOptions.id = scaleOptions.id || 'scale';\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Builds a map of scale ID to scale object for future lookup.\\n\\t\\t */\\n\\t\\tbuildScales: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me.options;\\n\\t\\t\\tvar scales = me.scales = {};\\n\\t\\t\\tvar items = [];\\n\\n\\t\\t\\tif (options.scales) {\\n\\t\\t\\t\\titems = items.concat(\\n\\t\\t\\t\\t\\t(options.scales.xAxes || []).map(function(xAxisOptions) {\\n\\t\\t\\t\\t\\t\\treturn {options: xAxisOptions, dtype: 'category'};\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\t(options.scales.yAxes || []).map(function(yAxisOptions) {\\n\\t\\t\\t\\t\\t\\treturn {options: yAxisOptions, dtype: 'linear'};\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (options.scale) {\\n\\t\\t\\t\\titems.push({options: options.scale, dtype: 'radialLinear', isDefault: true});\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(items, function(item) {\\n\\t\\t\\t\\tvar scaleOptions = item.options;\\n\\t\\t\\t\\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\\n\\t\\t\\t\\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\\n\\t\\t\\t\\tif (!scaleClass) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar scale = new scaleClass({\\n\\t\\t\\t\\t\\tid: scaleOptions.id,\\n\\t\\t\\t\\t\\toptions: scaleOptions,\\n\\t\\t\\t\\t\\tctx: me.chart.ctx,\\n\\t\\t\\t\\t\\tchart: me\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tscales[scale.id] = scale;\\n\\n\\t\\t\\t\\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\\n\\t\\t\\t\\t// and consider it as a regular scale part of the \\\"scales\\\"\\\" map only! This would\\n\\t\\t\\t\\t// make the logic easier and remove some useless? custom code.\\n\\t\\t\\t\\tif (item.isDefault) {\\n\\t\\t\\t\\t\\tme.scale = scale;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tChart.scaleService.addScalesToLayout(this);\\n\\t\\t},\\n\\n\\t\\tbuildOrUpdateControllers: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar types = [];\\n\\t\\t\\tvar newControllers = [];\\n\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar meta = me.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\tif (!meta.type) {\\n\\t\\t\\t\\t\\tmeta.type = dataset.type || me.config.type;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttypes.push(meta.type);\\n\\n\\t\\t\\t\\tif (meta.controller) {\\n\\t\\t\\t\\t\\tmeta.controller.updateIndex(datasetIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmeta.controller = new Chart.controllers[meta.type](me, datasetIndex);\\n\\t\\t\\t\\t\\tnewControllers.push(meta.controller);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\tif (types.length > 1) {\\n\\t\\t\\t\\tfor (var i = 1; i < types.length; i++) {\\n\\t\\t\\t\\t\\tif (types[i] !== types[i - 1]) {\\n\\t\\t\\t\\t\\t\\tme.isCombo = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn newControllers;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Reset the elements of all datasets\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tresetElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tme.getDatasetMeta(datasetIndex).controller.reset();\\n\\t\\t\\t}, me);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t* Resets the chart back to it's state before the initial animation\\n\\t\\t*/\\n\\t\\treset: function() {\\n\\t\\t\\tthis.resetElements();\\n\\t\\t\\tthis.tooltip.initialize();\\n\\t\\t},\\n\\n\\t\\tupdate: function(animationDuration, lazy) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tupdateConfig(me);\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeUpdate') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// In case the entire data object changed\\n\\t\\t\\tme.tooltip._data = me.data;\\n\\n\\t\\t\\t// Make sure dataset controllers are updated and new controllers are reset\\n\\t\\t\\tvar newControllers = me.buildOrUpdateControllers();\\n\\n\\t\\t\\t// Make sure all dataset controllers have correct meta data counts\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\tme.updateLayout();\\n\\n\\t\\t\\t// Can only reset the new controllers after the scales have been updated\\n\\t\\t\\thelpers.each(newControllers, function(controller) {\\n\\t\\t\\t\\tcontroller.reset();\\n\\t\\t\\t});\\n\\n\\t\\t\\tme.updateDatasets();\\n\\n\\t\\t\\t// Do this before render so that any plugins that need final scale updates can use it\\n\\t\\t\\tplugins.notify(me, 'afterUpdate');\\n\\n\\t\\t\\tif (me._bufferedRender) {\\n\\t\\t\\t\\tme._bufferedRequest = {\\n\\t\\t\\t\\t\\tlazy: lazy,\\n\\t\\t\\t\\t\\tduration: animationDuration\\n\\t\\t\\t\\t};\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.render(animationDuration, lazy);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\\n\\t\\t * hook, in which case, plugins will not be called on `afterLayout`.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tupdateLayout: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeLayout') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.layoutService.update(this, this.chart.width, this.chart.height);\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Provided for backward compatibility, use `afterLayout` instead.\\n\\t\\t\\t * @method IPlugin#afterScaleUpdate\\n\\t\\t\\t * @deprecated since version 2.5.0\\n\\t\\t\\t * @todo remove at version 3\\n\\t\\t\\t */\\n\\t\\t\\tplugins.notify(me, 'afterScaleUpdate');\\n\\t\\t\\tplugins.notify(me, 'afterLayout');\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\\n\\t\\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tupdateDatasets: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\\n\\t\\t\\t\\tme.getDatasetMeta(i).controller.update();\\n\\t\\t\\t}\\n\\n\\t\\t\\tplugins.notify(me, 'afterDatasetsUpdate');\\n\\t\\t},\\n\\n\\t\\trender: function(duration, lazy) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeRender') === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar animationOptions = me.options.animation;\\n\\t\\t\\tvar onComplete = function() {\\n\\t\\t\\t\\tplugins.notify(me, 'afterRender');\\n\\t\\t\\t\\tvar callback = animationOptions && animationOptions.onComplete;\\n\\t\\t\\t\\tif (callback && callback.call) {\\n\\t\\t\\t\\t\\tcallback.call(me);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\\n\\t\\t\\t\\tvar animation = new Chart.Animation();\\n\\t\\t\\t\\tanimation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps\\n\\t\\t\\t\\tanimation.easing = animationOptions.easing;\\n\\n\\t\\t\\t\\t// render function\\n\\t\\t\\t\\tanimation.render = function(chartInstance, animationObject) {\\n\\t\\t\\t\\t\\tvar easingFunction = helpers.easingEffects[animationObject.easing];\\n\\t\\t\\t\\t\\tvar stepDecimal = animationObject.currentStep / animationObject.numSteps;\\n\\t\\t\\t\\t\\tvar easeDecimal = easingFunction(stepDecimal);\\n\\n\\t\\t\\t\\t\\tchartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// user events\\n\\t\\t\\t\\tanimation.onAnimationProgress = animationOptions.onProgress;\\n\\t\\t\\t\\tanimation.onAnimationComplete = onComplete;\\n\\n\\t\\t\\t\\tChart.animationService.addAnimation(me, animation, duration, lazy);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.draw();\\n\\t\\t\\t\\tonComplete();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\tdraw: function(easingValue) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tme.clear();\\n\\n\\t\\t\\tif (easingValue === undefined || easingValue === null) {\\n\\t\\t\\t\\teasingValue = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Draw all the scales\\n\\t\\t\\thelpers.each(me.boxes, function(box) {\\n\\t\\t\\t\\tbox.draw(me.chartArea);\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\tif (me.scale) {\\n\\t\\t\\t\\tme.scale.draw();\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.drawDatasets(easingValue);\\n\\n\\t\\t\\t// Finally draw the tooltip\\n\\t\\t\\tme.tooltip.transition(easingValue).draw();\\n\\n\\t\\t\\tplugins.notify(me, 'afterDraw', [easingValue]);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\\n\\t\\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tdrawDatasets: function(easingValue) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Draw each dataset via its respective controller (reversed to support proper line stacking)\\n\\t\\t\\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tif (me.isDatasetVisible(datasetIndex)) {\\n\\t\\t\\t\\t\\tme.getDatasetMeta(datasetIndex).controller.draw(easingValue);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me, true);\\n\\n\\t\\t\\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\\n\\t\\t},\\n\\n\\t\\t// Get the single element that was clicked on\\n\\t\\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\\n\\t\\tgetElementAtEvent: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes.single(this, e);\\n\\t\\t},\\n\\n\\t\\tgetElementsAtEvent: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes.label(this, e, {intersect: true});\\n\\t\\t},\\n\\n\\t\\tgetElementsAtXAxis: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes['x-axis'](this, e, {intersect: true});\\n\\t\\t},\\n\\n\\t\\tgetElementsAtEventForMode: function(e, mode, options) {\\n\\t\\t\\tvar method = Chart.Interaction.modes[mode];\\n\\t\\t\\tif (typeof method === 'function') {\\n\\t\\t\\t\\treturn method(this, e, options);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn [];\\n\\t\\t},\\n\\n\\t\\tgetDatasetAtEvent: function(e) {\\n\\t\\t\\treturn Chart.Interaction.modes.dataset(this, e, {intersect: true});\\n\\t\\t},\\n\\n\\t\\tgetDatasetMeta: function(datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar dataset = me.data.datasets[datasetIndex];\\n\\t\\t\\tif (!dataset._meta) {\\n\\t\\t\\t\\tdataset._meta = {};\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar meta = dataset._meta[me.id];\\n\\t\\t\\tif (!meta) {\\n\\t\\t\\t\\tmeta = dataset._meta[me.id] = {\\n\\t\\t\\t\\t\\ttype: null,\\n\\t\\t\\t\\t\\tdata: [],\\n\\t\\t\\t\\t\\tdataset: null,\\n\\t\\t\\t\\t\\tcontroller: null,\\n\\t\\t\\t\\t\\thidden: null,\\t\\t\\t// See isDatasetVisible() comment\\n\\t\\t\\t\\t\\txAxisID: null,\\n\\t\\t\\t\\t\\tyAxisID: null\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn meta;\\n\\t\\t},\\n\\n\\t\\tgetVisibleDatasetCount: function() {\\n\\t\\t\\tvar count = 0;\\n\\t\\t\\tfor (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {\\n\\t\\t\\t\\tif (this.isDatasetVisible(i)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t},\\n\\n\\t\\tisDatasetVisible: function(datasetIndex) {\\n\\t\\t\\tvar meta = this.getDatasetMeta(datasetIndex);\\n\\n\\t\\t\\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\\n\\t\\t\\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\\n\\t\\t\\treturn typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\\n\\t\\t},\\n\\n\\t\\tgenerateLegend: function() {\\n\\t\\t\\treturn this.options.legendCallback(this);\\n\\t\\t},\\n\\n\\t\\tdestroy: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar canvas = me.chart.canvas;\\n\\t\\t\\tvar meta, i, ilen;\\n\\n\\t\\t\\tme.stop();\\n\\n\\t\\t\\t// dataset controllers need to cleanup associated data\\n\\t\\t\\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\\n\\t\\t\\t\\tmeta = me.getDatasetMeta(i);\\n\\t\\t\\t\\tif (meta.controller) {\\n\\t\\t\\t\\t\\tmeta.controller.destroy();\\n\\t\\t\\t\\t\\tmeta.controller = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (canvas) {\\n\\t\\t\\t\\tme.unbindEvents();\\n\\t\\t\\t\\thelpers.clear(me.chart);\\n\\t\\t\\t\\tplatform.releaseContext(me.chart.ctx);\\n\\t\\t\\t\\tme.chart.canvas = null;\\n\\t\\t\\t\\tme.chart.ctx = null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tplugins.notify(me, 'destroy');\\n\\n\\t\\t\\tdelete Chart.instances[me.id];\\n\\t\\t},\\n\\n\\t\\ttoBase64Image: function() {\\n\\t\\t\\treturn this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\\n\\t\\t},\\n\\n\\t\\tinitToolTip: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.tooltip = new Chart.Tooltip({\\n\\t\\t\\t\\t_chart: me.chart,\\n\\t\\t\\t\\t_chartInstance: me,\\n\\t\\t\\t\\t_data: me.data,\\n\\t\\t\\t\\t_options: me.options.tooltips\\n\\t\\t\\t}, me);\\n\\t\\t\\tme.tooltip.initialize();\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tbindEvents: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar listeners = me._listeners = {};\\n\\t\\t\\tvar listener = function() {\\n\\t\\t\\t\\tme.eventHandler.apply(me, arguments);\\n\\t\\t\\t};\\n\\n\\t\\t\\thelpers.each(me.options.events, function(type) {\\n\\t\\t\\t\\tplatform.addEventListener(me, type, listener);\\n\\t\\t\\t\\tlisteners[type] = listener;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Responsiveness is currently based on the use of an iframe, however this method causes\\n\\t\\t\\t// performance issues and could be troublesome when used with ad blockers. So make sure\\n\\t\\t\\t// that the user is still able to create a chart without iframe when responsive is false.\\n\\t\\t\\t// See https://github.com/chartjs/Chart.js/issues/2210\\n\\t\\t\\tif (me.options.responsive) {\\n\\t\\t\\t\\tlistener = function() {\\n\\t\\t\\t\\t\\tme.resize();\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tplatform.addEventListener(me, 'resize', listener);\\n\\t\\t\\t\\tlisteners.resize = listener;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tunbindEvents: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar listeners = me._listeners;\\n\\t\\t\\tif (!listeners) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdelete me._listeners;\\n\\t\\t\\thelpers.each(listeners, function(listener, type) {\\n\\t\\t\\t\\tplatform.removeEventListener(me, type, listener);\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tupdateHoverStyle: function(elements, mode, enabled) {\\n\\t\\t\\tvar method = enabled? 'setHoverStyle' : 'removeHoverStyle';\\n\\t\\t\\tvar element, i, ilen;\\n\\n\\t\\t\\tfor (i=0, ilen=elements.length; i<ilen; ++i) {\\n\\t\\t\\t\\telement = elements[i];\\n\\t\\t\\t\\tif (element) {\\n\\t\\t\\t\\t\\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\teventHandler: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar tooltip = me.tooltip;\\n\\n\\t\\t\\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Buffer any update calls so that renders do not occur\\n\\t\\t\\tme._bufferedRender = true;\\n\\t\\t\\tme._bufferedRequest = null;\\n\\n\\t\\t\\tvar changed = me.handleEvent(e);\\n\\t\\t\\tchanged |= tooltip && tooltip.handleEvent(e);\\n\\n\\t\\t\\tplugins.notify(me, 'afterEvent', [e]);\\n\\n\\t\\t\\tvar bufferedRequest = me._bufferedRequest;\\n\\t\\t\\tif (bufferedRequest) {\\n\\t\\t\\t\\t// If we have an update that was triggered, we need to do a normal render\\n\\t\\t\\t\\tme.render(bufferedRequest.duration, bufferedRequest.lazy);\\n\\t\\t\\t} else if (changed && !me.animating) {\\n\\t\\t\\t\\t// If entering, leaving, or changing elements, animate the change via pivot\\n\\t\\t\\t\\tme.stop();\\n\\n\\t\\t\\t\\t// We only need to render at this point. Updating will cause scales to be\\n\\t\\t\\t\\t// recomputed generating flicker & using more memory than necessary.\\n\\t\\t\\t\\tme.render(me.options.hover.animationDuration, true);\\n\\t\\t\\t}\\n\\n\\t\\t\\tme._bufferedRender = false;\\n\\t\\t\\tme._bufferedRequest = null;\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle an event\\n\\t\\t * @private\\n\\t\\t * @param {IEvent} event the event to handle\\n\\t\\t * @return {Boolean} true if the chart needs to re-render\\n\\t\\t */\\n\\t\\thandleEvent: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me.options || {};\\n\\t\\t\\tvar hoverOptions = options.hover;\\n\\t\\t\\tvar changed = false;\\n\\n\\t\\t\\tme.lastActive = me.lastActive || [];\\n\\n\\t\\t\\t// Find Active Elements for hover and tooltips\\n\\t\\t\\tif (e.type === 'mouseout') {\\n\\t\\t\\t\\tme.active = [];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// On Hover hook\\n\\t\\t\\tif (hoverOptions.onHover) {\\n\\t\\t\\t\\t// Need to call with native event here to not break backwards compatibility\\n\\t\\t\\t\\thoverOptions.onHover.call(me, e.native, me.active);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (e.type === 'mouseup' || e.type === 'click') {\\n\\t\\t\\t\\tif (options.onClick) {\\n\\t\\t\\t\\t\\t// Use e.native here for backwards compatibility\\n\\t\\t\\t\\t\\toptions.onClick.call(me, e.native, me.active);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove styling for last active (even if it may still be active)\\n\\t\\t\\tif (me.lastActive.length) {\\n\\t\\t\\t\\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Built in hover styling\\n\\t\\t\\tif (me.active.length && hoverOptions.mode) {\\n\\t\\t\\t\\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\\n\\t\\t\\t}\\n\\n\\t\\t\\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\\n\\n\\t\\t\\t// Remember Last Actives\\n\\t\\t\\tme.lastActive = me.active;\\n\\n\\t\\t\\treturn changed;\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],24:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\\n\\n\\t/**\\n\\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\\n\\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\\n\\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\\n\\t */\\n\\tfunction listenArrayEvents(array, listener) {\\n\\t\\tif (array._chartjs) {\\n\\t\\t\\tarray._chartjs.listeners.push(listener);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tObject.defineProperty(array, '_chartjs', {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable: false,\\n\\t\\t\\tvalue: {\\n\\t\\t\\t\\tlisteners: [listener]\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tarrayEvents.forEach(function(key) {\\n\\t\\t\\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\\n\\t\\t\\tvar base = array[key];\\n\\n\\t\\t\\tObject.defineProperty(array, key, {\\n\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\tenumerable: false,\\n\\t\\t\\t\\tvalue: function() {\\n\\t\\t\\t\\t\\tvar args = Array.prototype.slice.call(arguments);\\n\\t\\t\\t\\t\\tvar res = base.apply(this, args);\\n\\n\\t\\t\\t\\t\\thelpers.each(array._chartjs.listeners, function(object) {\\n\\t\\t\\t\\t\\t\\tif (typeof object[method] === 'function') {\\n\\t\\t\\t\\t\\t\\t\\tobject[method].apply(object, args);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * Removes the given array event listener and cleanup extra attached properties (such as\\n\\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\\n\\t */\\n\\tfunction unlistenArrayEvents(array, listener) {\\n\\t\\tvar stub = array._chartjs;\\n\\t\\tif (!stub) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar listeners = stub.listeners;\\n\\t\\tvar index = listeners.indexOf(listener);\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tlisteners.splice(index, 1);\\n\\t\\t}\\n\\n\\t\\tif (listeners.length > 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tarrayEvents.forEach(function(key) {\\n\\t\\t\\tdelete array[key];\\n\\t\\t});\\n\\n\\t\\tdelete array._chartjs;\\n\\t}\\n\\n\\t// Base class for all dataset controllers (line, bar, etc)\\n\\tChart.DatasetController = function(chart, datasetIndex) {\\n\\t\\tthis.initialize(chart, datasetIndex);\\n\\t};\\n\\n\\thelpers.extend(Chart.DatasetController.prototype, {\\n\\n\\t\\t/**\\n\\t\\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\\n\\t\\t * @type {Chart.core.element}\\n\\t\\t */\\n\\t\\tdatasetElementType: null,\\n\\n\\t\\t/**\\n\\t\\t * Element type used to generate a meta data (e.g. Chart.element.Point).\\n\\t\\t * @type {Chart.core.element}\\n\\t\\t */\\n\\t\\tdataElementType: null,\\n\\n\\t\\tinitialize: function(chart, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.chart = chart;\\n\\t\\t\\tme.index = datasetIndex;\\n\\t\\t\\tme.linkScales();\\n\\t\\t\\tme.addElements();\\n\\t\\t},\\n\\n\\t\\tupdateIndex: function(datasetIndex) {\\n\\t\\t\\tthis.index = datasetIndex;\\n\\t\\t},\\n\\n\\t\\tlinkScales: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\n\\t\\t\\tif (meta.xAxisID === null) {\\n\\t\\t\\t\\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\\n\\t\\t\\t}\\n\\t\\t\\tif (meta.yAxisID === null) {\\n\\t\\t\\t\\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tgetDataset: function() {\\n\\t\\t\\treturn this.chart.data.datasets[this.index];\\n\\t\\t},\\n\\n\\t\\tgetMeta: function() {\\n\\t\\t\\treturn this.chart.getDatasetMeta(this.index);\\n\\t\\t},\\n\\n\\t\\tgetScaleForId: function(scaleID) {\\n\\t\\t\\treturn this.chart.scales[scaleID];\\n\\t\\t},\\n\\n\\t\\treset: function() {\\n\\t\\t\\tthis.update(true);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tdestroy: function() {\\n\\t\\t\\tif (this._data) {\\n\\t\\t\\t\\tunlistenArrayEvents(this._data, this);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tcreateMetaDataset: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar type = me.datasetElementType;\\n\\t\\t\\treturn type && new type({\\n\\t\\t\\t\\t_chart: me.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: me.index\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\tcreateMetaData: function(index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar type = me.dataElementType;\\n\\t\\t\\treturn type && new type({\\n\\t\\t\\t\\t_chart: me.chart.chart,\\n\\t\\t\\t\\t_datasetIndex: me.index,\\n\\t\\t\\t\\t_index: index\\n\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\taddElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar data = me.getDataset().data || [];\\n\\t\\t\\tvar metaData = meta.data;\\n\\t\\t\\tvar i, ilen;\\n\\n\\t\\t\\tfor (i=0, ilen=data.length; i<ilen; ++i) {\\n\\t\\t\\t\\tmetaData[i] = metaData[i] || me.createMetaData(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmeta.dataset = meta.dataset || me.createMetaDataset();\\n\\t\\t},\\n\\n\\t\\taddElementAndReset: function(index) {\\n\\t\\t\\tvar element = this.createMetaData(index);\\n\\t\\t\\tthis.getMeta().data.splice(index, 0, element);\\n\\t\\t\\tthis.updateElement(element, index, true);\\n\\t\\t},\\n\\n\\t\\tbuildOrUpdateElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar dataset = me.getDataset();\\n\\t\\t\\tvar data = dataset.data || (dataset.data = []);\\n\\n\\t\\t\\t// In order to correctly handle data addition/deletion animation (an thus simulate\\n\\t\\t\\t// real-time charts), we need to monitor these data modifications and synchronize\\n\\t\\t\\t// the internal meta data accordingly.\\n\\t\\t\\tif (me._data !== data) {\\n\\t\\t\\t\\tif (me._data) {\\n\\t\\t\\t\\t\\t// This case happens when the user replaced the data array instance.\\n\\t\\t\\t\\t\\tunlistenArrayEvents(me._data, me);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlistenArrayEvents(data, me);\\n\\t\\t\\t\\tme._data = data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Re-sync meta data in case the user replaced the data array or if we missed\\n\\t\\t\\t// any updates and so make sure that we handle number of datapoints changing.\\n\\t\\t\\tme.resyncElements();\\n\\t\\t},\\n\\n\\t\\tupdate: helpers.noop,\\n\\n\\t\\tdraw: function(ease) {\\n\\t\\t\\tvar easingDecimal = ease || 1;\\n\\t\\t\\tvar i, len;\\n\\t\\t\\tvar metaData = this.getMeta().data;\\n\\t\\t\\tfor (i = 0, len = metaData.length; i < len; ++i) {\\n\\t\\t\\t\\tmetaData[i].transition(easingDecimal).draw();\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tremoveHoverStyle: function(element, elementOpts) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[element._datasetIndex],\\n\\t\\t\\t\\tindex = element._index,\\n\\t\\t\\t\\tcustom = element.custom || {},\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\\n\\t\\t\\t\\tmodel = element._model;\\n\\n\\t\\t\\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\\n\\t\\t\\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\\n\\t\\t\\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\\n\\t\\t},\\n\\n\\t\\tsetHoverStyle: function(element) {\\n\\t\\t\\tvar dataset = this.chart.data.datasets[element._datasetIndex],\\n\\t\\t\\t\\tindex = element._index,\\n\\t\\t\\t\\tcustom = element.custom || {},\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\\n\\t\\t\\t\\tgetHoverColor = helpers.getHoverColor,\\n\\t\\t\\t\\tmodel = element._model;\\n\\n\\t\\t\\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\\n\\t\\t\\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\\n\\t\\t\\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tresyncElements: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar meta = me.getMeta();\\n\\t\\t\\tvar data = me.getDataset().data;\\n\\t\\t\\tvar numMeta = meta.data.length;\\n\\t\\t\\tvar numData = data.length;\\n\\n\\t\\t\\tif (numData < numMeta) {\\n\\t\\t\\t\\tmeta.data.splice(numData, numMeta - numData);\\n\\t\\t\\t} else if (numData > numMeta) {\\n\\t\\t\\t\\tme.insertElements(numMeta, numData - numMeta);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tinsertElements: function(start, count) {\\n\\t\\t\\tfor (var i=0; i<count; ++i) {\\n\\t\\t\\t\\tthis.addElementAndReset(start + i);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataPush: function() {\\n\\t\\t\\tthis.insertElements(this.getDataset().data.length-1, arguments.length);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataPop: function() {\\n\\t\\t\\tthis.getMeta().data.pop();\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataShift: function() {\\n\\t\\t\\tthis.getMeta().data.shift();\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataSplice: function(start, count) {\\n\\t\\t\\tthis.getMeta().data.splice(start, count);\\n\\t\\t\\tthis.insertElements(start, arguments.length - 2);\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tonDataUnshift: function() {\\n\\t\\t\\tthis.insertElements(0, arguments.length);\\n\\t\\t}\\n\\t});\\n\\n\\tChart.DatasetController.extend = helpers.inherits;\\n};\\n\\n},{}],25:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.elements = {};\\n\\n\\tChart.Element = function(configuration) {\\n\\t\\thelpers.extend(this, configuration);\\n\\t\\tthis.initialize.apply(this, arguments);\\n\\t};\\n\\n\\thelpers.extend(Chart.Element.prototype, {\\n\\n\\t\\tinitialize: function() {\\n\\t\\t\\tthis.hidden = false;\\n\\t\\t},\\n\\n\\t\\tpivot: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (!me._view) {\\n\\t\\t\\t\\tme._view = helpers.clone(me._model);\\n\\t\\t\\t}\\n\\t\\t\\tme._start = helpers.clone(me._view);\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\ttransition: function(ease) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (!me._view) {\\n\\t\\t\\t\\tme._view = helpers.clone(me._model);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// No animation -> No Transition\\n\\t\\t\\tif (ease === 1) {\\n\\t\\t\\t\\tme._view = me._model;\\n\\t\\t\\t\\tme._start = null;\\n\\t\\t\\t\\treturn me;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!me._start) {\\n\\t\\t\\t\\tme.pivot();\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(me._model, function(value, key) {\\n\\n\\t\\t\\t\\tif (key[0] === '_') {\\n\\t\\t\\t\\t\\t// Only non-underscored properties\\n\\t\\t\\t\\t// Init if doesn't exist\\n\\t\\t\\t\\t} else if (!me._view.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\tif (typeof value === 'number' && !isNaN(me._view[key])) {\\n\\t\\t\\t\\t\\t\\tme._view[key] = value * ease;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tme._view[key] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t// No unnecessary computations\\n\\t\\t\\t\\t} else if (value === me._view[key]) {\\n\\t\\t\\t\\t\\t// It's the same! Woohoo!\\n\\t\\t\\t\\t// Color transitions if possible\\n\\t\\t\\t\\t} else if (typeof value === 'string') {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tvar color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);\\n\\t\\t\\t\\t\\t\\tme._view[key] = color.rgbString();\\n\\t\\t\\t\\t\\t} catch (err) {\\n\\t\\t\\t\\t\\t\\tme._view[key] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Number transitions\\n\\t\\t\\t\\t} else if (typeof value === 'number') {\\n\\t\\t\\t\\t\\tvar startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;\\n\\t\\t\\t\\t\\tme._view[key] = ((me._model[key] - startVal) * ease) + startVal;\\n\\t\\t\\t\\t// Everything else\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tme._view[key] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: this._model.x,\\n\\t\\t\\t\\ty: this._model.y\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\thasValue: function() {\\n\\t\\t\\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\\n\\t\\t}\\n\\t});\\n\\n\\tChart.Element.extend = helpers.inherits;\\n\\n};\\n\\n},{}],26:[function(require,module,exports){\\n/* global window: false */\\n/* global document: false */\\n'use strict';\\n\\nvar color = require(2);\\n\\nmodule.exports = function(Chart) {\\n\\t// Global Chart helpers object for utility methods and classes\\n\\tvar helpers = Chart.helpers = {};\\n\\n\\t// -- Basic js utility methods\\n\\thelpers.each = function(loopable, callback, self, reverse) {\\n\\t\\t// Check to see if null or undefined firstly.\\n\\t\\tvar i, len;\\n\\t\\tif (helpers.isArray(loopable)) {\\n\\t\\t\\tlen = loopable.length;\\n\\t\\t\\tif (reverse) {\\n\\t\\t\\t\\tfor (i = len - 1; i >= 0; i--) {\\n\\t\\t\\t\\t\\tcallback.call(self, loopable[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\t\\tcallback.call(self, loopable[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (typeof loopable === 'object') {\\n\\t\\t\\tvar keys = Object.keys(loopable);\\n\\t\\t\\tlen = keys.length;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tcallback.call(self, loopable[keys[i]], keys[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.clone = function(obj) {\\n\\t\\tvar objClone = {};\\n\\t\\thelpers.each(obj, function(value, key) {\\n\\t\\t\\tif (helpers.isArray(value)) {\\n\\t\\t\\t\\tobjClone[key] = value.slice(0);\\n\\t\\t\\t} else if (typeof value === 'object' && value !== null) {\\n\\t\\t\\t\\tobjClone[key] = helpers.clone(value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tobjClone[key] = value;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn objClone;\\n\\t};\\n\\thelpers.extend = function(base) {\\n\\t\\tvar setFn = function(value, key) {\\n\\t\\t\\tbase[key] = value;\\n\\t\\t};\\n\\t\\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {\\n\\t\\t\\thelpers.each(arguments[i], setFn);\\n\\t\\t}\\n\\t\\treturn base;\\n\\t};\\n\\t// Need a special merge function to chart configs since they are now grouped\\n\\thelpers.configMerge = function(_base) {\\n\\t\\tvar base = helpers.clone(_base);\\n\\t\\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\\n\\t\\t\\thelpers.each(extension, function(value, key) {\\n\\t\\t\\t\\tvar baseHasProperty = base.hasOwnProperty(key);\\n\\t\\t\\t\\tvar baseVal = baseHasProperty ? base[key] : {};\\n\\n\\t\\t\\t\\tif (key === 'scales') {\\n\\t\\t\\t\\t\\t// Scale config merging is complex. Add our own function here for that\\n\\t\\t\\t\\t\\tbase[key] = helpers.scaleMerge(baseVal, value);\\n\\t\\t\\t\\t} else if (key === 'scale') {\\n\\t\\t\\t\\t\\t// Used in polar area & radar charts since there is only one scale\\n\\t\\t\\t\\t\\tbase[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\\n\\t\\t\\t\\t} else if (baseHasProperty\\n\\t\\t\\t\\t\\t\\t&& typeof baseVal === 'object'\\n\\t\\t\\t\\t\\t\\t&& !helpers.isArray(baseVal)\\n\\t\\t\\t\\t\\t\\t&& baseVal !== null\\n\\t\\t\\t\\t\\t\\t&& typeof value === 'object'\\n\\t\\t\\t\\t\\t\\t&& !helpers.isArray(value)) {\\n\\t\\t\\t\\t\\t// If we are overwriting an object with an object, do a merge of the properties.\\n\\t\\t\\t\\t\\tbase[key] = helpers.configMerge(baseVal, value);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// can just overwrite the value in this case\\n\\t\\t\\t\\t\\tbase[key] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn base;\\n\\t};\\n\\thelpers.scaleMerge = function(_base, extension) {\\n\\t\\tvar base = helpers.clone(_base);\\n\\n\\t\\thelpers.each(extension, function(value, key) {\\n\\t\\t\\tif (key === 'xAxes' || key === 'yAxes') {\\n\\t\\t\\t\\t// These properties are arrays of items\\n\\t\\t\\t\\tif (base.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\thelpers.each(value, function(valueObj, index) {\\n\\t\\t\\t\\t\\t\\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\\n\\t\\t\\t\\t\\t\\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\\n\\t\\t\\t\\t\\t\\tif (index >= base[key].length || !base[key][index].type) {\\n\\t\\t\\t\\t\\t\\t\\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\\n\\t\\t\\t\\t\\t\\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\\n\\t\\t\\t\\t\\t\\t\\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\\n\\t\\t\\t\\t\\t\\t\\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Type is the same\\n\\t\\t\\t\\t\\t\\t\\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbase[key] = [];\\n\\t\\t\\t\\t\\thelpers.each(value, function(valueObj) {\\n\\t\\t\\t\\t\\t\\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\\n\\t\\t\\t\\t\\t\\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\\n\\t\\t\\t\\t// If we are overwriting an object with an object, do a merge of the properties.\\n\\t\\t\\t\\tbase[key] = helpers.configMerge(base[key], value);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// can just overwrite the value in this case\\n\\t\\t\\t\\tbase[key] = value;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn base;\\n\\t};\\n\\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\\n\\t\\tif (value === undefined || value === null) {\\n\\t\\t\\treturn defaultValue;\\n\\t\\t}\\n\\n\\t\\tif (helpers.isArray(value)) {\\n\\t\\t\\treturn index < value.length ? value[index] : defaultValue;\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t};\\n\\thelpers.getValueOrDefault = function(value, defaultValue) {\\n\\t\\treturn value === undefined ? defaultValue : value;\\n\\t};\\n\\thelpers.indexOf = Array.prototype.indexOf?\\n\\t\\tfunction(array, item) {\\n\\t\\t\\treturn array.indexOf(item);\\n\\t\\t}:\\n\\t\\tfunction(array, item) {\\n\\t\\t\\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\\n\\t\\t\\t\\tif (array[i] === item) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t};\\n\\thelpers.where = function(collection, filterCallback) {\\n\\t\\tif (helpers.isArray(collection) && Array.prototype.filter) {\\n\\t\\t\\treturn collection.filter(filterCallback);\\n\\t\\t}\\n\\t\\tvar filtered = [];\\n\\n\\t\\thelpers.each(collection, function(item) {\\n\\t\\t\\tif (filterCallback(item)) {\\n\\t\\t\\t\\tfiltered.push(item);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn filtered;\\n\\t};\\n\\thelpers.findIndex = Array.prototype.findIndex?\\n\\t\\tfunction(array, callback, scope) {\\n\\t\\t\\treturn array.findIndex(callback, scope);\\n\\t\\t} :\\n\\t\\tfunction(array, callback, scope) {\\n\\t\\t\\tscope = scope === undefined? array : scope;\\n\\t\\t\\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\\n\\t\\t\\t\\tif (callback.call(scope, array[i], i, array)) {\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t};\\n\\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\\n\\t\\t// Default to start of the array\\n\\t\\tif (startIndex === undefined || startIndex === null) {\\n\\t\\t\\tstartIndex = -1;\\n\\t\\t}\\n\\t\\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\\n\\t\\t\\tvar currentItem = arrayToSearch[i];\\n\\t\\t\\tif (filterCallback(currentItem)) {\\n\\t\\t\\t\\treturn currentItem;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\\n\\t\\t// Default to end of the array\\n\\t\\tif (startIndex === undefined || startIndex === null) {\\n\\t\\t\\tstartIndex = arrayToSearch.length;\\n\\t\\t}\\n\\t\\tfor (var i = startIndex - 1; i >= 0; i--) {\\n\\t\\t\\tvar currentItem = arrayToSearch[i];\\n\\t\\t\\tif (filterCallback(currentItem)) {\\n\\t\\t\\t\\treturn currentItem;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.inherits = function(extensions) {\\n\\t\\t// Basic javascript inheritance based on the model created in Backbone.js\\n\\t\\tvar me = this;\\n\\t\\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\\n\\t\\t\\treturn me.apply(this, arguments);\\n\\t\\t};\\n\\n\\t\\tvar Surrogate = function() {\\n\\t\\t\\tthis.constructor = ChartElement;\\n\\t\\t};\\n\\t\\tSurrogate.prototype = me.prototype;\\n\\t\\tChartElement.prototype = new Surrogate();\\n\\n\\t\\tChartElement.extend = helpers.inherits;\\n\\n\\t\\tif (extensions) {\\n\\t\\t\\thelpers.extend(ChartElement.prototype, extensions);\\n\\t\\t}\\n\\n\\t\\tChartElement.__super__ = me.prototype;\\n\\n\\t\\treturn ChartElement;\\n\\t};\\n\\thelpers.noop = function() {};\\n\\thelpers.uid = (function() {\\n\\t\\tvar id = 0;\\n\\t\\treturn function() {\\n\\t\\t\\treturn id++;\\n\\t\\t};\\n\\t}());\\n\\t// -- Math methods\\n\\thelpers.isNumber = function(n) {\\n\\t\\treturn !isNaN(parseFloat(n)) && isFinite(n);\\n\\t};\\n\\thelpers.almostEquals = function(x, y, epsilon) {\\n\\t\\treturn Math.abs(x - y) < epsilon;\\n\\t};\\n\\thelpers.almostWhole = function(x, epsilon) {\\n\\t\\tvar rounded = Math.round(x);\\n\\t\\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\\n\\t};\\n\\thelpers.max = function(array) {\\n\\t\\treturn array.reduce(function(max, value) {\\n\\t\\t\\tif (!isNaN(value)) {\\n\\t\\t\\t\\treturn Math.max(max, value);\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}, Number.NEGATIVE_INFINITY);\\n\\t};\\n\\thelpers.min = function(array) {\\n\\t\\treturn array.reduce(function(min, value) {\\n\\t\\t\\tif (!isNaN(value)) {\\n\\t\\t\\t\\treturn Math.min(min, value);\\n\\t\\t\\t}\\n\\t\\t\\treturn min;\\n\\t\\t}, Number.POSITIVE_INFINITY);\\n\\t};\\n\\thelpers.sign = Math.sign?\\n\\t\\tfunction(x) {\\n\\t\\t\\treturn Math.sign(x);\\n\\t\\t} :\\n\\t\\tfunction(x) {\\n\\t\\t\\tx = +x; // convert to a number\\n\\t\\t\\tif (x === 0 || isNaN(x)) {\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}\\n\\t\\t\\treturn x > 0 ? 1 : -1;\\n\\t\\t};\\n\\thelpers.log10 = Math.log10?\\n\\t\\tfunction(x) {\\n\\t\\t\\treturn Math.log10(x);\\n\\t\\t} :\\n\\t\\tfunction(x) {\\n\\t\\t\\treturn Math.log(x) / Math.LN10;\\n\\t\\t};\\n\\thelpers.toRadians = function(degrees) {\\n\\t\\treturn degrees * (Math.PI / 180);\\n\\t};\\n\\thelpers.toDegrees = function(radians) {\\n\\t\\treturn radians * (180 / Math.PI);\\n\\t};\\n\\t// Gets the angle from vertical upright to the point about a centre.\\n\\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\\n\\t\\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\\n\\t\\t\\tdistanceFromYCenter = anglePoint.y - centrePoint.y,\\n\\t\\t\\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\\n\\n\\t\\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\\n\\n\\t\\tif (angle < (-0.5 * Math.PI)) {\\n\\t\\t\\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tangle: angle,\\n\\t\\t\\tdistance: radialDistanceFromCenter\\n\\t\\t};\\n\\t};\\n\\thelpers.distanceBetweenPoints = function(pt1, pt2) {\\n\\t\\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\\n\\t};\\n\\thelpers.aliasPixel = function(pixelWidth) {\\n\\t\\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\\n\\t};\\n\\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\\n\\t\\t// Props to Rob Spencer at scaled innovation for his post on splining between points\\n\\t\\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\\n\\n\\t\\t// This function must also respect \\\"skipped\\\" points\\n\\n\\t\\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\\n\\t\\t\\tcurrent = middlePoint,\\n\\t\\t\\tnext = afterPoint.skip ? middlePoint : afterPoint;\\n\\n\\t\\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\\n\\t\\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\\n\\n\\t\\tvar s01 = d01 / (d01 + d12);\\n\\t\\tvar s12 = d12 / (d01 + d12);\\n\\n\\t\\t// If all points are the same, s01 & s02 will be inf\\n\\t\\ts01 = isNaN(s01) ? 0 : s01;\\n\\t\\ts12 = isNaN(s12) ? 0 : s12;\\n\\n\\t\\tvar fa = t * s01; // scaling factor for triangle Ta\\n\\t\\tvar fb = t * s12;\\n\\n\\t\\treturn {\\n\\t\\t\\tprevious: {\\n\\t\\t\\t\\tx: current.x - fa * (next.x - previous.x),\\n\\t\\t\\t\\ty: current.y - fa * (next.y - previous.y)\\n\\t\\t\\t},\\n\\t\\t\\tnext: {\\n\\t\\t\\t\\tx: current.x + fb * (next.x - previous.x),\\n\\t\\t\\t\\ty: current.y + fb * (next.y - previous.y)\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n\\thelpers.EPSILON = Number.EPSILON || 1e-14;\\n\\thelpers.splineCurveMonotone = function(points) {\\n\\t\\t// This function calculates Bzier control points in a similar way than |splineCurve|,\\n\\t\\t// but preserves monotonicity of the provided data and ensures no local extremums are added\\n\\t\\t// between the dataset discrete points due to the interpolation.\\n\\t\\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\\n\\n\\t\\tvar pointsWithTangents = (points || []).map(function(point) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tmodel: point._model,\\n\\t\\t\\t\\tdeltaK: 0,\\n\\t\\t\\t\\tmK: 0\\n\\t\\t\\t};\\n\\t\\t});\\n\\n\\t\\t// Calculate slopes (deltaK) and initialize tangents (mK)\\n\\t\\tvar pointsLen = pointsWithTangents.length;\\n\\t\\tvar i, pointBefore, pointCurrent, pointAfter;\\n\\t\\tfor (i = 0; i < pointsLen; ++i) {\\n\\t\\t\\tpointCurrent = pointsWithTangents[i];\\n\\t\\t\\tif (pointCurrent.model.skip) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\\n\\t\\t\\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\\n\\t\\t\\tif (pointAfter && !pointAfter.model.skip) {\\n\\t\\t\\t\\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\\n\\n\\t\\t\\t\\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\\n\\t\\t\\t\\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!pointBefore || pointBefore.model.skip) {\\n\\t\\t\\t\\tpointCurrent.mK = pointCurrent.deltaK;\\n\\t\\t\\t} else if (!pointAfter || pointAfter.model.skip) {\\n\\t\\t\\t\\tpointCurrent.mK = pointBefore.deltaK;\\n\\t\\t\\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\\n\\t\\t\\t\\tpointCurrent.mK = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Adjust tangents to ensure monotonic properties\\n\\t\\tvar alphaK, betaK, tauK, squaredMagnitude;\\n\\t\\tfor (i = 0; i < pointsLen - 1; ++i) {\\n\\t\\t\\tpointCurrent = pointsWithTangents[i];\\n\\t\\t\\tpointAfter = pointsWithTangents[i + 1];\\n\\t\\t\\tif (pointCurrent.model.skip || pointAfter.model.skip) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\\n\\t\\t\\t\\tpointCurrent.mK = pointAfter.mK = 0;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\talphaK = pointCurrent.mK / pointCurrent.deltaK;\\n\\t\\t\\tbetaK = pointAfter.mK / pointCurrent.deltaK;\\n\\t\\t\\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\\n\\t\\t\\tif (squaredMagnitude <= 9) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\ttauK = 3 / Math.sqrt(squaredMagnitude);\\n\\t\\t\\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\\n\\t\\t\\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\\n\\t\\t}\\n\\n\\t\\t// Compute control points\\n\\t\\tvar deltaX;\\n\\t\\tfor (i = 0; i < pointsLen; ++i) {\\n\\t\\t\\tpointCurrent = pointsWithTangents[i];\\n\\t\\t\\tif (pointCurrent.model.skip) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\\n\\t\\t\\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\\n\\t\\t\\tif (pointBefore && !pointBefore.model.skip) {\\n\\t\\t\\t\\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\\n\\t\\t\\t\\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\\n\\t\\t\\t\\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\\n\\t\\t\\t}\\n\\t\\t\\tif (pointAfter && !pointAfter.model.skip) {\\n\\t\\t\\t\\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\\n\\t\\t\\t\\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\\n\\t\\t\\t\\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\thelpers.nextItem = function(collection, index, loop) {\\n\\t\\tif (loop) {\\n\\t\\t\\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\\n\\t\\t}\\n\\t\\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\\n\\t};\\n\\thelpers.previousItem = function(collection, index, loop) {\\n\\t\\tif (loop) {\\n\\t\\t\\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\\n\\t\\t}\\n\\t\\treturn index <= 0 ? collection[0] : collection[index - 1];\\n\\t};\\n\\t// Implementation of the nice number algorithm used in determining where axis labels will go\\n\\thelpers.niceNum = function(range, round) {\\n\\t\\tvar exponent = Math.floor(helpers.log10(range));\\n\\t\\tvar fraction = range / Math.pow(10, exponent);\\n\\t\\tvar niceFraction;\\n\\n\\t\\tif (round) {\\n\\t\\t\\tif (fraction < 1.5) {\\n\\t\\t\\t\\tniceFraction = 1;\\n\\t\\t\\t} else if (fraction < 3) {\\n\\t\\t\\t\\tniceFraction = 2;\\n\\t\\t\\t} else if (fraction < 7) {\\n\\t\\t\\t\\tniceFraction = 5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tniceFraction = 10;\\n\\t\\t\\t}\\n\\t\\t} else if (fraction <= 1.0) {\\n\\t\\t\\tniceFraction = 1;\\n\\t\\t} else if (fraction <= 2) {\\n\\t\\t\\tniceFraction = 2;\\n\\t\\t} else if (fraction <= 5) {\\n\\t\\t\\tniceFraction = 5;\\n\\t\\t} else {\\n\\t\\t\\tniceFraction = 10;\\n\\t\\t}\\n\\n\\t\\treturn niceFraction * Math.pow(10, exponent);\\n\\t};\\n\\t// Easing functions adapted from Robert Penner's easing equations\\n\\t// http://www.robertpenner.com/easing/\\n\\tvar easingEffects = helpers.easingEffects = {\\n\\t\\tlinear: function(t) {\\n\\t\\t\\treturn t;\\n\\t\\t},\\n\\t\\teaseInQuad: function(t) {\\n\\t\\t\\treturn t * t;\\n\\t\\t},\\n\\t\\teaseOutQuad: function(t) {\\n\\t\\t\\treturn -1 * t * (t - 2);\\n\\t\\t},\\n\\t\\teaseInOutQuad: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 / 2 * ((--t) * (t - 2) - 1);\\n\\t\\t},\\n\\t\\teaseInCubic: function(t) {\\n\\t\\t\\treturn t * t * t;\\n\\t\\t},\\n\\t\\teaseOutCubic: function(t) {\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\\n\\t\\t},\\n\\t\\teaseInOutCubic: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * t + 2);\\n\\t\\t},\\n\\t\\teaseInQuart: function(t) {\\n\\t\\t\\treturn t * t * t * t;\\n\\t\\t},\\n\\t\\teaseOutQuart: function(t) {\\n\\t\\t\\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\\n\\t\\t},\\n\\t\\teaseInOutQuart: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\\n\\t\\t},\\n\\t\\teaseInQuint: function(t) {\\n\\t\\t\\treturn 1 * (t /= 1) * t * t * t * t;\\n\\t\\t},\\n\\t\\teaseOutQuint: function(t) {\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\\n\\t\\t},\\n\\t\\teaseInOutQuint: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * t * t * t * t * t;\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\\n\\t\\t},\\n\\t\\teaseInSine: function(t) {\\n\\t\\t\\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\\n\\t\\t},\\n\\t\\teaseOutSine: function(t) {\\n\\t\\t\\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\\n\\t\\t},\\n\\t\\teaseInOutSine: function(t) {\\n\\t\\t\\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\\n\\t\\t},\\n\\t\\teaseInExpo: function(t) {\\n\\t\\t\\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\\n\\t\\t},\\n\\t\\teaseOutExpo: function(t) {\\n\\t\\t\\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\\n\\t\\t},\\n\\t\\teaseInOutExpo: function(t) {\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (t === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\\n\\t\\t},\\n\\t\\teaseInCirc: function(t) {\\n\\t\\t\\tif (t >= 1) {\\n\\t\\t\\t\\treturn t;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\\n\\t\\t},\\n\\t\\teaseOutCirc: function(t) {\\n\\t\\t\\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\\n\\t\\t},\\n\\t\\teaseInOutCirc: function(t) {\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\\n\\t\\t},\\n\\t\\teaseInElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1) === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * 0.3;\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\\n\\t\\t},\\n\\t\\teaseOutElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1) === 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * 0.3;\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\\n\\t\\t},\\n\\t\\teaseInOutElastic: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tvar p = 0;\\n\\t\\t\\tvar a = 1;\\n\\t\\t\\tif (t === 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ((t /= 1 / 2) === 2) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (!p) {\\n\\t\\t\\t\\tp = 1 * (0.3 * 1.5);\\n\\t\\t\\t}\\n\\t\\t\\tif (a < Math.abs(1)) {\\n\\t\\t\\t\\ta = 1;\\n\\t\\t\\t\\ts = p / 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = p / (2 * Math.PI) * Math.asin(1 / a);\\n\\t\\t\\t}\\n\\t\\t\\tif (t < 1) {\\n\\t\\t\\t\\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\\n\\t\\t\\t}\\n\\t\\t\\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\\n\\t\\t},\\n\\t\\teaseInBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\\n\\t\\t},\\n\\t\\teaseOutBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\\n\\t\\t},\\n\\t\\teaseInOutBack: function(t) {\\n\\t\\t\\tvar s = 1.70158;\\n\\t\\t\\tif ((t /= 1 / 2) < 1) {\\n\\t\\t\\t\\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\\n\\t\\t},\\n\\t\\teaseInBounce: function(t) {\\n\\t\\t\\treturn 1 - easingEffects.easeOutBounce(1 - t);\\n\\t\\t},\\n\\t\\teaseOutBounce: function(t) {\\n\\t\\t\\tif ((t /= 1) < (1 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * t * t);\\n\\t\\t\\t} else if (t < (2 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\\n\\t\\t\\t} else if (t < (2.5 / 2.75)) {\\n\\t\\t\\t\\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\\n\\t\\t},\\n\\t\\teaseInOutBounce: function(t) {\\n\\t\\t\\tif (t < 1 / 2) {\\n\\t\\t\\t\\treturn easingEffects.easeInBounce(t * 2) * 0.5;\\n\\t\\t\\t}\\n\\t\\t\\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\\n\\t\\t}\\n\\t};\\n\\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\\n\\thelpers.requestAnimFrame = (function() {\\n\\t\\treturn window.requestAnimationFrame ||\\n\\t\\t\\twindow.webkitRequestAnimationFrame ||\\n\\t\\t\\twindow.mozRequestAnimationFrame ||\\n\\t\\t\\twindow.oRequestAnimationFrame ||\\n\\t\\t\\twindow.msRequestAnimationFrame ||\\n\\t\\t\\tfunction(callback) {\\n\\t\\t\\t\\treturn window.setTimeout(callback, 1000 / 60);\\n\\t\\t\\t};\\n\\t}());\\n\\t// -- DOM methods\\n\\thelpers.getRelativePosition = function(evt, chart) {\\n\\t\\tvar mouseX, mouseY;\\n\\t\\tvar e = evt.originalEvent || evt,\\n\\t\\t\\tcanvas = evt.currentTarget || evt.srcElement,\\n\\t\\t\\tboundingRect = canvas.getBoundingClientRect();\\n\\n\\t\\tvar touches = e.touches;\\n\\t\\tif (touches && touches.length > 0) {\\n\\t\\t\\tmouseX = touches[0].clientX;\\n\\t\\t\\tmouseY = touches[0].clientY;\\n\\n\\t\\t} else {\\n\\t\\t\\tmouseX = e.clientX;\\n\\t\\t\\tmouseY = e.clientY;\\n\\t\\t}\\n\\n\\t\\t// Scale mouse coordinates into canvas coordinates\\n\\t\\t// by following the pattern laid out by 'jerryj' in the comments of\\n\\t\\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\\n\\t\\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\\n\\t\\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\\n\\t\\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\\n\\t\\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\\n\\t\\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\\n\\t\\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\\n\\n\\t\\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\\n\\t\\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\\n\\t\\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\\n\\t\\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\\n\\n\\t\\treturn {\\n\\t\\t\\tx: mouseX,\\n\\t\\t\\ty: mouseY\\n\\t\\t};\\n\\n\\t};\\n\\thelpers.addEvent = function(node, eventType, method) {\\n\\t\\tif (node.addEventListener) {\\n\\t\\t\\tnode.addEventListener(eventType, method);\\n\\t\\t} else if (node.attachEvent) {\\n\\t\\t\\tnode.attachEvent('on' + eventType, method);\\n\\t\\t} else {\\n\\t\\t\\tnode['on' + eventType] = method;\\n\\t\\t}\\n\\t};\\n\\thelpers.removeEvent = function(node, eventType, handler) {\\n\\t\\tif (node.removeEventListener) {\\n\\t\\t\\tnode.removeEventListener(eventType, handler, false);\\n\\t\\t} else if (node.detachEvent) {\\n\\t\\t\\tnode.detachEvent('on' + eventType, handler);\\n\\t\\t} else {\\n\\t\\t\\tnode['on' + eventType] = helpers.noop;\\n\\t\\t}\\n\\t};\\n\\n\\t// Private helper function to convert max-width/max-height values that may be percentages into a number\\n\\tfunction parseMaxStyle(styleValue, node, parentProperty) {\\n\\t\\tvar valueInPixels;\\n\\t\\tif (typeof(styleValue) === 'string') {\\n\\t\\t\\tvalueInPixels = parseInt(styleValue, 10);\\n\\n\\t\\t\\tif (styleValue.indexOf('%') !== -1) {\\n\\t\\t\\t\\t// percentage * size in dimension\\n\\t\\t\\t\\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tvalueInPixels = styleValue;\\n\\t\\t}\\n\\n\\t\\treturn valueInPixels;\\n\\t}\\n\\n\\t/**\\n\\t * Returns if the given value contains an effective constraint.\\n\\t * @private\\n\\t */\\n\\tfunction isConstrainedValue(value) {\\n\\t\\treturn value !== undefined && value !== null && value !== 'none';\\n\\t}\\n\\n\\t// Private helper to get a constraint dimension\\n\\t// @param domNode : the node to check the constraint on\\n\\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\\n\\t// @param percentageProperty : property of parent to use when calculating width as a percentage\\n\\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\\n\\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\\n\\t\\tvar view = document.defaultView;\\n\\t\\tvar parentNode = domNode.parentNode;\\n\\t\\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\\n\\t\\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\\n\\t\\tvar hasCNode = isConstrainedValue(constrainedNode);\\n\\t\\tvar hasCContainer = isConstrainedValue(constrainedContainer);\\n\\t\\tvar infinity = Number.POSITIVE_INFINITY;\\n\\n\\t\\tif (hasCNode || hasCContainer) {\\n\\t\\t\\treturn Math.min(\\n\\t\\t\\t\\thasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\\n\\t\\t\\t\\thasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\\n\\t\\t}\\n\\n\\t\\treturn 'none';\\n\\t}\\n\\t// returns Number or undefined if no constraint\\n\\thelpers.getConstraintWidth = function(domNode) {\\n\\t\\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\\n\\t};\\n\\t// returns Number or undefined if no constraint\\n\\thelpers.getConstraintHeight = function(domNode) {\\n\\t\\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\\n\\t};\\n\\thelpers.getMaximumWidth = function(domNode) {\\n\\t\\tvar container = domNode.parentNode;\\n\\t\\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\\n\\t\\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\\n\\t\\tvar w = container.clientWidth - paddingLeft - paddingRight;\\n\\t\\tvar cw = helpers.getConstraintWidth(domNode);\\n\\t\\treturn isNaN(cw)? w : Math.min(w, cw);\\n\\t};\\n\\thelpers.getMaximumHeight = function(domNode) {\\n\\t\\tvar container = domNode.parentNode;\\n\\t\\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\\n\\t\\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\\n\\t\\tvar h = container.clientHeight - paddingTop - paddingBottom;\\n\\t\\tvar ch = helpers.getConstraintHeight(domNode);\\n\\t\\treturn isNaN(ch)? h : Math.min(h, ch);\\n\\t};\\n\\thelpers.getStyle = function(el, property) {\\n\\t\\treturn el.currentStyle ?\\n\\t\\t\\tel.currentStyle[property] :\\n\\t\\t\\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\\n\\t};\\n\\thelpers.retinaScale = function(chart) {\\n\\t\\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\\n\\t\\tif (pixelRatio === 1) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar canvas = chart.canvas;\\n\\t\\tvar height = chart.height;\\n\\t\\tvar width = chart.width;\\n\\n\\t\\tcanvas.height = height * pixelRatio;\\n\\t\\tcanvas.width = width * pixelRatio;\\n\\t\\tchart.ctx.scale(pixelRatio, pixelRatio);\\n\\n\\t\\t// If no style has been set on the canvas, the render size is used as display size,\\n\\t\\t// making the chart visually bigger, so let's enforce it to the \\\"correct\\\" values.\\n\\t\\t// See https://github.com/chartjs/Chart.js/issues/3575\\n\\t\\tcanvas.style.height = height + 'px';\\n\\t\\tcanvas.style.width = width + 'px';\\n\\t};\\n\\t// -- Canvas methods\\n\\thelpers.clear = function(chart) {\\n\\t\\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\\n\\t};\\n\\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\\n\\t\\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\\n\\t};\\n\\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\\n\\t\\tcache = cache || {};\\n\\t\\tvar data = cache.data = cache.data || {};\\n\\t\\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\\n\\n\\t\\tif (cache.font !== font) {\\n\\t\\t\\tdata = cache.data = {};\\n\\t\\t\\tgc = cache.garbageCollect = [];\\n\\t\\t\\tcache.font = font;\\n\\t\\t}\\n\\n\\t\\tctx.font = font;\\n\\t\\tvar longest = 0;\\n\\t\\thelpers.each(arrayOfThings, function(thing) {\\n\\t\\t\\t// Undefined strings and arrays should not be measured\\n\\t\\t\\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\\n\\t\\t\\t\\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\\n\\t\\t\\t} else if (helpers.isArray(thing)) {\\n\\t\\t\\t\\t// if it is an array lets measure each element\\n\\t\\t\\t\\t// to do maybe simplify this function a bit so we can do this more recursively?\\n\\t\\t\\t\\thelpers.each(thing, function(nestedThing) {\\n\\t\\t\\t\\t\\t// Undefined strings and arrays should not be measured\\n\\t\\t\\t\\t\\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\\n\\t\\t\\t\\t\\t\\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tvar gcLen = gc.length / 2;\\n\\t\\tif (gcLen > arrayOfThings.length) {\\n\\t\\t\\tfor (var i = 0; i < gcLen; i++) {\\n\\t\\t\\t\\tdelete data[gc[i]];\\n\\t\\t\\t}\\n\\t\\t\\tgc.splice(0, gcLen);\\n\\t\\t}\\n\\t\\treturn longest;\\n\\t};\\n\\thelpers.measureText = function(ctx, data, gc, longest, string) {\\n\\t\\tvar textWidth = data[string];\\n\\t\\tif (!textWidth) {\\n\\t\\t\\ttextWidth = data[string] = ctx.measureText(string).width;\\n\\t\\t\\tgc.push(string);\\n\\t\\t}\\n\\t\\tif (textWidth > longest) {\\n\\t\\t\\tlongest = textWidth;\\n\\t\\t}\\n\\t\\treturn longest;\\n\\t};\\n\\thelpers.numberOfLabelLines = function(arrayOfThings) {\\n\\t\\tvar numberOfLines = 1;\\n\\t\\thelpers.each(arrayOfThings, function(thing) {\\n\\t\\t\\tif (helpers.isArray(thing)) {\\n\\t\\t\\t\\tif (thing.length > numberOfLines) {\\n\\t\\t\\t\\t\\tnumberOfLines = thing.length;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn numberOfLines;\\n\\t};\\n\\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\\n\\t\\tctx.beginPath();\\n\\t\\tctx.moveTo(x + radius, y);\\n\\t\\tctx.lineTo(x + width - radius, y);\\n\\t\\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\\n\\t\\tctx.lineTo(x + width, y + height - radius);\\n\\t\\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\\n\\t\\tctx.lineTo(x + radius, y + height);\\n\\t\\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\\n\\t\\tctx.lineTo(x, y + radius);\\n\\t\\tctx.quadraticCurveTo(x, y, x + radius, y);\\n\\t\\tctx.closePath();\\n\\t};\\n\\thelpers.color = function(c) {\\n\\t\\tif (!color) {\\n\\t\\t\\tconsole.error('Color.js not found!');\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\n\\t\\t/* global CanvasGradient */\\n\\t\\tif (c instanceof CanvasGradient) {\\n\\t\\t\\treturn color(Chart.defaults.global.defaultColor);\\n\\t\\t}\\n\\n\\t\\treturn color(c);\\n\\t};\\n\\thelpers.isArray = Array.isArray?\\n\\t\\tfunction(obj) {\\n\\t\\t\\treturn Array.isArray(obj);\\n\\t\\t} :\\n\\t\\tfunction(obj) {\\n\\t\\t\\treturn Object.prototype.toString.call(obj) === '[object Array]';\\n\\t\\t};\\n\\t// ! @see http://stackoverflow.com/a/14853974\\n\\thelpers.arrayEquals = function(a0, a1) {\\n\\t\\tvar i, ilen, v0, v1;\\n\\n\\t\\tif (!a0 || !a1 || a0.length !== a1.length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tfor (i = 0, ilen=a0.length; i < ilen; ++i) {\\n\\t\\t\\tv0 = a0[i];\\n\\t\\t\\tv1 = a1[i];\\n\\n\\t\\t\\tif (v0 instanceof Array && v1 instanceof Array) {\\n\\t\\t\\t\\tif (!helpers.arrayEquals(v0, v1)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (v0 !== v1) {\\n\\t\\t\\t\\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t};\\n\\thelpers.callCallback = function(fn, args, _tArg) {\\n\\t\\tif (fn && typeof fn.call === 'function') {\\n\\t\\t\\tfn.apply(_tArg, args);\\n\\t\\t}\\n\\t};\\n\\thelpers.getHoverColor = function(colorValue) {\\n\\t\\t/* global CanvasPattern */\\n\\t\\treturn (colorValue instanceof CanvasPattern) ?\\n\\t\\t\\tcolorValue :\\n\\t\\t\\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\\n\\t};\\n};\\n\\n},{\\\"2\\\":2}],27:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\tvar helpers = Chart.helpers;\\n\\n\\t/**\\n\\t * Helper function to get relative position for an event\\n\\t * @param {Event|IEvent} event - The event to get the position for\\n\\t * @param {Chart} chart - The chart\\n\\t * @returns {Point} the event position\\n\\t */\\n\\tfunction getRelativePosition(e, chart) {\\n\\t\\tif (e.native) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: e.x,\\n\\t\\t\\t\\ty: e.y\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn helpers.getRelativePosition(e, chart);\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to traverse all of the visible elements in the chart\\n\\t * @param chart {chart} the chart\\n\\t * @param handler {Function} the callback to execute for each visible item\\n\\t */\\n\\tfunction parseVisibleItems(chart, handler) {\\n\\t\\tvar datasets = chart.data.datasets;\\n\\t\\tvar meta, i, j, ilen, jlen;\\n\\n\\t\\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\\n\\t\\t\\tif (!chart.isDatasetVisible(i)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmeta = chart.getDatasetMeta(i);\\n\\t\\t\\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\\n\\t\\t\\t\\tvar element = meta.data[j];\\n\\t\\t\\t\\tif (!element._view.skip) {\\n\\t\\t\\t\\t\\thandler(element);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to get the items that intersect the event position\\n\\t * @param items {ChartElement[]} elements to filter\\n\\t * @param position {Point} the point to be nearest to\\n\\t * @return {ChartElement[]} the nearest items\\n\\t */\\n\\tfunction getIntersectItems(chart, position) {\\n\\t\\tvar elements = [];\\n\\n\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\telements.push(element);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn elements;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\\n\\t * @param chart {Chart} the chart to look at elements from\\n\\t * @param position {Point} the point to be nearest to\\n\\t * @param intersect {Boolean} if true, only consider items that intersect the position\\n\\t * @param distanceMetric {Function} Optional function to provide the distance between\\n\\t * @return {ChartElement[]} the nearest items\\n\\t */\\n\\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\\n\\t\\tvar minDistance = Number.POSITIVE_INFINITY;\\n\\t\\tvar nearestItems = [];\\n\\n\\t\\tif (!distanceMetric) {\\n\\t\\t\\tdistanceMetric = helpers.distanceBetweenPoints;\\n\\t\\t}\\n\\n\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\tif (intersect && !element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar center = element.getCenterPoint();\\n\\t\\t\\tvar distance = distanceMetric(position, center);\\n\\n\\t\\t\\tif (distance < minDistance) {\\n\\t\\t\\t\\tnearestItems = [element];\\n\\t\\t\\t\\tminDistance = distance;\\n\\t\\t\\t} else if (distance === minDistance) {\\n\\t\\t\\t\\t// Can have multiple items at the same distance in which case we sort by size\\n\\t\\t\\t\\tnearestItems.push(element);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn nearestItems;\\n\\t}\\n\\n\\tfunction indexMode(chart, e, options) {\\n\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\tvar distanceMetric = function(pt1, pt2) {\\n\\t\\t\\treturn Math.abs(pt1.x - pt2.x);\\n\\t\\t};\\n\\t\\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\\n\\t\\tvar elements = [];\\n\\n\\t\\tif (!items.length) {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\n\\t\\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\\n\\t\\t\\tif (chart.isDatasetVisible(datasetIndex)) {\\n\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex),\\n\\t\\t\\t\\t\\telement = meta.data[items[0]._index];\\n\\n\\t\\t\\t\\t// don't count items that are skipped (null data)\\n\\t\\t\\t\\tif (element && !element._view.skip) {\\n\\t\\t\\t\\t\\telements.push(element);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn elements;\\n\\t}\\n\\n\\t/**\\n\\t * @interface IInteractionOptions\\n\\t */\\n\\t/**\\n\\t * If true, only consider items that intersect the point\\n\\t * @name IInterfaceOptions#boolean\\n\\t * @type Boolean\\n\\t */\\n\\n\\t/**\\n\\t * Contains interaction related functions\\n\\t * @namespace Chart.Interaction\\n\\t */\\n\\tChart.Interaction = {\\n\\t\\t// Helper function for different modes\\n\\t\\tmodes: {\\n\\t\\t\\tsingle: function(chart, e) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar elements = [];\\n\\n\\t\\t\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\t\\t\\telements.push(element);\\n\\t\\t\\t\\t\\t\\treturn elements;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\treturn elements.slice(0, 1);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * @function Chart.Interaction.modes.label\\n\\t\\t\\t * @deprecated since version 2.4.0\\n\\t\\t\\t */\\n\\t\\t\\tlabel: indexMode,\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\\n\\t\\t\\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\\n\\t\\t\\t * @function Chart.Interaction.modes.index\\n\\t\\t\\t * @since v2.4.0\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use during interaction\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tindex: indexMode,\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\\n\\t\\t\\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\\n\\t\\t\\t * @function Chart.Interaction.modes.dataset\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use during interaction\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tdataset: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\\n\\n\\t\\t\\t\\tif (items.length > 0) {\\n\\t\\t\\t\\t\\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn items;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * @function Chart.Interaction.modes.x-axis\\n\\t\\t\\t * @deprecated since version 2.4.0. Use index mode and intersect == true\\n\\t\\t\\t */\\n\\t\\t\\t'x-axis': function(chart, e) {\\n\\t\\t\\t\\treturn indexMode(chart, e, true);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Point mode returns all elements that hit test based on the event position\\n\\t\\t\\t * of the event\\n\\t\\t\\t * @function Chart.Interaction.modes.intersect\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tpoint: function(chart, e) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\treturn getIntersectItems(chart, position);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * nearest mode returns the element closest to the point\\n\\t\\t\\t * @function Chart.Interaction.modes.intersect\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tnearest: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar nearestItems = getNearestItems(chart, position, options.intersect);\\n\\n\\t\\t\\t\\t// We have multiple items at the same distance from the event. Now sort by smallest\\n\\t\\t\\t\\tif (nearestItems.length > 1) {\\n\\t\\t\\t\\t\\tnearestItems.sort(function(a, b) {\\n\\t\\t\\t\\t\\t\\tvar sizeA = a.getArea();\\n\\t\\t\\t\\t\\t\\tvar sizeB = b.getArea();\\n\\t\\t\\t\\t\\t\\tvar ret = sizeA - sizeB;\\n\\n\\t\\t\\t\\t\\t\\tif (ret === 0) {\\n\\t\\t\\t\\t\\t\\t\\t// if equal sort by dataset index\\n\\t\\t\\t\\t\\t\\t\\tret = a._datasetIndex - b._datasetIndex;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Return only 1 item\\n\\t\\t\\t\\treturn nearestItems.slice(0, 1);\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * x mode returns the elements that hit-test at the current x coordinate\\n\\t\\t\\t * @function Chart.Interaction.modes.x\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\tx: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar items = [];\\n\\t\\t\\t\\tvar intersectsItem = false;\\n\\n\\t\\t\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\t\\t\\tif (element.inXRange(position.x)) {\\n\\t\\t\\t\\t\\t\\titems.push(element);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\t\\t\\tintersectsItem = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t// If we want to trigger on an intersect and we don't have any items\\n\\t\\t\\t\\t// that intersect the position, return nothing\\n\\t\\t\\t\\tif (options.intersect && !intersectsItem) {\\n\\t\\t\\t\\t\\titems = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn items;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * y mode returns the elements that hit-test at the current y coordinate\\n\\t\\t\\t * @function Chart.Interaction.modes.y\\n\\t\\t\\t * @param chart {chart} the chart we are returning items from\\n\\t\\t\\t * @param e {Event} the event we are find things at\\n\\t\\t\\t * @param options {IInteractionOptions} options to use\\n\\t\\t\\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\\n\\t\\t\\t */\\n\\t\\t\\ty: function(chart, e, options) {\\n\\t\\t\\t\\tvar position = getRelativePosition(e, chart.chart);\\n\\t\\t\\t\\tvar items = [];\\n\\t\\t\\t\\tvar intersectsItem = false;\\n\\n\\t\\t\\t\\tparseVisibleItems(chart, function(element) {\\n\\t\\t\\t\\t\\tif (element.inYRange(position.y)) {\\n\\t\\t\\t\\t\\t\\titems.push(element);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (element.inRange(position.x, position.y)) {\\n\\t\\t\\t\\t\\t\\tintersectsItem = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t// If we want to trigger on an intersect and we don't have any items\\n\\t\\t\\t\\t// that intersect the position, return nothing\\n\\t\\t\\t\\tif (options.intersect && !intersectsItem) {\\n\\t\\t\\t\\t\\titems = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn items;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],28:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function() {\\n\\n\\t// Occupy the global variable of Chart, and create a simple base class\\n\\tvar Chart = function(item, config) {\\n\\t\\tthis.controller = new Chart.Controller(item, config, this);\\n\\t\\treturn this.controller;\\n\\t};\\n\\n\\t// Globally expose the defaults to allow for user updating/changing\\n\\tChart.defaults = {\\n\\t\\tglobal: {\\n\\t\\t\\tresponsive: true,\\n\\t\\t\\tresponsiveAnimationDuration: 0,\\n\\t\\t\\tmaintainAspectRatio: true,\\n\\t\\t\\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\\n\\t\\t\\thover: {\\n\\t\\t\\t\\tonHover: null,\\n\\t\\t\\t\\tmode: 'nearest',\\n\\t\\t\\t\\tintersect: true,\\n\\t\\t\\t\\tanimationDuration: 400\\n\\t\\t\\t},\\n\\t\\t\\tonClick: null,\\n\\t\\t\\tdefaultColor: 'rgba(0,0,0,0.1)',\\n\\t\\t\\tdefaultFontColor: '#666',\\n\\t\\t\\tdefaultFontFamily: \\\"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\\\",\\n\\t\\t\\tdefaultFontSize: 12,\\n\\t\\t\\tdefaultFontStyle: 'normal',\\n\\t\\t\\tshowLines: true,\\n\\n\\t\\t\\t// Element defaults defined in element extensions\\n\\t\\t\\telements: {},\\n\\n\\t\\t\\t// Legend callback string\\n\\t\\t\\tlegendCallback: function(chart) {\\n\\t\\t\\t\\tvar text = [];\\n\\t\\t\\t\\ttext.push('<ul class=\\\"' + chart.id + '-legend\\\">');\\n\\t\\t\\t\\tfor (var i = 0; i < chart.data.datasets.length; i++) {\\n\\t\\t\\t\\t\\ttext.push('<li><span style=\\\"background-color:' + chart.data.datasets[i].backgroundColor + '\\\"></span>');\\n\\t\\t\\t\\t\\tif (chart.data.datasets[i].label) {\\n\\t\\t\\t\\t\\t\\ttext.push(chart.data.datasets[i].label);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttext.push('</li>');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttext.push('</ul>');\\n\\n\\t\\t\\t\\treturn text.join('');\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tChart.Chart = Chart;\\n\\n\\treturn Chart;\\n};\\n\\n},{}],29:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\\n\\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\\n\\t// It is this service's responsibility of carrying out that layout.\\n\\tChart.layoutService = {\\n\\t\\tdefaults: {},\\n\\n\\t\\t// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.\\n\\t\\taddBox: function(chartInstance, box) {\\n\\t\\t\\tif (!chartInstance.boxes) {\\n\\t\\t\\t\\tchartInstance.boxes = [];\\n\\t\\t\\t}\\n\\t\\t\\tchartInstance.boxes.push(box);\\n\\t\\t},\\n\\n\\t\\tremoveBox: function(chartInstance, box) {\\n\\t\\t\\tif (!chartInstance.boxes) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tchartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);\\n\\t\\t},\\n\\n\\t\\t// The most important function\\n\\t\\tupdate: function(chartInstance, width, height) {\\n\\n\\t\\t\\tif (!chartInstance) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar layoutOptions = chartInstance.options.layout;\\n\\t\\t\\tvar padding = layoutOptions ? layoutOptions.padding : null;\\n\\n\\t\\t\\tvar leftPadding = 0;\\n\\t\\t\\tvar rightPadding = 0;\\n\\t\\t\\tvar topPadding = 0;\\n\\t\\t\\tvar bottomPadding = 0;\\n\\n\\t\\t\\tif (!isNaN(padding)) {\\n\\t\\t\\t\\t// options.layout.padding is a number. assign to all\\n\\t\\t\\t\\tleftPadding = padding;\\n\\t\\t\\t\\trightPadding = padding;\\n\\t\\t\\t\\ttopPadding = padding;\\n\\t\\t\\t\\tbottomPadding = padding;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tleftPadding = padding.left || 0;\\n\\t\\t\\t\\trightPadding = padding.right || 0;\\n\\t\\t\\t\\ttopPadding = padding.top || 0;\\n\\t\\t\\t\\tbottomPadding = padding.bottom || 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar leftBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'left';\\n\\t\\t\\t});\\n\\t\\t\\tvar rightBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'right';\\n\\t\\t\\t});\\n\\t\\t\\tvar topBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'top';\\n\\t\\t\\t});\\n\\t\\t\\tvar bottomBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'bottom';\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Boxes that overlay the chartarea such as the radialLinear scale\\n\\t\\t\\tvar chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {\\n\\t\\t\\t\\treturn box.options.position === 'chartArea';\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Ensure that full width boxes are at the very top / bottom\\n\\t\\t\\ttopBoxes.sort(function(a, b) {\\n\\t\\t\\t\\treturn (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);\\n\\t\\t\\t});\\n\\t\\t\\tbottomBoxes.sort(function(a, b) {\\n\\t\\t\\t\\treturn (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Essentially we now have any number of boxes on each of the 4 sides.\\n\\t\\t\\t// Our canvas looks like the following.\\n\\t\\t\\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\\n\\t\\t\\t// B1 is the bottom axis\\n\\t\\t\\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\\n\\t\\t\\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\\n\\t\\t\\t// an error will be thrown.\\n\\t\\t\\t//\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t// |                  T1 (Full Width)                   |\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t// |    |    |                 T2                  |    |\\n\\t\\t\\t// |    |----|-------------------------------------|----|\\n\\t\\t\\t// |    |    | C1 |                           | C2 |    |\\n\\t\\t\\t// |    |    |----|                           |----|    |\\n\\t\\t\\t// |    |    |                                     |    |\\n\\t\\t\\t// | L1 | L2 |           ChartArea (C0)            | R1 |\\n\\t\\t\\t// |    |    |                                     |    |\\n\\t\\t\\t// |    |    |----|                           |----|    |\\n\\t\\t\\t// |    |    | C3 |                           | C4 |    |\\n\\t\\t\\t// |    |----|-------------------------------------|----|\\n\\t\\t\\t// |    |    |                 B1                  |    |\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t// |                  B2 (Full Width)                   |\\n\\t\\t\\t// |----------------------------------------------------|\\n\\t\\t\\t//\\n\\t\\t\\t// What we do to find the best sizing, we do the following\\n\\t\\t\\t// 1. Determine the minimum size of the chart area.\\n\\t\\t\\t// 2. Split the remaining width equally between each vertical axis\\n\\t\\t\\t// 3. Split the remaining height equally between each horizontal axis\\n\\t\\t\\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\\n\\t\\t\\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\\n\\t\\t\\t// 6. Refit each axis\\n\\t\\t\\t// 7. Position each axis in the final location\\n\\t\\t\\t// 8. Tell the chart the final location of the chart area\\n\\t\\t\\t// 9. Tell any axes that overlay the chart area the positions of the chart area\\n\\n\\t\\t\\t// Step 1\\n\\t\\t\\tvar chartWidth = width - leftPadding - rightPadding;\\n\\t\\t\\tvar chartHeight = height - topPadding - bottomPadding;\\n\\t\\t\\tvar chartAreaWidth = chartWidth / 2; // min 50%\\n\\t\\t\\tvar chartAreaHeight = chartHeight / 2; // min 50%\\n\\n\\t\\t\\t// Step 2\\n\\t\\t\\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\\n\\n\\t\\t\\t// Step 3\\n\\t\\t\\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\\n\\n\\t\\t\\t// Step 4\\n\\t\\t\\tvar maxChartAreaWidth = chartWidth;\\n\\t\\t\\tvar maxChartAreaHeight = chartHeight;\\n\\t\\t\\tvar minBoxSizes = [];\\n\\n\\t\\t\\tfunction getMinimumBoxSize(box) {\\n\\t\\t\\t\\tvar minSize;\\n\\t\\t\\t\\tvar isHorizontal = box.isHorizontal();\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tminSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\\n\\t\\t\\t\\t\\tmaxChartAreaHeight -= minSize.height;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\\n\\t\\t\\t\\t\\tmaxChartAreaWidth -= minSize.width;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tminBoxSizes.push({\\n\\t\\t\\t\\t\\thorizontal: isHorizontal,\\n\\t\\t\\t\\t\\tminSize: minSize,\\n\\t\\t\\t\\t\\tbox: box,\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\\n\\n\\t\\t\\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\\n\\t\\t\\tvar maxHorizontalLeftPadding = 0;\\n\\t\\t\\tvar maxHorizontalRightPadding = 0;\\n\\t\\t\\tvar maxVerticalTopPadding = 0;\\n\\t\\t\\tvar maxVerticalBottomPadding = 0;\\n\\n\\t\\t\\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\\n\\t\\t\\t\\tif (horizontalBox.getPadding) {\\n\\t\\t\\t\\t\\tvar boxPadding = horizontalBox.getPadding();\\n\\t\\t\\t\\t\\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\\n\\t\\t\\t\\t\\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\\n\\t\\t\\t\\tif (verticalBox.getPadding) {\\n\\t\\t\\t\\t\\tvar boxPadding = verticalBox.getPadding();\\n\\t\\t\\t\\t\\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\\n\\t\\t\\t\\t\\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\\n\\t\\t\\t// be if the axes are drawn at their minimum sizes.\\n\\t\\t\\t// Steps 5 & 6\\n\\t\\t\\tvar totalLeftBoxesWidth = leftPadding;\\n\\t\\t\\tvar totalRightBoxesWidth = rightPadding;\\n\\t\\t\\tvar totalTopBoxesHeight = topPadding;\\n\\t\\t\\tvar totalBottomBoxesHeight = bottomPadding;\\n\\n\\t\\t\\t// Function to fit a box\\n\\t\\t\\tfunction fitBox(box) {\\n\\t\\t\\t\\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\\n\\t\\t\\t\\t\\treturn minBox.box === box;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (minBoxSize) {\\n\\t\\t\\t\\t\\tif (box.isHorizontal()) {\\n\\t\\t\\t\\t\\t\\tvar scaleMargin = {\\n\\t\\t\\t\\t\\t\\t\\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\\n\\t\\t\\t\\t\\t\\t\\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\\n\\t\\t\\t\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\t\\t\\t\\tbottom: 0\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\\n\\t\\t\\t\\t\\t\\t// on the margin. Sometimes they need to increase in size slightly\\n\\t\\t\\t\\t\\t\\tbox.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update, and calculate the left and right margins for the horizontal boxes\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\\n\\n\\t\\t\\thelpers.each(leftBoxes, function(box) {\\n\\t\\t\\t\\ttotalLeftBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(rightBoxes, function(box) {\\n\\t\\t\\t\\ttotalRightBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Set the Left and Right margins for the horizontal boxes\\n\\t\\t\\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\\n\\n\\t\\t\\t// Figure out how much margin is on the top and bottom of the vertical boxes\\n\\t\\t\\thelpers.each(topBoxes, function(box) {\\n\\t\\t\\t\\ttotalTopBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(bottomBoxes, function(box) {\\n\\t\\t\\t\\ttotalBottomBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\n\\t\\t\\tfunction finalFitVerticalBox(box) {\\n\\t\\t\\t\\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\\n\\t\\t\\t\\t\\treturn minSize.box === box;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tvar scaleMargin = {\\n\\t\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\t\\tright: 0,\\n\\t\\t\\t\\t\\ttop: totalTopBoxesHeight,\\n\\t\\t\\t\\t\\tbottom: totalBottomBoxesHeight\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tif (minBoxSize) {\\n\\t\\t\\t\\t\\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Let the left layout know the final margin\\n\\t\\t\\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\\n\\n\\t\\t\\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\\n\\t\\t\\ttotalLeftBoxesWidth = leftPadding;\\n\\t\\t\\ttotalRightBoxesWidth = rightPadding;\\n\\t\\t\\ttotalTopBoxesHeight = topPadding;\\n\\t\\t\\ttotalBottomBoxesHeight = bottomPadding;\\n\\n\\t\\t\\thelpers.each(leftBoxes, function(box) {\\n\\t\\t\\t\\ttotalLeftBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(rightBoxes, function(box) {\\n\\t\\t\\t\\ttotalRightBoxesWidth += box.width;\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(topBoxes, function(box) {\\n\\t\\t\\t\\ttotalTopBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\t\\t\\thelpers.each(bottomBoxes, function(box) {\\n\\t\\t\\t\\ttotalBottomBoxesHeight += box.height;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// We may be adding some padding to account for rotated x axis labels\\n\\t\\t\\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\\n\\t\\t\\ttotalLeftBoxesWidth += leftPaddingAddition;\\n\\t\\t\\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\\n\\n\\t\\t\\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\\n\\t\\t\\ttotalTopBoxesHeight += topPaddingAddition;\\n\\t\\t\\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\\n\\n\\t\\t\\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\\n\\t\\t\\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\\n\\t\\t\\t// without calling `fit` again\\n\\t\\t\\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\\n\\t\\t\\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\\n\\n\\t\\t\\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\\n\\t\\t\\t\\thelpers.each(leftBoxes, function(box) {\\n\\t\\t\\t\\t\\tbox.height = newMaxChartAreaHeight;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(rightBoxes, function(box) {\\n\\t\\t\\t\\t\\tbox.height = newMaxChartAreaHeight;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(topBoxes, function(box) {\\n\\t\\t\\t\\t\\tif (!box.options.fullWidth) {\\n\\t\\t\\t\\t\\t\\tbox.width = newMaxChartAreaWidth;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(bottomBoxes, function(box) {\\n\\t\\t\\t\\t\\tif (!box.options.fullWidth) {\\n\\t\\t\\t\\t\\t\\tbox.width = newMaxChartAreaWidth;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tmaxChartAreaHeight = newMaxChartAreaHeight;\\n\\t\\t\\t\\tmaxChartAreaWidth = newMaxChartAreaWidth;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Step 7 - Position the boxes\\n\\t\\t\\tvar left = leftPadding + leftPaddingAddition;\\n\\t\\t\\tvar top = topPadding + topPaddingAddition;\\n\\n\\t\\t\\tfunction placeBox(box) {\\n\\t\\t\\t\\tif (box.isHorizontal()) {\\n\\t\\t\\t\\t\\tbox.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;\\n\\t\\t\\t\\t\\tbox.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\\n\\t\\t\\t\\t\\tbox.top = top;\\n\\t\\t\\t\\t\\tbox.bottom = top + box.height;\\n\\n\\t\\t\\t\\t\\t// Move to next point\\n\\t\\t\\t\\t\\ttop = box.bottom;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbox.left = left;\\n\\t\\t\\t\\t\\tbox.right = left + box.width;\\n\\t\\t\\t\\t\\tbox.top = totalTopBoxesHeight;\\n\\t\\t\\t\\t\\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\\n\\n\\t\\t\\t\\t\\t// Move to next point\\n\\t\\t\\t\\t\\tleft = box.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\\n\\n\\t\\t\\t// Account for chart width and height\\n\\t\\t\\tleft += maxChartAreaWidth;\\n\\t\\t\\ttop += maxChartAreaHeight;\\n\\n\\t\\t\\thelpers.each(rightBoxes, placeBox);\\n\\t\\t\\thelpers.each(bottomBoxes, placeBox);\\n\\n\\t\\t\\t// Step 8\\n\\t\\t\\tchartInstance.chartArea = {\\n\\t\\t\\t\\tleft: totalLeftBoxesWidth,\\n\\t\\t\\t\\ttop: totalTopBoxesHeight,\\n\\t\\t\\t\\tright: totalLeftBoxesWidth + maxChartAreaWidth,\\n\\t\\t\\t\\tbottom: totalTopBoxesHeight + maxChartAreaHeight\\n\\t\\t\\t};\\n\\n\\t\\t\\t// Step 9\\n\\t\\t\\thelpers.each(chartAreaBoxes, function(box) {\\n\\t\\t\\t\\tbox.left = chartInstance.chartArea.left;\\n\\t\\t\\t\\tbox.top = chartInstance.chartArea.top;\\n\\t\\t\\t\\tbox.right = chartInstance.chartArea.right;\\n\\t\\t\\t\\tbox.bottom = chartInstance.chartArea.bottom;\\n\\n\\t\\t\\t\\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],30:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar noop = helpers.noop;\\n\\n\\tChart.defaults.global.legend = {\\n\\n\\t\\tdisplay: true,\\n\\t\\tposition: 'top',\\n\\t\\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\\n\\t\\treverse: false,\\n\\n\\t\\t// a callback that will handle\\n\\t\\tonClick: function(e, legendItem) {\\n\\t\\t\\tvar index = legendItem.datasetIndex;\\n\\t\\t\\tvar ci = this.chart;\\n\\t\\t\\tvar meta = ci.getDatasetMeta(index);\\n\\n\\t\\t\\t// See controller.isDatasetVisible comment\\n\\t\\t\\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\\n\\n\\t\\t\\t// We hid a dataset ... rerender the chart\\n\\t\\t\\tci.update();\\n\\t\\t},\\n\\n\\t\\tonHover: null,\\n\\n\\t\\tlabels: {\\n\\t\\t\\tboxWidth: 40,\\n\\t\\t\\tpadding: 10,\\n\\t\\t\\t// Generates labels shown in the legend\\n\\t\\t\\t// Valid properties to return:\\n\\t\\t\\t// text : text to display\\n\\t\\t\\t// fillStyle : fill of coloured box\\n\\t\\t\\t// strokeStyle: stroke of coloured box\\n\\t\\t\\t// hidden : if this legend item refers to a hidden item\\n\\t\\t\\t// lineCap : cap style for line\\n\\t\\t\\t// lineDash\\n\\t\\t\\t// lineDashOffset :\\n\\t\\t\\t// lineJoin :\\n\\t\\t\\t// lineWidth :\\n\\t\\t\\tgenerateLabels: function(chart) {\\n\\t\\t\\t\\tvar data = chart.data;\\n\\t\\t\\t\\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\\n\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\ttext: dataset.label,\\n\\t\\t\\t\\t\\t\\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\\n\\t\\t\\t\\t\\t\\thidden: !chart.isDatasetVisible(i),\\n\\t\\t\\t\\t\\t\\tlineCap: dataset.borderCapStyle,\\n\\t\\t\\t\\t\\t\\tlineDash: dataset.borderDash,\\n\\t\\t\\t\\t\\t\\tlineDashOffset: dataset.borderDashOffset,\\n\\t\\t\\t\\t\\t\\tlineJoin: dataset.borderJoinStyle,\\n\\t\\t\\t\\t\\t\\tlineWidth: dataset.borderWidth,\\n\\t\\t\\t\\t\\t\\tstrokeStyle: dataset.borderColor,\\n\\t\\t\\t\\t\\t\\tpointStyle: dataset.pointStyle,\\n\\n\\t\\t\\t\\t\\t\\t// Below is extra data used for toggling the datasets\\n\\t\\t\\t\\t\\t\\tdatasetIndex: i\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}, this) : [];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Helper function to get the box width based on the usePointStyle option\\n\\t * @param labelopts {Object} the label options on the legend\\n\\t * @param fontSize {Number} the label font size\\n\\t * @return {Number} width of the color box area\\n\\t */\\n\\tfunction getBoxWidth(labelOpts, fontSize) {\\n\\t\\treturn labelOpts.usePointStyle ?\\n\\t\\t\\tfontSize * Math.SQRT2 :\\n\\t\\t\\tlabelOpts.boxWidth;\\n\\t}\\n\\n\\tChart.Legend = Chart.Element.extend({\\n\\n\\t\\tinitialize: function(config) {\\n\\t\\t\\thelpers.extend(this, config);\\n\\n\\t\\t\\t// Contains hit boxes for each dataset (in dataset order)\\n\\t\\t\\tthis.legendHitBoxes = [];\\n\\n\\t\\t\\t// Are we in doughnut mode which has a different data type\\n\\t\\t\\tthis.doughnutMode = false;\\n\\t\\t},\\n\\n\\t\\t// These methods are ordered by lifecycle. Utilities then follow.\\n\\t\\t// Any function defined here is inherited by all legend types.\\n\\t\\t// Any function can be extended by the legend type\\n\\n\\t\\tbeforeUpdate: noop,\\n\\t\\tupdate: function(maxWidth, maxHeight, margins) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\\n\\t\\t\\tme.beforeUpdate();\\n\\n\\t\\t\\t// Absorb the master measurements\\n\\t\\t\\tme.maxWidth = maxWidth;\\n\\t\\t\\tme.maxHeight = maxHeight;\\n\\t\\t\\tme.margins = margins;\\n\\n\\t\\t\\t// Dimensions\\n\\t\\t\\tme.beforeSetDimensions();\\n\\t\\t\\tme.setDimensions();\\n\\t\\t\\tme.afterSetDimensions();\\n\\t\\t\\t// Labels\\n\\t\\t\\tme.beforeBuildLabels();\\n\\t\\t\\tme.buildLabels();\\n\\t\\t\\tme.afterBuildLabels();\\n\\n\\t\\t\\t// Fit\\n\\t\\t\\tme.beforeFit();\\n\\t\\t\\tme.fit();\\n\\t\\t\\tme.afterFit();\\n\\t\\t\\t//\\n\\t\\t\\tme.afterUpdate();\\n\\n\\t\\t\\treturn me.minSize;\\n\\t\\t},\\n\\t\\tafterUpdate: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeSetDimensions: noop,\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\t\\tme.left = 0;\\n\\t\\t\\t\\tme.right = me.width;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.height = me.maxHeight;\\n\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.top = 0;\\n\\t\\t\\t\\tme.bottom = me.height;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset padding\\n\\t\\t\\tme.paddingLeft = 0;\\n\\t\\t\\tme.paddingTop = 0;\\n\\t\\t\\tme.paddingRight = 0;\\n\\t\\t\\tme.paddingBottom = 0;\\n\\n\\t\\t\\t// Reset minSize\\n\\t\\t\\tme.minSize = {\\n\\t\\t\\t\\twidth: 0,\\n\\t\\t\\t\\theight: 0\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tafterSetDimensions: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeBuildLabels: noop,\\n\\t\\tbuildLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar labelOpts = me.options.labels;\\n\\t\\t\\tvar legendItems = labelOpts.generateLabels.call(me, me.chart);\\n\\n\\t\\t\\tif (labelOpts.filter) {\\n\\t\\t\\t\\tlegendItems = legendItems.filter(function(item) {\\n\\t\\t\\t\\t\\treturn labelOpts.filter(item, me.chart.data);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.options.reverse) {\\n\\t\\t\\t\\tlegendItems.reverse();\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.legendItems = legendItems;\\n\\t\\t},\\n\\t\\tafterBuildLabels: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeFit: noop,\\n\\t\\tfit: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar labelOpts = opts.labels;\\n\\t\\t\\tvar display = opts.display;\\n\\n\\t\\t\\tvar ctx = me.ctx;\\n\\n\\t\\t\\tvar globalDefault = Chart.defaults.global,\\n\\t\\t\\t\\titemOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\\n\\t\\t\\t\\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\\n\\t\\t\\t\\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\\n\\t\\t\\t\\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\\n\\n\\t\\t\\t// Reset hit boxes\\n\\t\\t\\tvar hitboxes = me.legendHitBoxes = [];\\n\\n\\t\\t\\tvar minSize = me.minSize;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\tminSize.width = me.maxWidth; // fill all the width\\n\\t\\t\\t\\tminSize.height = display ? 10 : 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.width = display ? 10 : 0;\\n\\t\\t\\t\\tminSize.height = me.maxHeight; // fill all the height\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Increase sizes here\\n\\t\\t\\tif (display) {\\n\\t\\t\\t\\tctx.font = labelFont;\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t// Labels\\n\\n\\t\\t\\t\\t\\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\\n\\t\\t\\t\\t\\tvar lineWidths = me.lineWidths = [0];\\n\\t\\t\\t\\t\\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\\n\\n\\t\\t\\t\\t\\tctx.textAlign = 'left';\\n\\t\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\t\\t\\thelpers.each(me.legendItems, function(legendItem, i) {\\n\\t\\t\\t\\t\\t\\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\\n\\t\\t\\t\\t\\t\\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\\n\\n\\t\\t\\t\\t\\t\\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\\n\\t\\t\\t\\t\\t\\t\\ttotalHeight += fontSize + (labelOpts.padding);\\n\\t\\t\\t\\t\\t\\t\\tlineWidths[lineWidths.length] = me.left;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Store the hitbox width and height here. Final position will be updated in `draw`\\n\\t\\t\\t\\t\\t\\thitboxes[i] = {\\n\\t\\t\\t\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\t\\t\\t\\twidth: width,\\n\\t\\t\\t\\t\\t\\t\\theight: fontSize\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\tminSize.height += totalHeight;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar vPadding = labelOpts.padding;\\n\\t\\t\\t\\t\\tvar columnWidths = me.columnWidths = [];\\n\\t\\t\\t\\t\\tvar totalWidth = labelOpts.padding;\\n\\t\\t\\t\\t\\tvar currentColWidth = 0;\\n\\t\\t\\t\\t\\tvar currentColHeight = 0;\\n\\t\\t\\t\\t\\tvar itemHeight = fontSize + vPadding;\\n\\n\\t\\t\\t\\t\\thelpers.each(me.legendItems, function(legendItem, i) {\\n\\t\\t\\t\\t\\t\\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\\n\\t\\t\\t\\t\\t\\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\\n\\n\\t\\t\\t\\t\\t\\t// If too tall, go to new column\\n\\t\\t\\t\\t\\t\\tif (currentColHeight + itemHeight > minSize.height) {\\n\\t\\t\\t\\t\\t\\t\\ttotalWidth += currentColWidth + labelOpts.padding;\\n\\t\\t\\t\\t\\t\\t\\tcolumnWidths.push(currentColWidth); // previous column width\\n\\n\\t\\t\\t\\t\\t\\t\\tcurrentColWidth = 0;\\n\\t\\t\\t\\t\\t\\t\\tcurrentColHeight = 0;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Get max width\\n\\t\\t\\t\\t\\t\\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\\n\\t\\t\\t\\t\\t\\tcurrentColHeight += itemHeight;\\n\\n\\t\\t\\t\\t\\t\\t// Store the hitbox width and height here. Final position will be updated in `draw`\\n\\t\\t\\t\\t\\t\\thitboxes[i] = {\\n\\t\\t\\t\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\t\\t\\t\\twidth: itemWidth,\\n\\t\\t\\t\\t\\t\\t\\theight: fontSize\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\ttotalWidth += currentColWidth;\\n\\t\\t\\t\\t\\tcolumnWidths.push(currentColWidth);\\n\\t\\t\\t\\t\\tminSize.width += totalWidth;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.width = minSize.width;\\n\\t\\t\\tme.height = minSize.height;\\n\\t\\t},\\n\\t\\tafterFit: noop,\\n\\n\\t\\t// Shared Methods\\n\\t\\tisHorizontal: function() {\\n\\t\\t\\treturn this.options.position === 'top' || this.options.position === 'bottom';\\n\\t\\t},\\n\\n\\t\\t// Actually draw the legend on the canvas\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar labelOpts = opts.labels;\\n\\t\\t\\tvar globalDefault = Chart.defaults.global,\\n\\t\\t\\t\\tlineDefault = globalDefault.elements.line,\\n\\t\\t\\t\\tlegendWidth = me.width,\\n\\t\\t\\t\\tlineWidths = me.lineWidths;\\n\\n\\t\\t\\tif (opts.display) {\\n\\t\\t\\t\\tvar ctx = me.ctx,\\n\\t\\t\\t\\t\\tcursor,\\n\\t\\t\\t\\t\\titemOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\t\\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\\n\\t\\t\\t\\t\\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\\n\\t\\t\\t\\t\\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\\n\\t\\t\\t\\t\\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\\n\\t\\t\\t\\t\\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\\n\\n\\t\\t\\t\\t// Canvas setup\\n\\t\\t\\t\\tctx.textAlign = 'left';\\n\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\t\\t\\t\\tctx.lineWidth = 0.5;\\n\\t\\t\\t\\tctx.strokeStyle = fontColor; // for strikethrough effect\\n\\t\\t\\t\\tctx.fillStyle = fontColor; // render in correct colour\\n\\t\\t\\t\\tctx.font = labelFont;\\n\\n\\t\\t\\t\\tvar boxWidth = getBoxWidth(labelOpts, fontSize),\\n\\t\\t\\t\\t\\thitboxes = me.legendHitBoxes;\\n\\n\\t\\t\\t\\t// current position\\n\\t\\t\\t\\tvar drawLegendBox = function(x, y, legendItem) {\\n\\t\\t\\t\\t\\tif (isNaN(boxWidth) || boxWidth <= 0) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Set the ctx for the box\\n\\t\\t\\t\\t\\tctx.save();\\n\\n\\t\\t\\t\\t\\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\\n\\t\\t\\t\\t\\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\\n\\t\\t\\t\\t\\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\\n\\t\\t\\t\\t\\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\\n\\t\\t\\t\\t\\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\\n\\t\\t\\t\\t\\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\\n\\t\\t\\t\\t\\tvar isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\\n\\n\\t\\t\\t\\t\\tif (ctx.setLineDash) {\\n\\t\\t\\t\\t\\t\\t// IE 9 and 10 do not support line dash\\n\\t\\t\\t\\t\\t\\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (opts.labels && opts.labels.usePointStyle) {\\n\\t\\t\\t\\t\\t\\t// Recalculate x and y for drawPoint() because its expecting\\n\\t\\t\\t\\t\\t\\t// x and y to be center of figure (instead of top left)\\n\\t\\t\\t\\t\\t\\tvar radius = fontSize * Math.SQRT2 / 2;\\n\\t\\t\\t\\t\\t\\tvar offSet = radius / Math.SQRT2;\\n\\t\\t\\t\\t\\t\\tvar centerX = x + offSet;\\n\\t\\t\\t\\t\\t\\tvar centerY = y + offSet;\\n\\n\\t\\t\\t\\t\\t\\t// Draw pointStyle as legend symbol\\n\\t\\t\\t\\t\\t\\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// Draw box as legend symbol\\n\\t\\t\\t\\t\\t\\tif (!isLineWidthZero) {\\n\\t\\t\\t\\t\\t\\t\\tctx.strokeRect(x, y, boxWidth, fontSize);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tctx.fillRect(x, y, boxWidth, fontSize);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tctx.restore();\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tvar fillText = function(x, y, legendItem, textWidth) {\\n\\t\\t\\t\\t\\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\\n\\n\\t\\t\\t\\t\\tif (legendItem.hidden) {\\n\\t\\t\\t\\t\\t\\t// Strikethrough the text if hidden\\n\\t\\t\\t\\t\\t\\tctx.beginPath();\\n\\t\\t\\t\\t\\t\\tctx.lineWidth = 2;\\n\\t\\t\\t\\t\\t\\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\\n\\t\\t\\t\\t\\t\\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\\n\\t\\t\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Horizontal\\n\\t\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tcursor = {\\n\\t\\t\\t\\t\\t\\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\\n\\t\\t\\t\\t\\t\\ty: me.top + labelOpts.padding,\\n\\t\\t\\t\\t\\t\\tline: 0\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcursor = {\\n\\t\\t\\t\\t\\t\\tx: me.left + labelOpts.padding,\\n\\t\\t\\t\\t\\t\\ty: me.top + labelOpts.padding,\\n\\t\\t\\t\\t\\t\\tline: 0\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar itemHeight = fontSize + labelOpts.padding;\\n\\t\\t\\t\\thelpers.each(me.legendItems, function(legendItem, i) {\\n\\t\\t\\t\\t\\tvar textWidth = ctx.measureText(legendItem.text).width,\\n\\t\\t\\t\\t\\t\\twidth = boxWidth + (fontSize / 2) + textWidth,\\n\\t\\t\\t\\t\\t\\tx = cursor.x,\\n\\t\\t\\t\\t\\t\\ty = cursor.y;\\n\\n\\t\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t\\tif (x + width >= legendWidth) {\\n\\t\\t\\t\\t\\t\\t\\ty = cursor.y += itemHeight;\\n\\t\\t\\t\\t\\t\\t\\tcursor.line++;\\n\\t\\t\\t\\t\\t\\t\\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else if (y + itemHeight > me.bottom) {\\n\\t\\t\\t\\t\\t\\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\\n\\t\\t\\t\\t\\t\\ty = cursor.y = me.top + labelOpts.padding;\\n\\t\\t\\t\\t\\t\\tcursor.line++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdrawLegendBox(x, y, legendItem);\\n\\n\\t\\t\\t\\t\\thitboxes[i].left = x;\\n\\t\\t\\t\\t\\thitboxes[i].top = y;\\n\\n\\t\\t\\t\\t\\t// Fill the actual label\\n\\t\\t\\t\\t\\tfillText(x, y, legendItem, textWidth);\\n\\n\\t\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t\\tcursor.x += width + (labelOpts.padding);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcursor.y += itemHeight;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle an event\\n\\t\\t * @private\\n\\t\\t * @param {IEvent} event - The event to handle\\n\\t\\t * @return {Boolean} true if a change occured\\n\\t\\t */\\n\\t\\thandleEvent: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar type = e.type === 'mouseup' ? 'click' : e.type;\\n\\t\\t\\tvar changed = false;\\n\\n\\t\\t\\tif (type === 'mousemove') {\\n\\t\\t\\t\\tif (!opts.onHover) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (type === 'click') {\\n\\t\\t\\t\\tif (!opts.onClick) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Chart event already has relative position in it\\n\\t\\t\\tvar x = e.x,\\n\\t\\t\\t\\ty = e.y;\\n\\n\\t\\t\\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\\n\\t\\t\\t\\t// See if we are touching one of the dataset boxes\\n\\t\\t\\t\\tvar lh = me.legendHitBoxes;\\n\\t\\t\\t\\tfor (var i = 0; i < lh.length; ++i) {\\n\\t\\t\\t\\t\\tvar hitBox = lh[i];\\n\\n\\t\\t\\t\\t\\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\\n\\t\\t\\t\\t\\t\\t// Touching an element\\n\\t\\t\\t\\t\\t\\tif (type === 'click') {\\n\\t\\t\\t\\t\\t\\t\\t// use e.native for backwards compatibility\\n\\t\\t\\t\\t\\t\\t\\topts.onClick.call(me, e.native, me.legendItems[i]);\\n\\t\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t} else if (type === 'mousemove') {\\n\\t\\t\\t\\t\\t\\t\\t// use e.native for backwards compatibility\\n\\t\\t\\t\\t\\t\\t\\topts.onHover.call(me, e.native, me.legendItems[i]);\\n\\t\\t\\t\\t\\t\\t\\tchanged = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn changed;\\n\\t\\t}\\n\\t});\\n\\n\\tfunction createNewLegendAndAttach(chartInstance, legendOpts) {\\n\\t\\tvar legend = new Chart.Legend({\\n\\t\\t\\tctx: chartInstance.chart.ctx,\\n\\t\\t\\toptions: legendOpts,\\n\\t\\t\\tchart: chartInstance\\n\\t\\t});\\n\\t\\tchartInstance.legend = legend;\\n\\t\\tChart.layoutService.addBox(chartInstance, legend);\\n\\t}\\n\\n\\t// Register the legend plugin\\n\\tChart.plugins.register({\\n\\t\\tbeforeInit: function(chartInstance) {\\n\\t\\t\\tvar legendOpts = chartInstance.options.legend;\\n\\n\\t\\t\\tif (legendOpts) {\\n\\t\\t\\t\\tcreateNewLegendAndAttach(chartInstance, legendOpts);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tbeforeUpdate: function(chartInstance) {\\n\\t\\t\\tvar legendOpts = chartInstance.options.legend;\\n\\n\\t\\t\\tif (legendOpts) {\\n\\t\\t\\t\\tlegendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\\n\\n\\t\\t\\t\\tif (chartInstance.legend) {\\n\\t\\t\\t\\t\\tchartInstance.legend.options = legendOpts;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcreateNewLegendAndAttach(chartInstance, legendOpts);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tChart.layoutService.removeBox(chartInstance, chartInstance.legend);\\n\\t\\t\\t\\tdelete chartInstance.legend;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tafterEvent: function(chartInstance, e) {\\n\\t\\t\\tvar legend = chartInstance.legend;\\n\\t\\t\\tif (legend) {\\n\\t\\t\\t\\tlegend.handleEvent(e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],31:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.global.plugins = {};\\n\\n\\t/**\\n\\t * The plugin service singleton\\n\\t * @namespace Chart.plugins\\n\\t * @since 2.1.0\\n\\t */\\n\\tChart.plugins = {\\n\\t\\t/**\\n\\t\\t * Globally registered plugins.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\t_plugins: [],\\n\\n\\t\\t/**\\n\\t\\t * This identifier is used to invalidate the descriptors cache attached to each chart\\n\\t\\t * when a global plugin is registered or unregistered. In this case, the cache ID is\\n\\t\\t * incremented and descriptors are regenerated during following API calls.\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\t_cacheId: 0,\\n\\n\\t\\t/**\\n\\t\\t * Registers the given plugin(s) if not already registered.\\n\\t\\t * @param {Array|Object} plugins plugin instance(s).\\n\\t\\t */\\n\\t\\tregister: function(plugins) {\\n\\t\\t\\tvar p = this._plugins;\\n\\t\\t\\t([]).concat(plugins).forEach(function(plugin) {\\n\\t\\t\\t\\tif (p.indexOf(plugin) === -1) {\\n\\t\\t\\t\\t\\tp.push(plugin);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis._cacheId++;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Unregisters the given plugin(s) only if registered.\\n\\t\\t * @param {Array|Object} plugins plugin instance(s).\\n\\t\\t */\\n\\t\\tunregister: function(plugins) {\\n\\t\\t\\tvar p = this._plugins;\\n\\t\\t\\t([]).concat(plugins).forEach(function(plugin) {\\n\\t\\t\\t\\tvar idx = p.indexOf(plugin);\\n\\t\\t\\t\\tif (idx !== -1) {\\n\\t\\t\\t\\t\\tp.splice(idx, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis._cacheId++;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Remove all registered plugins.\\n\\t\\t * @since 2.1.5\\n\\t\\t */\\n\\t\\tclear: function() {\\n\\t\\t\\tthis._plugins = [];\\n\\t\\t\\tthis._cacheId++;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Returns the number of registered plugins?\\n\\t\\t * @returns {Number}\\n\\t\\t * @since 2.1.5\\n\\t\\t */\\n\\t\\tcount: function() {\\n\\t\\t\\treturn this._plugins.length;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Returns all registered plugin instances.\\n\\t\\t * @returns {Array} array of plugin objects.\\n\\t\\t * @since 2.1.5\\n\\t\\t */\\n\\t\\tgetAll: function() {\\n\\t\\t\\treturn this._plugins;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\\n\\t\\t * This method immediately returns as soon as a plugin explicitly returns false. The\\n\\t\\t * returned value can be used, for instance, to interrupt the current action.\\n\\t\\t * @param {Object} chart - The chart instance for which plugins should be called.\\n\\t\\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\\n\\t\\t * @param {Array} [args] - Extra arguments to apply to the hook call.\\n\\t\\t * @returns {Boolean} false if any of the plugins return false, else returns true.\\n\\t\\t */\\n\\t\\tnotify: function(chart, hook, args) {\\n\\t\\t\\tvar descriptors = this.descriptors(chart);\\n\\t\\t\\tvar ilen = descriptors.length;\\n\\t\\t\\tvar i, descriptor, plugin, params, method;\\n\\n\\t\\t\\tfor (i=0; i<ilen; ++i) {\\n\\t\\t\\t\\tdescriptor = descriptors[i];\\n\\t\\t\\t\\tplugin = descriptor.plugin;\\n\\t\\t\\t\\tmethod = plugin[hook];\\n\\t\\t\\t\\tif (typeof method === 'function') {\\n\\t\\t\\t\\t\\tparams = [chart].concat(args || []);\\n\\t\\t\\t\\t\\tparams.push(descriptor.options);\\n\\t\\t\\t\\t\\tif (method.apply(plugin, params) === false) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Returns descriptors of enabled plugins for the given chart.\\n\\t\\t * @returns {Array} [{ plugin, options }]\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tdescriptors: function(chart) {\\n\\t\\t\\tvar cache = chart._plugins || (chart._plugins = {});\\n\\t\\t\\tif (cache.id === this._cacheId) {\\n\\t\\t\\t\\treturn cache.descriptors;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar plugins = [];\\n\\t\\t\\tvar descriptors = [];\\n\\t\\t\\tvar config = (chart && chart.config) || {};\\n\\t\\t\\tvar defaults = Chart.defaults.global.plugins;\\n\\t\\t\\tvar options = (config.options && config.options.plugins) || {};\\n\\n\\t\\t\\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\\n\\t\\t\\t\\tvar idx = plugins.indexOf(plugin);\\n\\t\\t\\t\\tif (idx !== -1) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar id = plugin.id;\\n\\t\\t\\t\\tvar opts = options[id];\\n\\t\\t\\t\\tif (opts === false) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (opts === true) {\\n\\t\\t\\t\\t\\topts = helpers.clone(defaults[id]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tplugins.push(plugin);\\n\\t\\t\\t\\tdescriptors.push({\\n\\t\\t\\t\\t\\tplugin: plugin,\\n\\t\\t\\t\\t\\toptions: opts || {}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\n\\t\\t\\tcache.descriptors = descriptors;\\n\\t\\t\\tcache.id = this._cacheId;\\n\\t\\t\\treturn descriptors;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Plugin extension hooks.\\n\\t * @interface IPlugin\\n\\t * @since 2.1.0\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeInit\\n\\t * @desc Called before initializing `chart`.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterInit\\n\\t * @desc Called after `chart` has been initialized and before the first update.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeUpdate\\n\\t * @desc Called before updating `chart`. If any plugin returns `false`, the update\\n\\t * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart update.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterUpdate\\n\\t * @desc Called after `chart` has been updated and before rendering. Note that this\\n\\t * hook will not be called if the chart update has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeDatasetsUpdate\\n \\t * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\\n\\t * the datasets update is cancelled until another `update` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} false to cancel the datasets update.\\n\\t * @since version 2.1.5\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterDatasetsUpdate\\n\\t * @desc Called after the `chart` datasets have been updated. Note that this hook\\n\\t * will not be called if the datasets update has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @since version 2.1.5\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeLayout\\n\\t * @desc Called before laying out `chart`. If any plugin returns `false`,\\n\\t * the layout update is cancelled until another `update` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart layout.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterLayout\\n\\t * @desc Called after the `chart` has been layed out. Note that this hook will not\\n\\t * be called if the layout update has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeRender\\n\\t * @desc Called before rendering `chart`. If any plugin returns `false`,\\n\\t * the rendering is cancelled until another `render` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart rendering.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterRender\\n\\t * @desc Called after the `chart` has been fully rendered (and animation completed). Note\\n\\t * that this hook will not be called if the rendering has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeDraw\\n\\t * @desc Called before drawing `chart` at every animation frame specified by the given\\n\\t * easing value. If any plugin returns `false`, the frame drawing is cancelled until\\n\\t * another `render` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart drawing.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterDraw\\n\\t * @desc Called after the `chart` has been drawn for the specific easing value. Note\\n\\t * that this hook will not be called if the drawing has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeDatasetsDraw\\n \\t * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\\n\\t * the datasets drawing is cancelled until another `render` is triggered.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterDatasetsDraw\\n\\t * @desc Called after the `chart` datasets have been drawn. Note that this hook\\n\\t * will not be called if the datasets drawing has been previously cancelled.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#beforeEvent\\n \\t * @desc Called before processing the specified `event`. If any plugin returns `false`,\\n\\t * the event will be discarded.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {IEvent} event - The event object.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#afterEvent\\n\\t * @desc Called after the `event` has been consumed. Note that this hook\\n\\t * will not be called if the `event` has been previously discarded.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {IEvent} event - The event object.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#resize\\n\\t * @desc Called after the chart as been resized.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\t/**\\n\\t * @method IPlugin#destroy\\n\\t * @desc Called after the chart as been destroyed.\\n\\t * @param {Chart.Controller} chart - The chart instance.\\n\\t * @param {Object} options - The plugin options.\\n\\t */\\n\\n\\t/**\\n\\t * Provided for backward compatibility, use Chart.plugins instead\\n\\t * @namespace Chart.pluginService\\n\\t * @deprecated since version 2.1.5\\n\\t * @todo remove at version 3\\n\\t * @private\\n\\t */\\n\\tChart.pluginService = Chart.plugins;\\n\\n\\t/**\\n\\t * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\\n\\t * effect, instead simply create/register plugins via plain JavaScript objects.\\n\\t * @interface Chart.PluginBase\\n\\t * @deprecated since version 2.5.0\\n\\t * @todo remove at version 3\\n\\t * @private\\n\\t */\\n\\tChart.PluginBase = helpers.inherits({});\\n};\\n\\n},{}],32:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.scale = {\\n\\t\\tdisplay: true,\\n\\t\\tposition: 'left',\\n\\n\\t\\t// grid line settings\\n\\t\\tgridLines: {\\n\\t\\t\\tdisplay: true,\\n\\t\\t\\tcolor: 'rgba(0, 0, 0, 0.1)',\\n\\t\\t\\tlineWidth: 1,\\n\\t\\t\\tdrawBorder: true,\\n\\t\\t\\tdrawOnChartArea: true,\\n\\t\\t\\tdrawTicks: true,\\n\\t\\t\\ttickMarkLength: 10,\\n\\t\\t\\tzeroLineWidth: 1,\\n\\t\\t\\tzeroLineColor: 'rgba(0,0,0,0.25)',\\n\\t\\t\\toffsetGridLines: false,\\n\\t\\t\\tborderDash: [],\\n\\t\\t\\tborderDashOffset: 0.0\\n\\t\\t},\\n\\n\\t\\t// scale label\\n\\t\\tscaleLabel: {\\n\\t\\t\\t// actual label\\n\\t\\t\\tlabelString: '',\\n\\n\\t\\t\\t// display property\\n\\t\\t\\tdisplay: false\\n\\t\\t},\\n\\n\\t\\t// label settings\\n\\t\\tticks: {\\n\\t\\t\\tbeginAtZero: false,\\n\\t\\t\\tminRotation: 0,\\n\\t\\t\\tmaxRotation: 50,\\n\\t\\t\\tmirror: false,\\n\\t\\t\\tpadding: 0,\\n\\t\\t\\treverse: false,\\n\\t\\t\\tdisplay: true,\\n\\t\\t\\tautoSkip: true,\\n\\t\\t\\tautoSkipPadding: 0,\\n\\t\\t\\tlabelOffset: 0,\\n\\t\\t\\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\\n\\t\\t\\tcallback: Chart.Ticks.formatters.values\\n\\t\\t}\\n\\t};\\n\\n\\tfunction computeTextSize(context, tick, font) {\\n\\t\\treturn helpers.isArray(tick) ?\\n\\t\\t\\thelpers.longestText(context, font, tick) :\\n\\t\\t\\tcontext.measureText(tick).width;\\n\\t}\\n\\n\\tfunction parseFontOptions(options) {\\n\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\t\\tvar globalDefaults = Chart.defaults.global;\\n\\t\\tvar size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\\n\\t\\tvar style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\\n\\t\\tvar family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\\n\\n\\t\\treturn {\\n\\t\\t\\tsize: size,\\n\\t\\t\\tstyle: style,\\n\\t\\t\\tfamily: family,\\n\\t\\t\\tfont: helpers.fontString(size, style, family)\\n\\t\\t};\\n\\t}\\n\\n\\tChart.Scale = Chart.Element.extend({\\n\\t\\t/**\\n\\t\\t * Get the padding needed for the scale\\n\\t\\t * @method getPadding\\n\\t\\t * @private\\n\\t\\t * @returns {Padding} the necessary padding\\n\\t\\t */\\n\\t\\tgetPadding: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tleft: me.paddingLeft || 0,\\n\\t\\t\\t\\ttop: me.paddingTop || 0,\\n\\t\\t\\t\\tright: me.paddingRight || 0,\\n\\t\\t\\t\\tbottom: me.paddingBottom || 0\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t// These methods are ordered by lifecyle. Utilities then follow.\\n\\t\\t// Any function defined here is inherited by all scale types.\\n\\t\\t// Any function can be extended by the scale type\\n\\n\\t\\tbeforeUpdate: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeUpdate, [this]);\\n\\t\\t},\\n\\t\\tupdate: function(maxWidth, maxHeight, margins) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\\n\\t\\t\\tme.beforeUpdate();\\n\\n\\t\\t\\t// Absorb the master measurements\\n\\t\\t\\tme.maxWidth = maxWidth;\\n\\t\\t\\tme.maxHeight = maxHeight;\\n\\t\\t\\tme.margins = helpers.extend({\\n\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\tright: 0,\\n\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\tbottom: 0\\n\\t\\t\\t}, margins);\\n\\t\\t\\tme.longestTextCache = me.longestTextCache || {};\\n\\n\\t\\t\\t// Dimensions\\n\\t\\t\\tme.beforeSetDimensions();\\n\\t\\t\\tme.setDimensions();\\n\\t\\t\\tme.afterSetDimensions();\\n\\n\\t\\t\\t// Data min/max\\n\\t\\t\\tme.beforeDataLimits();\\n\\t\\t\\tme.determineDataLimits();\\n\\t\\t\\tme.afterDataLimits();\\n\\n\\t\\t\\t// Ticks\\n\\t\\t\\tme.beforeBuildTicks();\\n\\t\\t\\tme.buildTicks();\\n\\t\\t\\tme.afterBuildTicks();\\n\\n\\t\\t\\tme.beforeTickToLabelConversion();\\n\\t\\t\\tme.convertTicksToLabels();\\n\\t\\t\\tme.afterTickToLabelConversion();\\n\\n\\t\\t\\t// Tick Rotation\\n\\t\\t\\tme.beforeCalculateTickRotation();\\n\\t\\t\\tme.calculateTickRotation();\\n\\t\\t\\tme.afterCalculateTickRotation();\\n\\t\\t\\t// Fit\\n\\t\\t\\tme.beforeFit();\\n\\t\\t\\tme.fit();\\n\\t\\t\\tme.afterFit();\\n\\t\\t\\t//\\n\\t\\t\\tme.afterUpdate();\\n\\n\\t\\t\\treturn me.minSize;\\n\\n\\t\\t},\\n\\t\\tafterUpdate: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterUpdate, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\n\\t\\tbeforeSetDimensions: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeSetDimensions, [this]);\\n\\t\\t},\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\t\\tme.left = 0;\\n\\t\\t\\t\\tme.right = me.width;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.height = me.maxHeight;\\n\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.top = 0;\\n\\t\\t\\t\\tme.bottom = me.height;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset padding\\n\\t\\t\\tme.paddingLeft = 0;\\n\\t\\t\\tme.paddingTop = 0;\\n\\t\\t\\tme.paddingRight = 0;\\n\\t\\t\\tme.paddingBottom = 0;\\n\\t\\t},\\n\\t\\tafterSetDimensions: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterSetDimensions, [this]);\\n\\t\\t},\\n\\n\\t\\t// Data limits\\n\\t\\tbeforeDataLimits: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeDataLimits, [this]);\\n\\t\\t},\\n\\t\\tdetermineDataLimits: helpers.noop,\\n\\t\\tafterDataLimits: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterDataLimits, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\t\\tbeforeBuildTicks: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeBuildTicks, [this]);\\n\\t\\t},\\n\\t\\tbuildTicks: helpers.noop,\\n\\t\\tafterBuildTicks: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterBuildTicks, [this]);\\n\\t\\t},\\n\\n\\t\\tbeforeTickToLabelConversion: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Convert ticks to strings\\n\\t\\t\\tvar tickOpts = me.options.ticks;\\n\\t\\t\\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\\n\\t\\t},\\n\\t\\tafterTickToLabelConversion: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterTickToLabelConversion, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\n\\t\\tbeforeCalculateTickRotation: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\\n\\t\\t},\\n\\t\\tcalculateTickRotation: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar context = me.ctx;\\n\\t\\t\\tvar tickOpts = me.options.ticks;\\n\\n\\t\\t\\t// Get the width of each grid by calculating the difference\\n\\t\\t\\t// between x offsets between 0 and 1.\\n\\t\\t\\tvar tickFont = parseFontOptions(tickOpts);\\n\\t\\t\\tcontext.font = tickFont.font;\\n\\n\\t\\t\\tvar labelRotation = tickOpts.minRotation || 0;\\n\\n\\t\\t\\tif (me.options.display && me.isHorizontal()) {\\n\\t\\t\\t\\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\\n\\t\\t\\t\\tvar labelWidth = originalLabelWidth;\\n\\t\\t\\t\\tvar cosRotation;\\n\\t\\t\\t\\tvar sinRotation;\\n\\n\\t\\t\\t\\t// Allow 3 pixels x2 padding either side for label readability\\n\\t\\t\\t\\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\\n\\n\\t\\t\\t\\t// Max label rotation can be set or default to 90 - also act as a loop counter\\n\\t\\t\\t\\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\\n\\t\\t\\t\\t\\tvar angleRadians = helpers.toRadians(labelRotation);\\n\\t\\t\\t\\t\\tcosRotation = Math.cos(angleRadians);\\n\\t\\t\\t\\t\\tsinRotation = Math.sin(angleRadians);\\n\\n\\t\\t\\t\\t\\tif (sinRotation * originalLabelWidth > me.maxHeight) {\\n\\t\\t\\t\\t\\t\\t// go back one step\\n\\t\\t\\t\\t\\t\\tlabelRotation--;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tlabelRotation++;\\n\\t\\t\\t\\t\\tlabelWidth = cosRotation * originalLabelWidth;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.labelRotation = labelRotation;\\n\\t\\t},\\n\\t\\tafterCalculateTickRotation: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterCalculateTickRotation, [this]);\\n\\t\\t},\\n\\n\\t\\t//\\n\\n\\t\\tbeforeFit: function() {\\n\\t\\t\\thelpers.callCallback(this.options.beforeFit, [this]);\\n\\t\\t},\\n\\t\\tfit: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Reset\\n\\t\\t\\tvar minSize = me.minSize = {\\n\\t\\t\\t\\twidth: 0,\\n\\t\\t\\t\\theight: 0\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\tvar scaleLabelOpts = opts.scaleLabel;\\n\\t\\t\\tvar gridLineOpts = opts.gridLines;\\n\\t\\t\\tvar display = opts.display;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tvar tickFont = parseFontOptions(tickOpts);\\n\\t\\t\\tvar scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\\n\\t\\t\\tvar tickMarkLength = opts.gridLines.tickMarkLength;\\n\\n\\t\\t\\t// Width\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t// subtract the margins to line up with the chartArea if we are a full width scale\\n\\t\\t\\t\\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// height\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.height = me.maxHeight; // fill all the height\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Are we showing a title for the scale?\\n\\t\\t\\tif (scaleLabelOpts.display && display) {\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tminSize.height += scaleLabelFontSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tminSize.width += scaleLabelFontSize;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Don't bother fitting the ticks if we are not showing them\\n\\t\\t\\tif (tickOpts.display && display) {\\n\\t\\t\\t\\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\\n\\t\\t\\t\\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\\n\\t\\t\\t\\tvar lineSpace = tickFont.size * 0.5;\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\t// A horizontal axis is more constrained by the height.\\n\\t\\t\\t\\t\\tme.longestLabelWidth = largestTextWidth;\\n\\n\\t\\t\\t\\t\\tvar angleRadians = helpers.toRadians(me.labelRotation);\\n\\t\\t\\t\\t\\tvar cosRotation = Math.cos(angleRadians);\\n\\t\\t\\t\\t\\tvar sinRotation = Math.sin(angleRadians);\\n\\n\\t\\t\\t\\t\\t// TODO - improve this calculation\\n\\t\\t\\t\\t\\tvar labelHeight = (sinRotation * largestTextWidth)\\n\\t\\t\\t\\t\\t\\t+ (tickFont.size * tallestLabelHeightInLines)\\n\\t\\t\\t\\t\\t\\t+ (lineSpace * tallestLabelHeightInLines);\\n\\n\\t\\t\\t\\t\\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\\n\\t\\t\\t\\t\\tme.ctx.font = tickFont.font;\\n\\n\\t\\t\\t\\t\\tvar firstTick = me.ticks[0];\\n\\t\\t\\t\\t\\tvar firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\\n\\n\\t\\t\\t\\t\\tvar lastTick = me.ticks[me.ticks.length - 1];\\n\\t\\t\\t\\t\\tvar lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\\n\\n\\t\\t\\t\\t\\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\\n\\t\\t\\t\\t\\t// by the font height\\n\\t\\t\\t\\t\\tif (me.labelRotation !== 0) {\\n\\t\\t\\t\\t\\t\\tme.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\\n\\t\\t\\t\\t\\t\\tme.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\\n\\t\\t\\t\\t\\t\\tme.paddingRight = lastLabelWidth / 2 + 3;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\\n\\t\\t\\t\\t\\t// Account for padding\\n\\n\\t\\t\\t\\t\\tif (tickOpts.mirror) {\\n\\t\\t\\t\\t\\t\\tlargestTextWidth = 0;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlargestTextWidth += me.options.ticks.padding;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tminSize.width += largestTextWidth;\\n\\t\\t\\t\\t\\tme.paddingTop = tickFont.size / 2;\\n\\t\\t\\t\\t\\tme.paddingBottom = tickFont.size / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.handleMargins();\\n\\n\\t\\t\\tme.width = minSize.width;\\n\\t\\t\\tme.height = minSize.height;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle margins and padding interactions\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\thandleMargins: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.margins) {\\n\\t\\t\\t\\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\\n\\t\\t\\t\\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\\n\\t\\t\\t\\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\\n\\t\\t\\t\\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tafterFit: function() {\\n\\t\\t\\thelpers.callCallback(this.options.afterFit, [this]);\\n\\t\\t},\\n\\n\\t\\t// Shared Methods\\n\\t\\tisHorizontal: function() {\\n\\t\\t\\treturn this.options.position === 'top' || this.options.position === 'bottom';\\n\\t\\t},\\n\\t\\tisFullWidth: function() {\\n\\t\\t\\treturn (this.options.fullWidth);\\n\\t\\t},\\n\\n\\t\\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\\n\\t\\tgetRightValue: function(rawValue) {\\n\\t\\t\\t// Null and undefined values first\\n\\t\\t\\tif (rawValue === null || typeof(rawValue) === 'undefined') {\\n\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t}\\n\\t\\t\\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\\n\\t\\t\\tif (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\\n\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t}\\n\\t\\t\\t// If it is in fact an object, dive in one more level\\n\\t\\t\\tif (typeof(rawValue) === 'object') {\\n\\t\\t\\t\\tif ((rawValue instanceof Date) || (rawValue.isValid)) {\\n\\t\\t\\t\\t\\treturn rawValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Value is good, return it\\n\\t\\t\\treturn rawValue;\\n\\t\\t},\\n\\n\\t\\t// Used to get the value to display in the tooltip for the data at the given index\\n\\t\\t// function getLabelForIndex(index, datasetIndex)\\n\\t\\tgetLabelForIndex: helpers.noop,\\n\\n\\t\\t// Used to get data value locations.  Value can either be an index or a numerical value\\n\\t\\tgetPixelForValue: helpers.noop,\\n\\n\\t\\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\\n\\t\\tgetValueForPixel: helpers.noop,\\n\\n\\t\\t// Used for tick location, should\\n\\t\\tgetPixelForTick: function(index, includeOffset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\\n\\t\\t\\t\\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\\n\\t\\t\\t\\tvar pixel = (tickWidth * index) + me.paddingLeft;\\n\\n\\t\\t\\t\\tif (includeOffset) {\\n\\t\\t\\t\\t\\tpixel += tickWidth / 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar finalVal = me.left + Math.round(pixel);\\n\\t\\t\\t\\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\\n\\t\\t\\t\\treturn finalVal;\\n\\t\\t\\t}\\n\\t\\t\\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\\n\\t\\t\\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));\\n\\t\\t},\\n\\n\\t\\t// Utility for getting the pixel location of a percentage of scale\\n\\t\\tgetPixelForDecimal: function(decimal /* , includeOffset*/) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\\n\\t\\t\\t\\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\\n\\n\\t\\t\\t\\tvar finalVal = me.left + Math.round(valueOffset);\\n\\t\\t\\t\\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\\n\\t\\t\\t\\treturn finalVal;\\n\\t\\t\\t}\\n\\t\\t\\treturn me.top + (decimal * me.height);\\n\\t\\t},\\n\\n\\t\\tgetBasePixel: function() {\\n\\t\\t\\treturn this.getPixelForValue(this.getBaseValue());\\n\\t\\t},\\n\\n\\t\\tgetBaseValue: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar min = me.min;\\n\\t\\t\\tvar max = me.max;\\n\\n\\t\\t\\treturn me.beginAtZero ? 0:\\n\\t\\t\\t\\tmin < 0 && max < 0? max :\\n\\t\\t\\t\\tmin > 0 && max > 0? min :\\n\\t\\t\\t\\t0;\\n\\t\\t},\\n\\n\\t\\t// Actually draw the scale on the canvas\\n\\t\\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\\n\\t\\tdraw: function(chartArea) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me.options;\\n\\t\\t\\tif (!options.display) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar context = me.ctx;\\n\\t\\t\\tvar globalDefaults = Chart.defaults.global;\\n\\t\\t\\tvar optionTicks = options.ticks;\\n\\t\\t\\tvar gridLines = options.gridLines;\\n\\t\\t\\tvar scaleLabel = options.scaleLabel;\\n\\n\\t\\t\\tvar isRotated = me.labelRotation !== 0;\\n\\t\\t\\tvar skipRatio;\\n\\t\\t\\tvar useAutoskipper = optionTicks.autoSkip;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\t// figure out the maximum number of gridlines to show\\n\\t\\t\\tvar maxTicks;\\n\\t\\t\\tif (optionTicks.maxTicksLimit) {\\n\\t\\t\\t\\tmaxTicks = optionTicks.maxTicksLimit;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\tvar tickFont = parseFontOptions(optionTicks);\\n\\n\\t\\t\\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\\n\\t\\t\\tvar borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\\n\\t\\t\\tvar borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\\n\\n\\t\\t\\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\tvar scaleLabelFont = parseFontOptions(scaleLabel);\\n\\n\\t\\t\\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\\n\\t\\t\\tvar cosRotation = Math.cos(labelRotationRadians);\\n\\t\\t\\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\\n\\n\\t\\t\\t// Make sure we draw text in the correct color and font\\n\\t\\t\\tcontext.fillStyle = tickFontColor;\\n\\n\\t\\t\\tvar itemsToDraw = [];\\n\\n\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\tskipRatio = false;\\n\\n\\t\\t\\t\\t// Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\\n\\t\\t\\t\\t// See #2584\\n\\t\\t\\t\\tif (isRotated) {\\n\\t\\t\\t\\t\\tlongestRotatedLabel /= 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\\n\\t\\t\\t\\t\\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if they defined a max number of optionTicks,\\n\\t\\t\\t\\t// increase skipRatio until that number is met\\n\\t\\t\\t\\tif (maxTicks && me.ticks.length > maxTicks) {\\n\\t\\t\\t\\t\\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\\n\\t\\t\\t\\t\\t\\tif (!skipRatio) {\\n\\t\\t\\t\\t\\t\\t\\tskipRatio = 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tskipRatio += 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!useAutoskipper) {\\n\\t\\t\\t\\t\\tskipRatio = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\\n\\t\\t\\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\\n\\t\\t\\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\\n\\t\\t\\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\\n\\n\\t\\t\\thelpers.each(me.ticks, function(label, index) {\\n\\t\\t\\t\\t// If the callback returned a null or undefined value, do not draw this line\\n\\t\\t\\t\\tif (label === undefined || label === null) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar isLastTick = me.ticks.length === index + 1;\\n\\n\\t\\t\\t\\t// Since we always show the last tick,we need may need to hide the last shown one before\\n\\t\\t\\t\\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\\n\\t\\t\\t\\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar lineWidth, lineColor;\\n\\t\\t\\t\\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\\n\\t\\t\\t\\t\\t// Draw the first index specially\\n\\t\\t\\t\\t\\tlineWidth = gridLines.zeroLineWidth;\\n\\t\\t\\t\\t\\tlineColor = gridLines.zeroLineColor;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\\n\\t\\t\\t\\t\\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Common properties\\n\\t\\t\\t\\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\\n\\t\\t\\t\\tvar textAlign = 'middle';\\n\\t\\t\\t\\tvar textBaseline = 'middle';\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\n\\t\\t\\t\\t\\tif (options.position === 'bottom') {\\n\\t\\t\\t\\t\\t\\t// bottom\\n\\t\\t\\t\\t\\t\\ttextBaseline = !isRotated? 'top':'middle';\\n\\t\\t\\t\\t\\t\\ttextAlign = !isRotated? 'center': 'right';\\n\\t\\t\\t\\t\\t\\tlabelY = me.top + tl;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// top\\n\\t\\t\\t\\t\\t\\ttextBaseline = !isRotated? 'bottom':'middle';\\n\\t\\t\\t\\t\\t\\ttextAlign = !isRotated? 'center': 'left';\\n\\t\\t\\t\\t\\t\\tlabelY = me.bottom - tl;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\\n\\t\\t\\t\\t\\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\\n\\n\\t\\t\\t\\t\\ttx1 = tx2 = x1 = x2 = xLineValue;\\n\\t\\t\\t\\t\\tty1 = yTickStart;\\n\\t\\t\\t\\t\\tty2 = yTickEnd;\\n\\t\\t\\t\\t\\ty1 = chartArea.top;\\n\\t\\t\\t\\t\\ty2 = chartArea.bottom;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar isLeft = options.position === 'left';\\n\\t\\t\\t\\t\\tvar tickPadding = optionTicks.padding;\\n\\t\\t\\t\\t\\tvar labelXOffset;\\n\\n\\t\\t\\t\\t\\tif (optionTicks.mirror) {\\n\\t\\t\\t\\t\\t\\ttextAlign = isLeft ? 'left' : 'right';\\n\\t\\t\\t\\t\\t\\tlabelXOffset = tickPadding;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttextAlign = isLeft ? 'right' : 'left';\\n\\t\\t\\t\\t\\t\\tlabelXOffset = tl + tickPadding;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\\n\\n\\t\\t\\t\\t\\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\\n\\t\\t\\t\\t\\tyLineValue += helpers.aliasPixel(lineWidth);\\n\\t\\t\\t\\t\\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\\n\\n\\t\\t\\t\\t\\ttx1 = xTickStart;\\n\\t\\t\\t\\t\\ttx2 = xTickEnd;\\n\\t\\t\\t\\t\\tx1 = chartArea.left;\\n\\t\\t\\t\\t\\tx2 = chartArea.right;\\n\\t\\t\\t\\t\\tty1 = ty2 = y1 = y2 = yLineValue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\titemsToDraw.push({\\n\\t\\t\\t\\t\\ttx1: tx1,\\n\\t\\t\\t\\t\\tty1: ty1,\\n\\t\\t\\t\\t\\ttx2: tx2,\\n\\t\\t\\t\\t\\tty2: ty2,\\n\\t\\t\\t\\t\\tx1: x1,\\n\\t\\t\\t\\t\\ty1: y1,\\n\\t\\t\\t\\t\\tx2: x2,\\n\\t\\t\\t\\t\\ty2: y2,\\n\\t\\t\\t\\t\\tlabelX: labelX,\\n\\t\\t\\t\\t\\tlabelY: labelY,\\n\\t\\t\\t\\t\\tglWidth: lineWidth,\\n\\t\\t\\t\\t\\tglColor: lineColor,\\n\\t\\t\\t\\t\\tglBorderDash: borderDash,\\n\\t\\t\\t\\t\\tglBorderDashOffset: borderDashOffset,\\n\\t\\t\\t\\t\\trotation: -1 * labelRotationRadians,\\n\\t\\t\\t\\t\\tlabel: label,\\n\\t\\t\\t\\t\\ttextBaseline: textBaseline,\\n\\t\\t\\t\\t\\ttextAlign: textAlign\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\\n\\t\\t\\thelpers.each(itemsToDraw, function(itemToDraw) {\\n\\t\\t\\t\\tif (gridLines.display) {\\n\\t\\t\\t\\t\\tcontext.save();\\n\\t\\t\\t\\t\\tcontext.lineWidth = itemToDraw.glWidth;\\n\\t\\t\\t\\t\\tcontext.strokeStyle = itemToDraw.glColor;\\n\\t\\t\\t\\t\\tif (context.setLineDash) {\\n\\t\\t\\t\\t\\t\\tcontext.setLineDash(itemToDraw.glBorderDash);\\n\\t\\t\\t\\t\\t\\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcontext.beginPath();\\n\\n\\t\\t\\t\\t\\tif (gridLines.drawTicks) {\\n\\t\\t\\t\\t\\t\\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\\n\\t\\t\\t\\t\\t\\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (gridLines.drawOnChartArea) {\\n\\t\\t\\t\\t\\t\\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\\n\\t\\t\\t\\t\\t\\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcontext.stroke();\\n\\t\\t\\t\\t\\tcontext.restore();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (optionTicks.display) {\\n\\t\\t\\t\\t\\tcontext.save();\\n\\t\\t\\t\\t\\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\\n\\t\\t\\t\\t\\tcontext.rotate(itemToDraw.rotation);\\n\\t\\t\\t\\t\\tcontext.font = tickFont.font;\\n\\t\\t\\t\\t\\tcontext.textBaseline = itemToDraw.textBaseline;\\n\\t\\t\\t\\t\\tcontext.textAlign = itemToDraw.textAlign;\\n\\n\\t\\t\\t\\t\\tvar label = itemToDraw.label;\\n\\t\\t\\t\\t\\tif (helpers.isArray(label)) {\\n\\t\\t\\t\\t\\t\\tfor (var i = 0, y = 0; i < label.length; ++i) {\\n\\t\\t\\t\\t\\t\\t\\t// We just make sure the multiline element is a string here..\\n\\t\\t\\t\\t\\t\\t\\tcontext.fillText('' + label[i], 0, y);\\n\\t\\t\\t\\t\\t\\t\\t// apply same lineSpacing as calculated @ L#320\\n\\t\\t\\t\\t\\t\\t\\ty += (tickFont.size * 1.5);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.fillText(label, 0, 0);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcontext.restore();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (scaleLabel.display) {\\n\\t\\t\\t\\t// Draw the scale label\\n\\t\\t\\t\\tvar scaleLabelX;\\n\\t\\t\\t\\tvar scaleLabelY;\\n\\t\\t\\t\\tvar rotation = 0;\\n\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\\n\\t\\t\\t\\t\\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar isLeft = options.position === 'left';\\n\\t\\t\\t\\t\\tscaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);\\n\\t\\t\\t\\t\\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\\n\\t\\t\\t\\t\\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcontext.save();\\n\\t\\t\\t\\tcontext.translate(scaleLabelX, scaleLabelY);\\n\\t\\t\\t\\tcontext.rotate(rotation);\\n\\t\\t\\t\\tcontext.textAlign = 'center';\\n\\t\\t\\t\\tcontext.textBaseline = 'middle';\\n\\t\\t\\t\\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\\n\\t\\t\\t\\tcontext.font = scaleLabelFont.font;\\n\\t\\t\\t\\tcontext.fillText(scaleLabel.labelString, 0, 0);\\n\\t\\t\\t\\tcontext.restore();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (gridLines.drawBorder) {\\n\\t\\t\\t\\t// Draw the line at the edge of the axis\\n\\t\\t\\t\\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\\n\\t\\t\\t\\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\\n\\t\\t\\t\\tvar x1 = me.left,\\n\\t\\t\\t\\t\\tx2 = me.right,\\n\\t\\t\\t\\t\\ty1 = me.top,\\n\\t\\t\\t\\t\\ty2 = me.bottom;\\n\\n\\t\\t\\t\\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\\n\\t\\t\\t\\tif (isHorizontal) {\\n\\t\\t\\t\\t\\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\\n\\t\\t\\t\\t\\ty1 += aliasPixel;\\n\\t\\t\\t\\t\\ty2 += aliasPixel;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tx1 = x2 = options.position === 'left' ? me.right : me.left;\\n\\t\\t\\t\\t\\tx1 += aliasPixel;\\n\\t\\t\\t\\t\\tx2 += aliasPixel;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcontext.beginPath();\\n\\t\\t\\t\\tcontext.moveTo(x1, y1);\\n\\t\\t\\t\\tcontext.lineTo(x2, y2);\\n\\t\\t\\t\\tcontext.stroke();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],33:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.scaleService = {\\n\\t\\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\\n\\t\\t// use the new chart options to grab the correct scale\\n\\t\\tconstructors: {},\\n\\t\\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\\n\\t\\t// old browsers\\n\\n\\t\\t// Scale config defaults\\n\\t\\tdefaults: {},\\n\\t\\tregisterScaleType: function(type, scaleConstructor, defaults) {\\n\\t\\t\\tthis.constructors[type] = scaleConstructor;\\n\\t\\t\\tthis.defaults[type] = helpers.clone(defaults);\\n\\t\\t},\\n\\t\\tgetScaleConstructor: function(type) {\\n\\t\\t\\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\\n\\t\\t},\\n\\t\\tgetScaleDefaults: function(type) {\\n\\t\\t\\t// Return the scale defaults merged with the global settings so that we always use the latest ones\\n\\t\\t\\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\\n\\t\\t},\\n\\t\\tupdateScaleDefaults: function(type, additions) {\\n\\t\\t\\tvar defaults = this.defaults;\\n\\t\\t\\tif (defaults.hasOwnProperty(type)) {\\n\\t\\t\\t\\tdefaults[type] = helpers.extend(defaults[type], additions);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\taddScalesToLayout: function(chartInstance) {\\n\\t\\t\\t// Adds each scale to the chart.boxes array to be sized accordingly\\n\\t\\t\\thelpers.each(chartInstance.scales, function(scale) {\\n\\t\\t\\t\\tChart.layoutService.addBox(chartInstance, scale);\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],34:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\t/**\\n\\t * Namespace to hold static tick generation functions\\n\\t * @namespace Chart.Ticks\\n\\t */\\n\\tChart.Ticks = {\\n\\t\\t/**\\n\\t\\t * Namespace to hold generators for different types of ticks\\n\\t\\t * @namespace Chart.Ticks.generators\\n\\t\\t */\\n\\t\\tgenerators: {\\n\\t\\t\\t/**\\n\\t\\t\\t * Interface for the options provided to the numeric tick generator\\n\\t\\t\\t * @interface INumericTickGenerationOptions\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * The maximum number of ticks to display\\n\\t\\t\\t * @name INumericTickGenerationOptions#maxTicks\\n\\t\\t\\t * @type Number\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * The distance between each tick.\\n\\t\\t\\t * @name INumericTickGenerationOptions#stepSize\\n\\t\\t\\t * @type Number\\n\\t\\t\\t * @optional\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\\n\\t\\t\\t * @name INumericTickGenerationOptions#min\\n\\t\\t\\t * @type Number\\n\\t\\t\\t * @optional\\n\\t\\t\\t */\\n\\t\\t\\t/**\\n\\t\\t\\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\\n\\t\\t\\t * @name INumericTickGenerationOptions#max\\n\\t\\t\\t * @type Number\\n\\t\\t\\t * @optional\\n\\t\\t\\t */\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Generate a set of linear ticks\\n\\t\\t\\t * @method Chart.Ticks.generators.linear\\n\\t\\t\\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\\n\\t\\t\\t * @param dataRange {IRange} the range of the data\\n\\t\\t\\t * @returns {Array<Number>} array of tick values\\n\\t\\t\\t */\\n\\t\\t\\tlinear: function(generationOptions, dataRange) {\\n\\t\\t\\t\\tvar ticks = [];\\n\\t\\t\\t\\t// To get a \\\"nice\\\" value for the tick spacing, we will use the appropriately named\\n\\t\\t\\t\\t// \\\"nice number\\\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\\n\\t\\t\\t\\t// for details.\\n\\n\\t\\t\\t\\tvar spacing;\\n\\t\\t\\t\\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\\n\\t\\t\\t\\t\\tspacing = generationOptions.stepSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\\n\\t\\t\\t\\t\\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\\n\\t\\t\\t\\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\\n\\n\\t\\t\\t\\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\\n\\t\\t\\t\\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\\n\\t\\t\\t\\t\\t// If very close to our whole number, use it.\\n\\t\\t\\t\\t\\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\\n\\t\\t\\t\\t\\t\\tniceMin = generationOptions.min;\\n\\t\\t\\t\\t\\t\\tniceMax = generationOptions.max;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar numSpaces = (niceMax - niceMin) / spacing;\\n\\t\\t\\t\\t// If very close to our rounded value, use it.\\n\\t\\t\\t\\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\\n\\t\\t\\t\\t\\tnumSpaces = Math.round(numSpaces);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnumSpaces = Math.ceil(numSpaces);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Put the values into the ticks array\\n\\t\\t\\t\\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\\n\\t\\t\\t\\tfor (var j = 1; j < numSpaces; ++j) {\\n\\t\\t\\t\\t\\tticks.push(niceMin + (j * spacing));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\\n\\n\\t\\t\\t\\treturn ticks;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Generate a set of logarithmic ticks\\n\\t\\t\\t * @method Chart.Ticks.generators.logarithmic\\n\\t\\t\\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\\n\\t\\t\\t * @param dataRange {IRange} the range of the data\\n\\t\\t\\t * @returns {Array<Number>} array of tick values\\n\\t\\t\\t */\\n\\t\\t\\tlogarithmic: function(generationOptions, dataRange) {\\n\\t\\t\\t\\tvar ticks = [];\\n\\t\\t\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\n\\t\\t\\t\\t// Figure out what the max number of ticks we can support it is based on the size of\\n\\t\\t\\t\\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\\n\\t\\t\\t\\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\\n\\t\\t\\t\\t// the graph\\n\\t\\t\\t\\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\\n\\n\\t\\t\\t\\tvar endExp = Math.floor(helpers.log10(dataRange.max));\\n\\t\\t\\t\\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\\n\\t\\t\\t\\tvar exp;\\n\\t\\t\\t\\tvar significand;\\n\\n\\t\\t\\t\\tif (tickVal === 0) {\\n\\t\\t\\t\\t\\texp = Math.floor(helpers.log10(dataRange.minNotZero));\\n\\t\\t\\t\\t\\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\\n\\n\\t\\t\\t\\t\\tticks.push(tickVal);\\n\\t\\t\\t\\t\\ttickVal = significand * Math.pow(10, exp);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\texp = Math.floor(helpers.log10(tickVal));\\n\\t\\t\\t\\t\\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tticks.push(tickVal);\\n\\n\\t\\t\\t\\t\\t++significand;\\n\\t\\t\\t\\t\\tif (significand === 10) {\\n\\t\\t\\t\\t\\t\\tsignificand = 1;\\n\\t\\t\\t\\t\\t\\t++exp;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttickVal = significand * Math.pow(10, exp);\\n\\t\\t\\t\\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\\n\\n\\t\\t\\t\\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\\n\\t\\t\\t\\tticks.push(lastTick);\\n\\n\\t\\t\\t\\treturn ticks;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Namespace to hold formatters for different types of ticks\\n\\t\\t * @namespace Chart.Ticks.formatters\\n\\t\\t */\\n\\t\\tformatters: {\\n\\t\\t\\t/**\\n\\t\\t\\t * Formatter for value labels\\n\\t\\t\\t * @method Chart.Ticks.formatters.values\\n\\t\\t\\t * @param value the value to display\\n\\t\\t\\t * @return {String|Array} the label to display\\n\\t\\t\\t */\\n\\t\\t\\tvalues: function(value) {\\n\\t\\t\\t\\treturn helpers.isArray(value) ? value : '' + value;\\n\\t\\t\\t},\\n\\n\\t\\t\\t/**\\n\\t\\t\\t * Formatter for linear numeric ticks\\n\\t\\t\\t * @method Chart.Ticks.formatters.linear\\n\\t\\t\\t * @param tickValue {Number} the value to be formatted\\n\\t\\t\\t * @param index {Number} the position of the tickValue parameter in the ticks array\\n\\t\\t\\t * @param ticks {Array<Number>} the list of ticks being converted\\n\\t\\t\\t * @return {String} string representation of the tickValue parameter\\n\\t\\t\\t */\\n\\t\\t\\tlinear: function(tickValue, index, ticks) {\\n\\t\\t\\t\\t// If we have lots of ticks, don't use the ones\\n\\t\\t\\t\\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\\n\\n\\t\\t\\t\\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\\n\\t\\t\\t\\tif (Math.abs(delta) > 1) {\\n\\t\\t\\t\\t\\tif (tickValue !== Math.floor(tickValue)) {\\n\\t\\t\\t\\t\\t\\t// not an integer\\n\\t\\t\\t\\t\\t\\tdelta = tickValue - Math.floor(tickValue);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar logDelta = helpers.log10(Math.abs(delta));\\n\\t\\t\\t\\tvar tickString = '';\\n\\n\\t\\t\\t\\tif (tickValue !== 0) {\\n\\t\\t\\t\\t\\tvar numDecimal = -1 * Math.floor(logDelta);\\n\\t\\t\\t\\t\\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\\n\\t\\t\\t\\t\\ttickString = tickValue.toFixed(numDecimal);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttickString = '0'; // never show decimal places for 0\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tickString;\\n\\t\\t\\t},\\n\\n\\t\\t\\tlogarithmic: function(tickValue, index, ticks) {\\n\\t\\t\\t\\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\\n\\n\\t\\t\\t\\tif (tickValue === 0) {\\n\\t\\t\\t\\t\\treturn '0';\\n\\t\\t\\t\\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\\n\\t\\t\\t\\t\\treturn tickValue.toExponential();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn '';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],35:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tChart.defaults.global.title = {\\n\\t\\tdisplay: false,\\n\\t\\tposition: 'top',\\n\\t\\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\\n\\n\\t\\tfontStyle: 'bold',\\n\\t\\tpadding: 10,\\n\\n\\t\\t// actual title\\n\\t\\ttext: ''\\n\\t};\\n\\n\\tvar noop = helpers.noop;\\n\\tChart.Title = Chart.Element.extend({\\n\\n\\t\\tinitialize: function(config) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\thelpers.extend(me, config);\\n\\n\\t\\t\\t// Contains hit boxes for each dataset (in dataset order)\\n\\t\\t\\tme.legendHitBoxes = [];\\n\\t\\t},\\n\\n\\t\\t// These methods are ordered by lifecycle. Utilities then follow.\\n\\n\\t\\tbeforeUpdate: noop,\\n\\t\\tupdate: function(maxWidth, maxHeight, margins) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\\n\\t\\t\\tme.beforeUpdate();\\n\\n\\t\\t\\t// Absorb the master measurements\\n\\t\\t\\tme.maxWidth = maxWidth;\\n\\t\\t\\tme.maxHeight = maxHeight;\\n\\t\\t\\tme.margins = margins;\\n\\n\\t\\t\\t// Dimensions\\n\\t\\t\\tme.beforeSetDimensions();\\n\\t\\t\\tme.setDimensions();\\n\\t\\t\\tme.afterSetDimensions();\\n\\t\\t\\t// Labels\\n\\t\\t\\tme.beforeBuildLabels();\\n\\t\\t\\tme.buildLabels();\\n\\t\\t\\tme.afterBuildLabels();\\n\\n\\t\\t\\t// Fit\\n\\t\\t\\tme.beforeFit();\\n\\t\\t\\tme.fit();\\n\\t\\t\\tme.afterFit();\\n\\t\\t\\t//\\n\\t\\t\\tme.afterUpdate();\\n\\n\\t\\t\\treturn me.minSize;\\n\\n\\t\\t},\\n\\t\\tafterUpdate: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeSetDimensions: noop,\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\t\\tme.left = 0;\\n\\t\\t\\t\\tme.right = me.width;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.height = me.maxHeight;\\n\\n\\t\\t\\t\\t// Reset position before calculating rotation\\n\\t\\t\\t\\tme.top = 0;\\n\\t\\t\\t\\tme.bottom = me.height;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reset padding\\n\\t\\t\\tme.paddingLeft = 0;\\n\\t\\t\\tme.paddingTop = 0;\\n\\t\\t\\tme.paddingRight = 0;\\n\\t\\t\\tme.paddingBottom = 0;\\n\\n\\t\\t\\t// Reset minSize\\n\\t\\t\\tme.minSize = {\\n\\t\\t\\t\\twidth: 0,\\n\\t\\t\\t\\theight: 0\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tafterSetDimensions: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeBuildLabels: noop,\\n\\t\\tbuildLabels: noop,\\n\\t\\tafterBuildLabels: noop,\\n\\n\\t\\t//\\n\\n\\t\\tbeforeFit: noop,\\n\\t\\tfit: function() {\\n\\t\\t\\tvar me = this,\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\topts = me.options,\\n\\t\\t\\t\\tglobalDefaults = Chart.defaults.global,\\n\\t\\t\\t\\tdisplay = opts.display,\\n\\t\\t\\t\\tfontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t\\tminSize = me.minSize;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tminSize.width = me.maxWidth; // fill all the width\\n\\t\\t\\t\\tminSize.height = display ? fontSize + (opts.padding * 2) : 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminSize.width = display ? fontSize + (opts.padding * 2) : 0;\\n\\t\\t\\t\\tminSize.height = me.maxHeight; // fill all the height\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.width = minSize.width;\\n\\t\\t\\tme.height = minSize.height;\\n\\n\\t\\t},\\n\\t\\tafterFit: noop,\\n\\n\\t\\t// Shared Methods\\n\\t\\tisHorizontal: function() {\\n\\t\\t\\tvar pos = this.options.position;\\n\\t\\t\\treturn pos === 'top' || pos === 'bottom';\\n\\t\\t},\\n\\n\\t\\t// Actually draw the title block on the canvas\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this,\\n\\t\\t\\t\\tctx = me.ctx,\\n\\t\\t\\t\\tvalueOrDefault = helpers.getValueOrDefault,\\n\\t\\t\\t\\topts = me.options,\\n\\t\\t\\t\\tglobalDefaults = Chart.defaults.global;\\n\\n\\t\\t\\tif (opts.display) {\\n\\t\\t\\t\\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t\\t\\tfontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\t\\t\\tfontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t\\t\\ttitleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\\n\\t\\t\\t\\t\\trotation = 0,\\n\\t\\t\\t\\t\\ttitleX,\\n\\t\\t\\t\\t\\ttitleY,\\n\\t\\t\\t\\t\\ttop = me.top,\\n\\t\\t\\t\\t\\tleft = me.left,\\n\\t\\t\\t\\t\\tbottom = me.bottom,\\n\\t\\t\\t\\t\\tright = me.right,\\n\\t\\t\\t\\t\\tmaxWidth;\\n\\n\\t\\t\\t\\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\\n\\t\\t\\t\\tctx.font = titleFont;\\n\\n\\t\\t\\t\\t// Horizontal\\n\\t\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t\\ttitleX = left + ((right - left) / 2); // midpoint of the width\\n\\t\\t\\t\\t\\ttitleY = top + ((bottom - top) / 2); // midpoint of the height\\n\\t\\t\\t\\t\\tmaxWidth = right - left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttitleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\\n\\t\\t\\t\\t\\ttitleY = top + ((bottom - top) / 2);\\n\\t\\t\\t\\t\\tmaxWidth = bottom - top;\\n\\t\\t\\t\\t\\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tctx.save();\\n\\t\\t\\t\\tctx.translate(titleX, titleY);\\n\\t\\t\\t\\tctx.rotate(rotation);\\n\\t\\t\\t\\tctx.textAlign = 'center';\\n\\t\\t\\t\\tctx.textBaseline = 'middle';\\n\\t\\t\\t\\tctx.fillText(opts.text, 0, 0, maxWidth);\\n\\t\\t\\t\\tctx.restore();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\n\\tfunction createNewTitleBlockAndAttach(chartInstance, titleOpts) {\\n\\t\\tvar title = new Chart.Title({\\n\\t\\t\\tctx: chartInstance.chart.ctx,\\n\\t\\t\\toptions: titleOpts,\\n\\t\\t\\tchart: chartInstance\\n\\t\\t});\\n\\t\\tchartInstance.titleBlock = title;\\n\\t\\tChart.layoutService.addBox(chartInstance, title);\\n\\t}\\n\\n\\t// Register the title plugin\\n\\tChart.plugins.register({\\n\\t\\tbeforeInit: function(chartInstance) {\\n\\t\\t\\tvar titleOpts = chartInstance.options.title;\\n\\n\\t\\t\\tif (titleOpts) {\\n\\t\\t\\t\\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tbeforeUpdate: function(chartInstance) {\\n\\t\\t\\tvar titleOpts = chartInstance.options.title;\\n\\n\\t\\t\\tif (titleOpts) {\\n\\t\\t\\t\\ttitleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);\\n\\n\\t\\t\\t\\tif (chartInstance.titleBlock) {\\n\\t\\t\\t\\t\\tchartInstance.titleBlock.options = titleOpts;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tChart.layoutService.removeBox(chartInstance, chartInstance.titleBlock);\\n\\t\\t\\t\\tdelete chartInstance.titleBlock;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],36:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\t/**\\n \\t * Helper method to merge the opacity into a color\\n \\t */\\n\\tfunction mergeOpacity(colorString, opacity) {\\n\\t\\tvar color = helpers.color(colorString);\\n\\t\\treturn color.alpha(opacity * color.alpha()).rgbaString();\\n\\t}\\n\\n\\tChart.defaults.global.tooltips = {\\n\\t\\tenabled: true,\\n\\t\\tcustom: null,\\n\\t\\tmode: 'nearest',\\n\\t\\tposition: 'average',\\n\\t\\tintersect: true,\\n\\t\\tbackgroundColor: 'rgba(0,0,0,0.8)',\\n\\t\\ttitleFontStyle: 'bold',\\n\\t\\ttitleSpacing: 2,\\n\\t\\ttitleMarginBottom: 6,\\n\\t\\ttitleFontColor: '#fff',\\n\\t\\ttitleAlign: 'left',\\n\\t\\tbodySpacing: 2,\\n\\t\\tbodyFontColor: '#fff',\\n\\t\\tbodyAlign: 'left',\\n\\t\\tfooterFontStyle: 'bold',\\n\\t\\tfooterSpacing: 2,\\n\\t\\tfooterMarginTop: 6,\\n\\t\\tfooterFontColor: '#fff',\\n\\t\\tfooterAlign: 'left',\\n\\t\\tyPadding: 6,\\n\\t\\txPadding: 6,\\n\\t\\tcaretSize: 5,\\n\\t\\tcornerRadius: 6,\\n\\t\\tmultiKeyBackground: '#fff',\\n\\t\\tdisplayColors: true,\\n\\t\\tcallbacks: {\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tbeforeTitle: helpers.noop,\\n\\t\\t\\ttitle: function(tooltipItems, data) {\\n\\t\\t\\t\\t// Pick first xLabel for now\\n\\t\\t\\t\\tvar title = '';\\n\\t\\t\\t\\tvar labels = data.labels;\\n\\t\\t\\t\\tvar labelCount = labels ? labels.length : 0;\\n\\n\\t\\t\\t\\tif (tooltipItems.length > 0) {\\n\\t\\t\\t\\t\\tvar item = tooltipItems[0];\\n\\n\\t\\t\\t\\t\\tif (item.xLabel) {\\n\\t\\t\\t\\t\\t\\ttitle = item.xLabel;\\n\\t\\t\\t\\t\\t} else if (labelCount > 0 && item.index < labelCount) {\\n\\t\\t\\t\\t\\t\\ttitle = labels[item.index];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn title;\\n\\t\\t\\t},\\n\\t\\t\\tafterTitle: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tbeforeBody: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItem, data)\\n\\t\\t\\tbeforeLabel: helpers.noop,\\n\\t\\t\\tlabel: function(tooltipItem, data) {\\n\\t\\t\\t\\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\\n\\t\\t\\t\\treturn datasetLabel + ': ' + tooltipItem.yLabel;\\n\\t\\t\\t},\\n\\t\\t\\tlabelColor: function(tooltipItem, chartInstance) {\\n\\t\\t\\t\\tvar meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);\\n\\t\\t\\t\\tvar activeElement = meta.data[tooltipItem.index];\\n\\t\\t\\t\\tvar view = activeElement._view;\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tborderColor: view.borderColor,\\n\\t\\t\\t\\t\\tbackgroundColor: view.backgroundColor\\n\\t\\t\\t\\t};\\n\\t\\t\\t},\\n\\t\\t\\tafterLabel: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tafterBody: helpers.noop,\\n\\n\\t\\t\\t// Args are: (tooltipItems, data)\\n\\t\\t\\tbeforeFooter: helpers.noop,\\n\\t\\t\\tfooter: helpers.noop,\\n\\t\\t\\tafterFooter: helpers.noop\\n\\t\\t}\\n\\t};\\n\\n\\t// Helper to push or concat based on if the 2nd parameter is an array or not\\n\\tfunction pushOrConcat(base, toPush) {\\n\\t\\tif (toPush) {\\n\\t\\t\\tif (helpers.isArray(toPush)) {\\n\\t\\t\\t\\t// base = base.concat(toPush);\\n\\t\\t\\t\\tArray.prototype.push.apply(base, toPush);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbase.push(toPush);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn base;\\n\\t}\\n\\n\\t// Private helper to create a tooltip item model\\n\\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\\n\\t// @return : new tooltip item\\n\\tfunction createTooltipItem(element) {\\n\\t\\tvar xScale = element._xScale;\\n\\t\\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\\n\\t\\tvar index = element._index,\\n\\t\\t\\tdatasetIndex = element._datasetIndex;\\n\\n\\t\\treturn {\\n\\t\\t\\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\\n\\t\\t\\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\\n\\t\\t\\tindex: index,\\n\\t\\t\\tdatasetIndex: datasetIndex,\\n\\t\\t\\tx: element._model.x,\\n\\t\\t\\ty: element._model.y\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Helper to get the reset model for the tooltip\\n\\t * @param tooltipOpts {Object} the tooltip options\\n\\t */\\n\\tfunction getBaseModel(tooltipOpts) {\\n\\t\\tvar globalDefaults = Chart.defaults.global;\\n\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\n\\t\\treturn {\\n\\t\\t\\t// Positioning\\n\\t\\t\\txPadding: tooltipOpts.xPadding,\\n\\t\\t\\tyPadding: tooltipOpts.yPadding,\\n\\t\\t\\txAlign: tooltipOpts.xAlign,\\n\\t\\t\\tyAlign: tooltipOpts.yAlign,\\n\\n\\t\\t\\t// Body\\n\\t\\t\\tbodyFontColor: tooltipOpts.bodyFontColor,\\n\\t\\t\\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\t_bodyAlign: tooltipOpts.bodyAlign,\\n\\t\\t\\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\tbodySpacing: tooltipOpts.bodySpacing,\\n\\n\\t\\t\\t// Title\\n\\t\\t\\ttitleFontColor: tooltipOpts.titleFontColor,\\n\\t\\t\\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t_titleAlign: tooltipOpts.titleAlign,\\n\\t\\t\\ttitleSpacing: tooltipOpts.titleSpacing,\\n\\t\\t\\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\\n\\n\\t\\t\\t// Footer\\n\\t\\t\\tfooterFontColor: tooltipOpts.footerFontColor,\\n\\t\\t\\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\\n\\t\\t\\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\\n\\t\\t\\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\\n\\t\\t\\t_footerAlign: tooltipOpts.footerAlign,\\n\\t\\t\\tfooterSpacing: tooltipOpts.footerSpacing,\\n\\t\\t\\tfooterMarginTop: tooltipOpts.footerMarginTop,\\n\\n\\t\\t\\t// Appearance\\n\\t\\t\\tcaretSize: tooltipOpts.caretSize,\\n\\t\\t\\tcornerRadius: tooltipOpts.cornerRadius,\\n\\t\\t\\tbackgroundColor: tooltipOpts.backgroundColor,\\n\\t\\t\\topacity: 0,\\n\\t\\t\\tlegendColorBackground: tooltipOpts.multiKeyBackground,\\n\\t\\t\\tdisplayColors: tooltipOpts.displayColors\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Get the size of the tooltip\\n\\t */\\n\\tfunction getTooltipSize(tooltip, model) {\\n\\t\\tvar ctx = tooltip._chart.ctx;\\n\\n\\t\\tvar height = model.yPadding * 2; // Tooltip Padding\\n\\t\\tvar width = 0;\\n\\n\\t\\t// Count of all lines in the body\\n\\t\\tvar body = model.body;\\n\\t\\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\\n\\t\\t\\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\\n\\t\\t}, 0);\\n\\t\\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\\n\\n\\t\\tvar titleLineCount = model.title.length;\\n\\t\\tvar footerLineCount = model.footer.length;\\n\\t\\tvar titleFontSize = model.titleFontSize,\\n\\t\\t\\tbodyFontSize = model.bodyFontSize,\\n\\t\\t\\tfooterFontSize = model.footerFontSize;\\n\\n\\t\\theight += titleLineCount * titleFontSize; // Title Lines\\n\\t\\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\\n\\t\\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\\n\\t\\theight += combinedBodyLength * bodyFontSize; // Body Lines\\n\\t\\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\\n\\t\\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\\n\\t\\theight += footerLineCount * (footerFontSize); // Footer Lines\\n\\t\\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\\n\\n\\t\\t// Title width\\n\\t\\tvar widthPadding = 0;\\n\\t\\tvar maxLineWidth = function(line) {\\n\\t\\t\\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\\n\\t\\t};\\n\\n\\t\\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\\n\\t\\thelpers.each(model.title, maxLineWidth);\\n\\n\\t\\t// Body width\\n\\t\\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\\n\\t\\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\\n\\n\\t\\t// Body lines may include some extra width due to the color box\\n\\t\\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\\n\\t\\thelpers.each(body, function(bodyItem) {\\n\\t\\t\\thelpers.each(bodyItem.before, maxLineWidth);\\n\\t\\t\\thelpers.each(bodyItem.lines, maxLineWidth);\\n\\t\\t\\thelpers.each(bodyItem.after, maxLineWidth);\\n\\t\\t});\\n\\n\\t\\t// Reset back to 0\\n\\t\\twidthPadding = 0;\\n\\n\\t\\t// Footer width\\n\\t\\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\\n\\t\\thelpers.each(model.footer, maxLineWidth);\\n\\n\\t\\t// Add padding\\n\\t\\twidth += 2 * model.xPadding;\\n\\n\\t\\treturn {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Helper to get the alignment of a tooltip given the size\\n\\t */\\n\\tfunction determineAlignment(tooltip, size) {\\n\\t\\tvar model = tooltip._model;\\n\\t\\tvar chart = tooltip._chart;\\n\\t\\tvar chartArea = tooltip._chartInstance.chartArea;\\n\\t\\tvar xAlign = 'center';\\n\\t\\tvar yAlign = 'center';\\n\\n\\t\\tif (model.y < size.height) {\\n\\t\\t\\tyAlign = 'top';\\n\\t\\t} else if (model.y > (chart.height - size.height)) {\\n\\t\\t\\tyAlign = 'bottom';\\n\\t\\t}\\n\\n\\t\\tvar lf, rf; // functions to determine left, right alignment\\n\\t\\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\\n\\t\\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\\n\\t\\tvar midX = (chartArea.left + chartArea.right) / 2;\\n\\t\\tvar midY = (chartArea.top + chartArea.bottom) / 2;\\n\\n\\t\\tif (yAlign === 'center') {\\n\\t\\t\\tlf = function(x) {\\n\\t\\t\\t\\treturn x <= midX;\\n\\t\\t\\t};\\n\\t\\t\\trf = function(x) {\\n\\t\\t\\t\\treturn x > midX;\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tlf = function(x) {\\n\\t\\t\\t\\treturn x <= (size.width / 2);\\n\\t\\t\\t};\\n\\t\\t\\trf = function(x) {\\n\\t\\t\\t\\treturn x >= (chart.width - (size.width / 2));\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tolf = function(x) {\\n\\t\\t\\treturn x + size.width > chart.width;\\n\\t\\t};\\n\\t\\torf = function(x) {\\n\\t\\t\\treturn x - size.width < 0;\\n\\t\\t};\\n\\t\\tyf = function(y) {\\n\\t\\t\\treturn y <= midY ? 'top' : 'bottom';\\n\\t\\t};\\n\\n\\t\\tif (lf(model.x)) {\\n\\t\\t\\txAlign = 'left';\\n\\n\\t\\t\\t// Is tooltip too wide and goes over the right side of the chart.?\\n\\t\\t\\tif (olf(model.x)) {\\n\\t\\t\\t\\txAlign = 'center';\\n\\t\\t\\t\\tyAlign = yf(model.y);\\n\\t\\t\\t}\\n\\t\\t} else if (rf(model.x)) {\\n\\t\\t\\txAlign = 'right';\\n\\n\\t\\t\\t// Is tooltip too wide and goes outside left edge of canvas?\\n\\t\\t\\tif (orf(model.x)) {\\n\\t\\t\\t\\txAlign = 'center';\\n\\t\\t\\t\\tyAlign = yf(model.y);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar opts = tooltip._options;\\n\\t\\treturn {\\n\\t\\t\\txAlign: opts.xAlign ? opts.xAlign : xAlign,\\n\\t\\t\\tyAlign: opts.yAlign ? opts.yAlign : yAlign\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\\n\\t */\\n\\tfunction getBackgroundPoint(vm, size, alignment) {\\n\\t\\t// Background Position\\n\\t\\tvar x = vm.x;\\n\\t\\tvar y = vm.y;\\n\\n\\t\\tvar caretSize = vm.caretSize,\\n\\t\\t\\tcaretPadding = vm.caretPadding,\\n\\t\\t\\tcornerRadius = vm.cornerRadius,\\n\\t\\t\\txAlign = alignment.xAlign,\\n\\t\\t\\tyAlign = alignment.yAlign,\\n\\t\\t\\tpaddingAndSize = caretSize + caretPadding,\\n\\t\\t\\tradiusAndPadding = cornerRadius + caretPadding;\\n\\n\\t\\tif (xAlign === 'right') {\\n\\t\\t\\tx -= size.width;\\n\\t\\t} else if (xAlign === 'center') {\\n\\t\\t\\tx -= (size.width / 2);\\n\\t\\t}\\n\\n\\t\\tif (yAlign === 'top') {\\n\\t\\t\\ty += paddingAndSize;\\n\\t\\t} else if (yAlign === 'bottom') {\\n\\t\\t\\ty -= size.height + paddingAndSize;\\n\\t\\t} else {\\n\\t\\t\\ty -= (size.height / 2);\\n\\t\\t}\\n\\n\\t\\tif (yAlign === 'center') {\\n\\t\\t\\tif (xAlign === 'left') {\\n\\t\\t\\t\\tx += paddingAndSize;\\n\\t\\t\\t} else if (xAlign === 'right') {\\n\\t\\t\\t\\tx -= paddingAndSize;\\n\\t\\t\\t}\\n\\t\\t} else if (xAlign === 'left') {\\n\\t\\t\\tx -= radiusAndPadding;\\n\\t\\t} else if (xAlign === 'right') {\\n\\t\\t\\tx += radiusAndPadding;\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tx: x,\\n\\t\\t\\ty: y\\n\\t\\t};\\n\\t}\\n\\n\\tChart.Tooltip = Chart.Element.extend({\\n\\t\\tinitialize: function() {\\n\\t\\t\\tthis._model = getBaseModel(this._options);\\n\\t\\t},\\n\\n\\t\\t// Get the title\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetTitle: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me._options;\\n\\t\\t\\tvar callbacks = opts.callbacks;\\n\\n\\t\\t\\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),\\n\\t\\t\\t\\ttitle = callbacks.title.apply(me, arguments),\\n\\t\\t\\t\\tafterTitle = callbacks.afterTitle.apply(me, arguments);\\n\\n\\t\\t\\tvar lines = [];\\n\\t\\t\\tlines = pushOrConcat(lines, beforeTitle);\\n\\t\\t\\tlines = pushOrConcat(lines, title);\\n\\t\\t\\tlines = pushOrConcat(lines, afterTitle);\\n\\n\\t\\t\\treturn lines;\\n\\t\\t},\\n\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetBeforeBody: function() {\\n\\t\\t\\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\\n\\t\\t\\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\\n\\t\\t},\\n\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetBody: function(tooltipItems, data) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar callbacks = me._options.callbacks;\\n\\t\\t\\tvar bodyItems = [];\\n\\n\\t\\t\\thelpers.each(tooltipItems, function(tooltipItem) {\\n\\t\\t\\t\\tvar bodyItem = {\\n\\t\\t\\t\\t\\tbefore: [],\\n\\t\\t\\t\\t\\tlines: [],\\n\\t\\t\\t\\t\\tafter: []\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\\n\\t\\t\\t\\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\\n\\t\\t\\t\\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\\n\\n\\t\\t\\t\\tbodyItems.push(bodyItem);\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn bodyItems;\\n\\t\\t},\\n\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetAfterBody: function() {\\n\\t\\t\\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\\n\\t\\t\\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\\n\\t\\t},\\n\\n\\t\\t// Get the footer and beforeFooter and afterFooter lines\\n\\t\\t// Args are: (tooltipItem, data)\\n\\t\\tgetFooter: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar callbacks = me._options.callbacks;\\n\\n\\t\\t\\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\\n\\t\\t\\tvar footer = callbacks.footer.apply(me, arguments);\\n\\t\\t\\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\\n\\n\\t\\t\\tvar lines = [];\\n\\t\\t\\tlines = pushOrConcat(lines, beforeFooter);\\n\\t\\t\\tlines = pushOrConcat(lines, footer);\\n\\t\\t\\tlines = pushOrConcat(lines, afterFooter);\\n\\n\\t\\t\\treturn lines;\\n\\t\\t},\\n\\n\\t\\tupdate: function(changed) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me._options;\\n\\n\\t\\t\\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\\n\\t\\t\\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\\n\\t\\t\\t// which breaks any animations.\\n\\t\\t\\tvar existingModel = me._model;\\n\\t\\t\\tvar model = me._model = getBaseModel(opts);\\n\\t\\t\\tvar active = me._active;\\n\\n\\t\\t\\tvar data = me._data;\\n\\t\\t\\tvar chartInstance = me._chartInstance;\\n\\n\\t\\t\\t// In the case where active.length === 0 we need to keep these at existing values for good animations\\n\\t\\t\\tvar alignment = {\\n\\t\\t\\t\\txAlign: existingModel.xAlign,\\n\\t\\t\\t\\tyAlign: existingModel.yAlign\\n\\t\\t\\t};\\n\\t\\t\\tvar backgroundPoint = {\\n\\t\\t\\t\\tx: existingModel.x,\\n\\t\\t\\t\\ty: existingModel.y\\n\\t\\t\\t};\\n\\t\\t\\tvar tooltipSize = {\\n\\t\\t\\t\\twidth: existingModel.width,\\n\\t\\t\\t\\theight: existingModel.height\\n\\t\\t\\t};\\n\\t\\t\\tvar tooltipPosition = {\\n\\t\\t\\t\\tx: existingModel.caretX,\\n\\t\\t\\t\\ty: existingModel.caretY\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar i, len;\\n\\n\\t\\t\\tif (active.length) {\\n\\t\\t\\t\\tmodel.opacity = 1;\\n\\n\\t\\t\\t\\tvar labelColors = [];\\n\\t\\t\\t\\ttooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\\n\\n\\t\\t\\t\\tvar tooltipItems = [];\\n\\t\\t\\t\\tfor (i = 0, len = active.length; i < len; ++i) {\\n\\t\\t\\t\\t\\ttooltipItems.push(createTooltipItem(active[i]));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the user provided a filter function, use it to modify the tooltip items\\n\\t\\t\\t\\tif (opts.filter) {\\n\\t\\t\\t\\t\\ttooltipItems = tooltipItems.filter(function(a) {\\n\\t\\t\\t\\t\\t\\treturn opts.filter(a, data);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the user provided a sorting function, use it to modify the tooltip items\\n\\t\\t\\t\\tif (opts.itemSort) {\\n\\t\\t\\t\\t\\ttooltipItems = tooltipItems.sort(function(a, b) {\\n\\t\\t\\t\\t\\t\\treturn opts.itemSort(a, b, data);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Determine colors for boxes\\n\\t\\t\\t\\thelpers.each(tooltipItems, function(tooltipItem) {\\n\\t\\t\\t\\t\\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t// Build the Text Lines\\n\\t\\t\\t\\tmodel.title = me.getTitle(tooltipItems, data);\\n\\t\\t\\t\\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\\n\\t\\t\\t\\tmodel.body = me.getBody(tooltipItems, data);\\n\\t\\t\\t\\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\\n\\t\\t\\t\\tmodel.footer = me.getFooter(tooltipItems, data);\\n\\n\\t\\t\\t\\t// Initial positioning and colors\\n\\t\\t\\t\\tmodel.x = Math.round(tooltipPosition.x);\\n\\t\\t\\t\\tmodel.y = Math.round(tooltipPosition.y);\\n\\t\\t\\t\\tmodel.caretPadding = helpers.getValueOrDefault(tooltipPosition.padding, 2);\\n\\t\\t\\t\\tmodel.labelColors = labelColors;\\n\\n\\t\\t\\t\\t// data points\\n\\t\\t\\t\\tmodel.dataPoints = tooltipItems;\\n\\n\\t\\t\\t\\t// We need to determine alignment of the tooltip\\n\\t\\t\\t\\ttooltipSize = getTooltipSize(this, model);\\n\\t\\t\\t\\talignment = determineAlignment(this, tooltipSize);\\n\\t\\t\\t\\t// Final Size and Position\\n\\t\\t\\t\\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmodel.opacity = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tmodel.xAlign = alignment.xAlign;\\n\\t\\t\\tmodel.yAlign = alignment.yAlign;\\n\\t\\t\\tmodel.x = backgroundPoint.x;\\n\\t\\t\\tmodel.y = backgroundPoint.y;\\n\\t\\t\\tmodel.width = tooltipSize.width;\\n\\t\\t\\tmodel.height = tooltipSize.height;\\n\\n\\t\\t\\t// Point where the caret on the tooltip points to\\n\\t\\t\\tmodel.caretX = tooltipPosition.x;\\n\\t\\t\\tmodel.caretY = tooltipPosition.y;\\n\\n\\t\\t\\tme._model = model;\\n\\n\\t\\t\\tif (changed && opts.custom) {\\n\\t\\t\\t\\topts.custom.call(me, model);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn me;\\n\\t\\t},\\n\\t\\tdrawCaret: function(tooltipPoint, size, opacity) {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar x1, x2, x3;\\n\\t\\t\\tvar y1, y2, y3;\\n\\t\\t\\tvar caretSize = vm.caretSize;\\n\\t\\t\\tvar cornerRadius = vm.cornerRadius;\\n\\t\\t\\tvar xAlign = vm.xAlign,\\n\\t\\t\\t\\tyAlign = vm.yAlign;\\n\\t\\t\\tvar ptX = tooltipPoint.x,\\n\\t\\t\\t\\tptY = tooltipPoint.y;\\n\\t\\t\\tvar width = size.width,\\n\\t\\t\\t\\theight = size.height;\\n\\n\\t\\t\\tif (yAlign === 'center') {\\n\\t\\t\\t\\t// Left or right side\\n\\t\\t\\t\\tif (xAlign === 'left') {\\n\\t\\t\\t\\t\\tx1 = ptX;\\n\\t\\t\\t\\t\\tx2 = x1 - caretSize;\\n\\t\\t\\t\\t\\tx3 = x1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tx1 = ptX + width;\\n\\t\\t\\t\\t\\tx2 = x1 + caretSize;\\n\\t\\t\\t\\t\\tx3 = x1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ty2 = ptY + (height / 2);\\n\\t\\t\\t\\ty1 = y2 - caretSize;\\n\\t\\t\\t\\ty3 = y2 + caretSize;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (xAlign === 'left') {\\n\\t\\t\\t\\t\\tx1 = ptX + cornerRadius;\\n\\t\\t\\t\\t\\tx2 = x1 + caretSize;\\n\\t\\t\\t\\t\\tx3 = x2 + caretSize;\\n\\t\\t\\t\\t} else if (xAlign === 'right') {\\n\\t\\t\\t\\t\\tx1 = ptX + width - cornerRadius;\\n\\t\\t\\t\\t\\tx2 = x1 - caretSize;\\n\\t\\t\\t\\t\\tx3 = x2 - caretSize;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tx2 = ptX + (width / 2);\\n\\t\\t\\t\\t\\tx1 = x2 - caretSize;\\n\\t\\t\\t\\t\\tx3 = x2 + caretSize;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (yAlign === 'top') {\\n\\t\\t\\t\\t\\ty1 = ptY;\\n\\t\\t\\t\\t\\ty2 = y1 - caretSize;\\n\\t\\t\\t\\t\\ty3 = y1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ty1 = ptY + height;\\n\\t\\t\\t\\t\\ty2 = y1 + caretSize;\\n\\t\\t\\t\\t\\ty3 = y1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.moveTo(x1, y1);\\n\\t\\t\\tctx.lineTo(x2, y2);\\n\\t\\t\\tctx.lineTo(x3, y3);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.fill();\\n\\t\\t},\\n\\t\\tdrawTitle: function(pt, vm, ctx, opacity) {\\n\\t\\t\\tvar title = vm.title;\\n\\n\\t\\t\\tif (title.length) {\\n\\t\\t\\t\\tctx.textAlign = vm._titleAlign;\\n\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\t\\tvar titleFontSize = vm.titleFontSize,\\n\\t\\t\\t\\t\\ttitleSpacing = vm.titleSpacing;\\n\\n\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\\n\\t\\t\\t\\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\\n\\n\\t\\t\\t\\tvar i, len;\\n\\t\\t\\t\\tfor (i = 0, len = title.length; i < len; ++i) {\\n\\t\\t\\t\\t\\tctx.fillText(title[i], pt.x, pt.y);\\n\\t\\t\\t\\t\\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\\n\\n\\t\\t\\t\\t\\tif (i + 1 === title.length) {\\n\\t\\t\\t\\t\\t\\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tdrawBody: function(pt, vm, ctx, opacity) {\\n\\t\\t\\tvar bodyFontSize = vm.bodyFontSize;\\n\\t\\t\\tvar bodySpacing = vm.bodySpacing;\\n\\t\\t\\tvar body = vm.body;\\n\\n\\t\\t\\tctx.textAlign = vm._bodyAlign;\\n\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\tvar textColor = mergeOpacity(vm.bodyFontColor, opacity);\\n\\t\\t\\tctx.fillStyle = textColor;\\n\\t\\t\\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\\n\\n\\t\\t\\t// Before Body\\n\\t\\t\\tvar xLinePadding = 0;\\n\\t\\t\\tvar fillLineOfText = function(line) {\\n\\t\\t\\t\\tctx.fillText(line, pt.x + xLinePadding, pt.y);\\n\\t\\t\\t\\tpt.y += bodyFontSize + bodySpacing;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// Before body lines\\n\\t\\t\\thelpers.each(vm.beforeBody, fillLineOfText);\\n\\n\\t\\t\\tvar drawColorBoxes = vm.displayColors;\\n\\t\\t\\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\\n\\n\\t\\t\\t// Draw body lines now\\n\\t\\t\\thelpers.each(body, function(bodyItem, i) {\\n\\t\\t\\t\\thelpers.each(bodyItem.before, fillLineOfText);\\n\\n\\t\\t\\t\\thelpers.each(bodyItem.lines, function(line) {\\n\\t\\t\\t\\t\\t// Draw Legend-like boxes if needed\\n\\t\\t\\t\\t\\tif (drawColorBoxes) {\\n\\t\\t\\t\\t\\t\\t// Fill a white rect so that colours merge nicely if the opacity is < 1\\n\\t\\t\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\\n\\t\\t\\t\\t\\t\\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\\n\\n\\t\\t\\t\\t\\t\\t// Border\\n\\t\\t\\t\\t\\t\\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\\n\\t\\t\\t\\t\\t\\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\\n\\n\\t\\t\\t\\t\\t\\t// Inner square\\n\\t\\t\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\\n\\t\\t\\t\\t\\t\\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\\n\\n\\t\\t\\t\\t\\t\\tctx.fillStyle = textColor;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfillLineOfText(line);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(bodyItem.after, fillLineOfText);\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Reset back to 0 for after body\\n\\t\\t\\txLinePadding = 0;\\n\\n\\t\\t\\t// After body lines\\n\\t\\t\\thelpers.each(vm.afterBody, fillLineOfText);\\n\\t\\t\\tpt.y -= bodySpacing; // Remove last body spacing\\n\\t\\t},\\n\\t\\tdrawFooter: function(pt, vm, ctx, opacity) {\\n\\t\\t\\tvar footer = vm.footer;\\n\\n\\t\\t\\tif (footer.length) {\\n\\t\\t\\t\\tpt.y += vm.footerMarginTop;\\n\\n\\t\\t\\t\\tctx.textAlign = vm._footerAlign;\\n\\t\\t\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\t\\t\\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\\n\\t\\t\\t\\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\\n\\n\\t\\t\\t\\thelpers.each(footer, function(line) {\\n\\t\\t\\t\\t\\tctx.fillText(line, pt.x, pt.y);\\n\\t\\t\\t\\t\\tpt.y += vm.footerFontSize + vm.footerSpacing;\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\\n\\t\\t\\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\\n\\t\\t\\thelpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);\\n\\t\\t\\tctx.fill();\\n\\t\\t},\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tif (vm.opacity === 0) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar tooltipSize = {\\n\\t\\t\\t\\twidth: vm.width,\\n\\t\\t\\t\\theight: vm.height\\n\\t\\t\\t};\\n\\t\\t\\tvar pt = {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y\\n\\t\\t\\t};\\n\\n\\t\\t\\t// IE11/Edge does not like very small opacities, so snap to 0\\n\\t\\t\\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\\n\\n\\t\\t\\tif (this._options.enabled) {\\n\\t\\t\\t\\t// Draw Background\\n\\t\\t\\t\\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\\n\\n\\t\\t\\t\\t// Draw Caret\\n\\t\\t\\t\\tthis.drawCaret(pt, tooltipSize, opacity);\\n\\n\\t\\t\\t\\t// Draw Title, Body, and Footer\\n\\t\\t\\t\\tpt.x += vm.xPadding;\\n\\t\\t\\t\\tpt.y += vm.yPadding;\\n\\n\\t\\t\\t\\t// Titles\\n\\t\\t\\t\\tthis.drawTitle(pt, vm, ctx, opacity);\\n\\n\\t\\t\\t\\t// Body\\n\\t\\t\\t\\tthis.drawBody(pt, vm, ctx, opacity);\\n\\n\\t\\t\\t\\t// Footer\\n\\t\\t\\t\\tthis.drawFooter(pt, vm, ctx, opacity);\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Handle an event\\n\\t\\t * @private\\n\\t\\t * @param {IEvent} event - The event to handle\\n\\t\\t * @returns {Boolean} true if the tooltip changed\\n\\t\\t */\\n\\t\\thandleEvent: function(e) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar options = me._options;\\n\\t\\t\\tvar changed = false;\\n\\n\\t\\t\\tme._lastActive = me._lastActive || [];\\n\\n\\t\\t\\t// Find Active Elements for tooltips\\n\\t\\t\\tif (e.type === 'mouseout') {\\n\\t\\t\\t\\tme._active = [];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme._active = me._chartInstance.getElementsAtEventForMode(e, options.mode, options);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remember Last Actives\\n\\t\\t\\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\\n\\t\\t\\tme._lastActive = me._active;\\n\\n\\t\\t\\tif (options.enabled || options.custom) {\\n\\t\\t\\t\\tme._eventPosition = {\\n\\t\\t\\t\\t\\tx: e.x,\\n\\t\\t\\t\\t\\ty: e.y\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar model = me._model;\\n\\t\\t\\t\\tme.update(true);\\n\\t\\t\\t\\tme.pivot();\\n\\n\\t\\t\\t\\t// See if our tooltip position changed\\n\\t\\t\\t\\tchanged |= (model.x !== me._model.x) || (model.y !== me._model.y);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn changed;\\n\\t\\t}\\n\\t});\\n\\n\\t/**\\n\\t * @namespace Chart.Tooltip.positioners\\n\\t */\\n\\tChart.Tooltip.positioners = {\\n\\t\\t/**\\n\\t\\t * Average mode places the tooltip at the average position of the elements shown\\n\\t\\t * @function Chart.Tooltip.positioners.average\\n\\t\\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\\n\\t\\t * @returns {Point} tooltip position\\n\\t\\t */\\n\\t\\taverage: function(elements) {\\n\\t\\t\\tif (!elements.length) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar i, len;\\n\\t\\t\\tvar x = 0;\\n\\t\\t\\tvar y = 0;\\n\\t\\t\\tvar count = 0;\\n\\n\\t\\t\\tfor (i = 0, len = elements.length; i < len; ++i) {\\n\\t\\t\\t\\tvar el = elements[i];\\n\\t\\t\\t\\tif (el && el.hasValue()) {\\n\\t\\t\\t\\t\\tvar pos = el.tooltipPosition();\\n\\t\\t\\t\\t\\tx += pos.x;\\n\\t\\t\\t\\t\\ty += pos.y;\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: Math.round(x / count),\\n\\t\\t\\t\\ty: Math.round(y / count)\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Gets the tooltip position nearest of the item nearest to the event position\\n\\t\\t * @function Chart.Tooltip.positioners.nearest\\n\\t\\t * @param elements {Chart.Element[]} the tooltip elements\\n\\t\\t * @param eventPosition {Point} the position of the event in canvas coordinates\\n\\t\\t * @returns {Point} the tooltip position\\n\\t\\t */\\n\\t\\tnearest: function(elements, eventPosition) {\\n\\t\\t\\tvar x = eventPosition.x;\\n\\t\\t\\tvar y = eventPosition.y;\\n\\n\\t\\t\\tvar nearestElement;\\n\\t\\t\\tvar minDistance = Number.POSITIVE_INFINITY;\\n\\t\\t\\tvar i, len;\\n\\t\\t\\tfor (i = 0, len = elements.length; i < len; ++i) {\\n\\t\\t\\t\\tvar el = elements[i];\\n\\t\\t\\t\\tif (el && el.hasValue()) {\\n\\t\\t\\t\\t\\tvar center = el.getCenterPoint();\\n\\t\\t\\t\\t\\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\\n\\n\\t\\t\\t\\t\\tif (d < minDistance) {\\n\\t\\t\\t\\t\\t\\tminDistance = d;\\n\\t\\t\\t\\t\\t\\tnearestElement = el;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nearestElement) {\\n\\t\\t\\t\\tvar tp = nearestElement.tooltipPosition();\\n\\t\\t\\t\\tx = tp.x;\\n\\t\\t\\t\\ty = tp.y;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: x,\\n\\t\\t\\t\\ty: y\\n\\t\\t\\t};\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],37:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tglobalOpts = Chart.defaults.global;\\n\\n\\tglobalOpts.elements.arc = {\\n\\t\\tbackgroundColor: globalOpts.defaultColor,\\n\\t\\tborderColor: '#fff',\\n\\t\\tborderWidth: 2\\n\\t};\\n\\n\\tChart.elements.Arc = Chart.Element.extend({\\n\\t\\tinLabelRange: function(mouseX) {\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tif (vm) {\\n\\t\\t\\t\\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tinRange: function(chartX, chartY) {\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tif (vm) {\\n\\t\\t\\t\\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {\\n\\t\\t\\t\\t\\t\\tx: chartX,\\n\\t\\t\\t\\t\\t\\ty: chartY\\n\\t\\t\\t\\t\\t}),\\n\\t\\t\\t\\t\\tangle = pointRelativePosition.angle,\\n\\t\\t\\t\\t\\tdistance = pointRelativePosition.distance;\\n\\n\\t\\t\\t\\t// Sanitise angle range\\n\\t\\t\\t\\tvar startAngle = vm.startAngle;\\n\\t\\t\\t\\tvar endAngle = vm.endAngle;\\n\\t\\t\\t\\twhile (endAngle < startAngle) {\\n\\t\\t\\t\\t\\tendAngle += 2.0 * Math.PI;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (angle > endAngle) {\\n\\t\\t\\t\\t\\tangle -= 2.0 * Math.PI;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (angle < startAngle) {\\n\\t\\t\\t\\t\\tangle += 2.0 * Math.PI;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if within the range of the open/close angle\\n\\t\\t\\t\\tvar betweenAngles = (angle >= startAngle && angle <= endAngle),\\n\\t\\t\\t\\t\\twithinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\\n\\n\\t\\t\\t\\treturn (betweenAngles && withinRadius);\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tgetCenterPoint: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\\n\\t\\t\\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x + Math.cos(halfAngle) * halfRadius,\\n\\t\\t\\t\\ty: vm.y + Math.sin(halfAngle) * halfRadius\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tgetArea: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\\n\\t\\t},\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\n\\t\\t\\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\\n\\t\\t\\t\\trangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\\n\\t\\t\\t\\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tdraw: function() {\\n\\n\\t\\t\\tvar ctx = this._chart.ctx,\\n\\t\\t\\t\\tvm = this._view,\\n\\t\\t\\t\\tsA = vm.startAngle,\\n\\t\\t\\t\\teA = vm.endAngle;\\n\\n\\t\\t\\tctx.beginPath();\\n\\n\\t\\t\\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\\n\\t\\t\\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\\n\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.strokeStyle = vm.borderColor;\\n\\t\\t\\tctx.lineWidth = vm.borderWidth;\\n\\n\\t\\t\\tctx.fillStyle = vm.backgroundColor;\\n\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tctx.lineJoin = 'bevel';\\n\\n\\t\\t\\tif (vm.borderWidth) {\\n\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],38:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar globalDefaults = Chart.defaults.global;\\n\\n\\tChart.defaults.global.elements.line = {\\n\\t\\ttension: 0.4,\\n\\t\\tbackgroundColor: globalDefaults.defaultColor,\\n\\t\\tborderWidth: 3,\\n\\t\\tborderColor: globalDefaults.defaultColor,\\n\\t\\tborderCapStyle: 'butt',\\n\\t\\tborderDash: [],\\n\\t\\tborderDashOffset: 0.0,\\n\\t\\tborderJoinStyle: 'miter',\\n\\t\\tcapBezierPoints: true,\\n\\t\\tfill: true, // do we fill in the area between the line and its base axis\\n\\t};\\n\\n\\tChart.elements.Line = Chart.Element.extend({\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar vm = me._view;\\n\\t\\t\\tvar spanGaps = vm.spanGaps;\\n\\t\\t\\tvar fillPoint = vm.scaleZero;\\n\\t\\t\\tvar loop = me._loop;\\n\\n\\t\\t\\t// Handle different fill modes for cartesian lines\\n\\t\\t\\tif (!loop) {\\n\\t\\t\\t\\tif (vm.fill === 'top') {\\n\\t\\t\\t\\t\\tfillPoint = vm.scaleTop;\\n\\t\\t\\t\\t} else if (vm.fill === 'bottom') {\\n\\t\\t\\t\\t\\tfillPoint = vm.scaleBottom;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar ctx = me._chart.ctx;\\n\\t\\t\\tctx.save();\\n\\n\\t\\t\\t// Helper function to draw a line to a point\\n\\t\\t\\tfunction lineToPoint(previousPoint, point) {\\n\\t\\t\\t\\tvar pointVM = point._view;\\n\\t\\t\\t\\tif (point._view.steppedLine === true) {\\n\\t\\t\\t\\t\\tctx.lineTo(pointVM.x, previousPoint._view.y);\\n\\t\\t\\t\\t\\tctx.lineTo(pointVM.x, pointVM.y);\\n\\t\\t\\t\\t} else if (point._view.tension === 0) {\\n\\t\\t\\t\\t\\tctx.lineTo(pointVM.x, pointVM.y);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tctx.bezierCurveTo(\\n\\t\\t\\t\\t\\t\\tpreviousPoint._view.controlPointNextX,\\n\\t\\t\\t\\t\\t\\tpreviousPoint._view.controlPointNextY,\\n\\t\\t\\t\\t\\t\\tpointVM.controlPointPreviousX,\\n\\t\\t\\t\\t\\t\\tpointVM.controlPointPreviousY,\\n\\t\\t\\t\\t\\t\\tpointVM.x,\\n\\t\\t\\t\\t\\t\\tpointVM.y\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar points = me._children.slice(); // clone array\\n\\t\\t\\tvar lastDrawnIndex = -1;\\n\\n\\t\\t\\t// If we are looping, adding the first point again\\n\\t\\t\\tif (loop && points.length) {\\n\\t\\t\\t\\tpoints.push(points[0]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar index, current, previous, currentVM;\\n\\n\\t\\t\\t// Fill Line\\n\\t\\t\\tif (points.length && vm.fill) {\\n\\t\\t\\t\\tctx.beginPath();\\n\\n\\t\\t\\t\\tfor (index = 0; index < points.length; ++index) {\\n\\t\\t\\t\\t\\tcurrent = points[index];\\n\\t\\t\\t\\t\\tprevious = helpers.previousItem(points, index);\\n\\t\\t\\t\\t\\tcurrentVM = current._view;\\n\\n\\t\\t\\t\\t\\t// First point moves to it's starting position no matter what\\n\\t\\t\\t\\t\\tif (index === 0) {\\n\\t\\t\\t\\t\\t\\tif (loop) {\\n\\t\\t\\t\\t\\t\\t\\tctx.moveTo(fillPoint.x, fillPoint.y);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tctx.moveTo(currentVM.x, fillPoint);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (!currentVM.skip) {\\n\\t\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (currentVM.skip) {\\n\\t\\t\\t\\t\\t\\t\\t// Only do this if this is the first point that is skipped\\n\\t\\t\\t\\t\\t\\t\\tif (!spanGaps && lastDrawnIndex === (index - 1)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (loop) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(fillPoint.x, fillPoint.y);\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(previous._view.x, fillPoint);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tif (lastDrawnIndex !== (index - 1)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\\n\\t\\t\\t\\t\\t\\t\\t\\t// If the first data point is NaN, then there is no real gap to skip\\n\\t\\t\\t\\t\\t\\t\\t\\tif (spanGaps && lastDrawnIndex !== -1) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// We are spanning the gap, so simple draw a line to this point\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlineToPoint(previous, current);\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if (loop) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, fillPoint);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tctx.lineTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Line to next point\\n\\t\\t\\t\\t\\t\\t\\t\\tlineToPoint(previous, current);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!loop && lastDrawnIndex !== -1) {\\n\\t\\t\\t\\t\\tctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\\n\\t\\t\\t\\tctx.closePath();\\n\\t\\t\\t\\tctx.fill();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Stroke Line Options\\n\\t\\t\\tvar globalOptionLineElements = globalDefaults.elements.line;\\n\\t\\t\\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\\n\\n\\t\\t\\t// IE 9 and 10 do not support line dash\\n\\t\\t\\tif (ctx.setLineDash) {\\n\\t\\t\\t\\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\\n\\t\\t\\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\\n\\t\\t\\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\\n\\t\\t\\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\\n\\n\\t\\t\\t// Stroke Line\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tlastDrawnIndex = -1;\\n\\n\\t\\t\\tfor (index = 0; index < points.length; ++index) {\\n\\t\\t\\t\\tcurrent = points[index];\\n\\t\\t\\t\\tprevious = helpers.previousItem(points, index);\\n\\t\\t\\t\\tcurrentVM = current._view;\\n\\n\\t\\t\\t\\t// First point moves to it's starting position no matter what\\n\\t\\t\\t\\tif (index === 0) {\\n\\t\\t\\t\\t\\tif (!currentVM.skip) {\\n\\t\\t\\t\\t\\t\\tctx.moveTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\\n\\n\\t\\t\\t\\t\\tif (!currentVM.skip) {\\n\\t\\t\\t\\t\\t\\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\\n\\t\\t\\t\\t\\t\\t\\t// There was a gap and this is the first point after the gap\\n\\t\\t\\t\\t\\t\\t\\tctx.moveTo(currentVM.x, currentVM.y);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Line to next point\\n\\t\\t\\t\\t\\t\\t\\tlineToPoint(previous, current);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tlastDrawnIndex = index;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.stroke();\\n\\t\\t\\tctx.restore();\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],39:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tglobalOpts = Chart.defaults.global,\\n\\t\\tdefaultColor = globalOpts.defaultColor;\\n\\n\\tglobalOpts.elements.point = {\\n\\t\\tradius: 3,\\n\\t\\tpointStyle: 'circle',\\n\\t\\tbackgroundColor: defaultColor,\\n\\t\\tborderWidth: 1,\\n\\t\\tborderColor: defaultColor,\\n\\t\\t// Hover\\n\\t\\thitRadius: 1,\\n\\t\\thoverRadius: 4,\\n\\t\\thoverBorderWidth: 1\\n\\t};\\n\\n\\tfunction xRange(mouseX) {\\n\\t\\tvar vm = this._view;\\n\\t\\treturn vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\\n\\t}\\n\\n\\tfunction yRange(mouseY) {\\n\\t\\tvar vm = this._view;\\n\\t\\treturn vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\\n\\t}\\n\\n\\tChart.elements.Point = Chart.Element.extend({\\n\\t\\tinRange: function(mouseX, mouseY) {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\\n\\t\\t},\\n\\n\\t\\tinLabelRange: xRange,\\n\\t\\tinXRange: xRange,\\n\\t\\tinYRange: yRange,\\n\\n\\t\\tgetCenterPoint: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tgetArea: function() {\\n\\t\\t\\treturn Math.PI * Math.pow(this._view.radius, 2);\\n\\t\\t},\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y,\\n\\t\\t\\t\\tpadding: vm.radius + vm.borderWidth\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tdraw: function(chartArea) {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar model = this._model;\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar pointStyle = vm.pointStyle;\\n\\t\\t\\tvar radius = vm.radius;\\n\\t\\t\\tvar x = vm.x;\\n\\t\\t\\tvar y = vm.y;\\n\\t\\t\\tvar color = Chart.helpers.color;\\n\\t\\t\\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\\n\\t\\t\\tvar ratio = 0;\\n\\n\\t\\t\\tif (vm.skip) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.strokeStyle = vm.borderColor || defaultColor;\\n\\t\\t\\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\\n\\t\\t\\tctx.fillStyle = vm.backgroundColor || defaultColor;\\n\\n\\t\\t\\t// Cliping for Points.\\n\\t\\t\\t// going out from inner charArea?\\n\\t\\t\\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {\\n\\t\\t\\t\\t// Point fade out\\n\\t\\t\\t\\tif (model.x < chartArea.left) {\\n\\t\\t\\t\\t\\tratio = (x - model.x) / (chartArea.left - model.x);\\n\\t\\t\\t\\t} else if (chartArea.right*errMargin < model.x) {\\n\\t\\t\\t\\t\\tratio = (model.x - x) / (model.x - chartArea.right);\\n\\t\\t\\t\\t} else if (model.y < chartArea.top) {\\n\\t\\t\\t\\t\\tratio = (y - model.y) / (chartArea.top - model.y);\\n\\t\\t\\t\\t} else if (chartArea.bottom*errMargin < model.y) {\\n\\t\\t\\t\\t\\tratio = (model.y - y) / (model.y - chartArea.bottom);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tratio = Math.round(ratio*100) / 100;\\n\\t\\t\\t\\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\\n\\t\\t\\t\\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],40:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar globalOpts = Chart.defaults.global;\\n\\n\\tglobalOpts.elements.rectangle = {\\n\\t\\tbackgroundColor: globalOpts.defaultColor,\\n\\t\\tborderWidth: 0,\\n\\t\\tborderColor: globalOpts.defaultColor,\\n\\t\\tborderSkipped: 'bottom'\\n\\t};\\n\\n\\tfunction isVertical(bar) {\\n\\t\\treturn bar._view.width !== undefined;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to get the bounds of the bar regardless of the orientation\\n\\t * @private\\n\\t * @param bar {Chart.Element.Rectangle} the bar\\n\\t * @return {Bounds} bounds of the bar\\n\\t */\\n\\tfunction getBarBounds(bar) {\\n\\t\\tvar vm = bar._view;\\n\\t\\tvar x1, x2, y1, y2;\\n\\n\\t\\tif (isVertical(bar)) {\\n\\t\\t\\t// vertical\\n\\t\\t\\tvar halfWidth = vm.width / 2;\\n\\t\\t\\tx1 = vm.x - halfWidth;\\n\\t\\t\\tx2 = vm.x + halfWidth;\\n\\t\\t\\ty1 = Math.min(vm.y, vm.base);\\n\\t\\t\\ty2 = Math.max(vm.y, vm.base);\\n\\t\\t} else {\\n\\t\\t\\t// horizontal bar\\n\\t\\t\\tvar halfHeight = vm.height / 2;\\n\\t\\t\\tx1 = Math.min(vm.x, vm.base);\\n\\t\\t\\tx2 = Math.max(vm.x, vm.base);\\n\\t\\t\\ty1 = vm.y - halfHeight;\\n\\t\\t\\ty2 = vm.y + halfHeight;\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tleft: x1,\\n\\t\\t\\ttop: y1,\\n\\t\\t\\tright: x2,\\n\\t\\t\\tbottom: y2\\n\\t\\t};\\n\\t}\\n\\n\\tChart.elements.Rectangle = Chart.Element.extend({\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar ctx = this._chart.ctx;\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar left, right, top, bottom, signX, signY, borderSkipped;\\n\\t\\t\\tvar borderWidth = vm.borderWidth;\\n\\n\\t\\t\\tif (!vm.horizontal) {\\n\\t\\t\\t\\t// bar\\n\\t\\t\\t\\tleft = vm.x - vm.width / 2;\\n\\t\\t\\t\\tright = vm.x + vm.width / 2;\\n\\t\\t\\t\\ttop = vm.y;\\n\\t\\t\\t\\tbottom = vm.base;\\n\\t\\t\\t\\tsignX = 1;\\n\\t\\t\\t\\tsignY = bottom > top? 1: -1;\\n\\t\\t\\t\\tborderSkipped = vm.borderSkipped || 'bottom';\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// horizontal bar\\n\\t\\t\\t\\tleft = vm.base;\\n\\t\\t\\t\\tright = vm.x;\\n\\t\\t\\t\\ttop = vm.y - vm.height / 2;\\n\\t\\t\\t\\tbottom = vm.y + vm.height / 2;\\n\\t\\t\\t\\tsignX = right > left? 1: -1;\\n\\t\\t\\t\\tsignY = 1;\\n\\t\\t\\t\\tborderSkipped = vm.borderSkipped || 'left';\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Canvas doesn't allow us to stroke inside the width so we can\\n\\t\\t\\t// adjust the sizes to fit if we're setting a stroke on the line\\n\\t\\t\\tif (borderWidth) {\\n\\t\\t\\t\\t// borderWidth shold be less than bar width and bar height.\\n\\t\\t\\t\\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\\n\\t\\t\\t\\tborderWidth = borderWidth > barSize? barSize: borderWidth;\\n\\t\\t\\t\\tvar halfStroke = borderWidth / 2;\\n\\t\\t\\t\\t// Adjust borderWidth when bar top position is near vm.base(zero).\\n\\t\\t\\t\\tvar borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);\\n\\t\\t\\t\\tvar borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);\\n\\t\\t\\t\\tvar borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);\\n\\t\\t\\t\\tvar borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);\\n\\t\\t\\t\\t// not become a vertical line?\\n\\t\\t\\t\\tif (borderLeft !== borderRight) {\\n\\t\\t\\t\\t\\ttop = borderTop;\\n\\t\\t\\t\\t\\tbottom = borderBottom;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// not become a horizontal line?\\n\\t\\t\\t\\tif (borderTop !== borderBottom) {\\n\\t\\t\\t\\t\\tleft = borderLeft;\\n\\t\\t\\t\\t\\tright = borderRight;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.fillStyle = vm.backgroundColor;\\n\\t\\t\\tctx.strokeStyle = vm.borderColor;\\n\\t\\t\\tctx.lineWidth = borderWidth;\\n\\n\\t\\t\\t// Corner points, from bottom-left to bottom-right clockwise\\n\\t\\t\\t// | 1 2 |\\n\\t\\t\\t// | 0 3 |\\n\\t\\t\\tvar corners = [\\n\\t\\t\\t\\t[left, bottom],\\n\\t\\t\\t\\t[left, top],\\n\\t\\t\\t\\t[right, top],\\n\\t\\t\\t\\t[right, bottom]\\n\\t\\t\\t];\\n\\n\\t\\t\\t// Find first (starting) corner with fallback to 'bottom'\\n\\t\\t\\tvar borders = ['bottom', 'left', 'top', 'right'];\\n\\t\\t\\tvar startCorner = borders.indexOf(borderSkipped, 0);\\n\\t\\t\\tif (startCorner === -1) {\\n\\t\\t\\t\\tstartCorner = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction cornerAt(index) {\\n\\t\\t\\t\\treturn corners[(startCorner + index) % 4];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Draw rectangle from 'startCorner'\\n\\t\\t\\tvar corner = cornerAt(0);\\n\\t\\t\\tctx.moveTo(corner[0], corner[1]);\\n\\n\\t\\t\\tfor (var i = 1; i < 4; i++) {\\n\\t\\t\\t\\tcorner = cornerAt(i);\\n\\t\\t\\t\\tctx.lineTo(corner[0], corner[1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.fill();\\n\\t\\t\\tif (borderWidth) {\\n\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\theight: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn vm.base - vm.y;\\n\\t\\t},\\n\\t\\tinRange: function(mouseX, mouseY) {\\n\\t\\t\\tvar inRange = false;\\n\\n\\t\\t\\tif (this._view) {\\n\\t\\t\\t\\tvar bounds = getBarBounds(this);\\n\\t\\t\\t\\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn inRange;\\n\\t\\t},\\n\\t\\tinLabelRange: function(mouseX, mouseY) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (!me._view) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar inRange = false;\\n\\t\\t\\tvar bounds = getBarBounds(me);\\n\\n\\t\\t\\tif (isVertical(me)) {\\n\\t\\t\\t\\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn inRange;\\n\\t\\t},\\n\\t\\tinXRange: function(mouseX) {\\n\\t\\t\\tvar bounds = getBarBounds(this);\\n\\t\\t\\treturn mouseX >= bounds.left && mouseX <= bounds.right;\\n\\t\\t},\\n\\t\\tinYRange: function(mouseY) {\\n\\t\\t\\tvar bounds = getBarBounds(this);\\n\\t\\t\\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\\n\\t\\t},\\n\\t\\tgetCenterPoint: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\tvar x, y;\\n\\t\\t\\tif (isVertical(this)) {\\n\\t\\t\\t\\tx = vm.x;\\n\\t\\t\\t\\ty = (vm.y + vm.base) / 2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tx = (vm.x + vm.base) / 2;\\n\\t\\t\\t\\ty = vm.y;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {x: x, y: y};\\n\\t\\t},\\n\\t\\tgetArea: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn vm.width * Math.abs(vm.y - vm.base);\\n\\t\\t},\\n\\t\\ttooltipPosition: function() {\\n\\t\\t\\tvar vm = this._view;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: vm.x,\\n\\t\\t\\t\\ty: vm.y\\n\\t\\t\\t};\\n\\t\\t}\\n\\t});\\n\\n};\\n\\n},{}],41:[function(require,module,exports){\\n'use strict';\\n\\n// Chart.Platform implementation for targeting a web browser\\nmodule.exports = function(Chart) {\\n\\tvar helpers = Chart.helpers;\\n\\n\\t// DOM event types -> Chart.js event types.\\n\\t// Note: only events with different types are mapped.\\n\\t// https://developer.mozilla.org/en-US/docs/Web/Events\\n\\tvar eventTypeMap = {\\n\\t\\t// Touch events\\n\\t\\ttouchstart: 'mousedown',\\n\\t\\ttouchmove: 'mousemove',\\n\\t\\ttouchend: 'mouseup',\\n\\n\\t\\t// Pointer events\\n\\t\\tpointerenter: 'mouseenter',\\n\\t\\tpointerdown: 'mousedown',\\n\\t\\tpointermove: 'mousemove',\\n\\t\\tpointerup: 'mouseup',\\n\\t\\tpointerleave: 'mouseout',\\n\\t\\tpointerout: 'mouseout'\\n\\t};\\n\\n\\t/**\\n\\t * The \\\"used\\\" size is the final value of a dimension property after all calculations have\\n\\t * been performed. This method uses the computed style of `element` but returns undefined\\n\\t * if the computed style is not expressed in pixels. That can happen in some cases where\\n\\t * `element` has a size relative to its parent and this last one is not yet displayed,\\n\\t * for example because of `display: none` on a parent node.\\n\\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\\n\\t * @returns {Number} Size in pixels or undefined if unknown.\\n\\t */\\n\\tfunction readUsedSize(element, property) {\\n\\t\\tvar value = helpers.getStyle(element, property);\\n\\t\\tvar matches = value && value.match(/(\\\\d+)px/);\\n\\t\\treturn matches? Number(matches[1]) : undefined;\\n\\t}\\n\\n\\t/**\\n\\t * Initializes the canvas style and render size without modifying the canvas display size,\\n\\t * since responsiveness is handled by the controller.resize() method. The config is used\\n\\t * to determine the aspect ratio to apply in case no explicit height has been specified.\\n\\t */\\n\\tfunction initCanvas(canvas, config) {\\n\\t\\tvar style = canvas.style;\\n\\n\\t\\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\\n\\t\\t// returns null or '' if no explicit value has been set to the canvas attribute.\\n\\t\\tvar renderHeight = canvas.getAttribute('height');\\n\\t\\tvar renderWidth = canvas.getAttribute('width');\\n\\n\\t\\t// Chart.js modifies some canvas values that we want to restore on destroy\\n\\t\\tcanvas._chartjs = {\\n\\t\\t\\tinitial: {\\n\\t\\t\\t\\theight: renderHeight,\\n\\t\\t\\t\\twidth: renderWidth,\\n\\t\\t\\t\\tstyle: {\\n\\t\\t\\t\\t\\tdisplay: style.display,\\n\\t\\t\\t\\t\\theight: style.height,\\n\\t\\t\\t\\t\\twidth: style.width\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Force canvas to display as block to avoid extra space caused by inline\\n\\t\\t// elements, which would interfere with the responsive resize process.\\n\\t\\t// https://github.com/chartjs/Chart.js/issues/2538\\n\\t\\tstyle.display = style.display || 'block';\\n\\n\\t\\tif (renderWidth === null || renderWidth === '') {\\n\\t\\t\\tvar displayWidth = readUsedSize(canvas, 'width');\\n\\t\\t\\tif (displayWidth !== undefined) {\\n\\t\\t\\t\\tcanvas.width = displayWidth;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (renderHeight === null || renderHeight === '') {\\n\\t\\t\\tif (canvas.style.height === '') {\\n\\t\\t\\t\\t// If no explicit render height and style height, let's apply the aspect ratio,\\n\\t\\t\\t\\t// which one can be specified by the user but also by charts as default option\\n\\t\\t\\t\\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\\n\\t\\t\\t\\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar displayHeight = readUsedSize(canvas, 'height');\\n\\t\\t\\t\\tif (displayWidth !== undefined) {\\n\\t\\t\\t\\t\\tcanvas.height = displayHeight;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn canvas;\\n\\t}\\n\\n\\tfunction createEvent(type, chart, x, y, native) {\\n\\t\\treturn {\\n\\t\\t\\ttype: type,\\n\\t\\t\\tchart: chart,\\n\\t\\t\\tnative: native || null,\\n\\t\\t\\tx: x !== undefined? x : null,\\n\\t\\t\\ty: y !== undefined? y : null,\\n\\t\\t};\\n\\t}\\n\\n\\tfunction fromNativeEvent(event, chart) {\\n\\t\\tvar type = eventTypeMap[event.type] || event.type;\\n\\t\\tvar pos = helpers.getRelativePosition(event, chart);\\n\\t\\treturn createEvent(type, chart, pos.x, pos.y, event);\\n\\t}\\n\\n\\tfunction createResizer(handler) {\\n\\t\\tvar iframe = document.createElement('iframe');\\n\\t\\tiframe.className = 'chartjs-hidden-iframe';\\n\\t\\tiframe.style.cssText =\\n\\t\\t\\t'display:block;'+\\n\\t\\t\\t'overflow:hidden;'+\\n\\t\\t\\t'border:0;'+\\n\\t\\t\\t'margin:0;'+\\n\\t\\t\\t'top:0;'+\\n\\t\\t\\t'left:0;'+\\n\\t\\t\\t'bottom:0;'+\\n\\t\\t\\t'right:0;'+\\n\\t\\t\\t'height:100%;'+\\n\\t\\t\\t'width:100%;'+\\n\\t\\t\\t'position:absolute;'+\\n\\t\\t\\t'pointer-events:none;'+\\n\\t\\t\\t'z-index:-1;';\\n\\n\\t\\t// Prevent the iframe to gain focus on tab.\\n\\t\\t// https://github.com/chartjs/Chart.js/issues/3090\\n\\t\\tiframe.tabIndex = -1;\\n\\n\\t\\t// If the iframe is re-attached to the DOM, the resize listener is removed because the\\n\\t\\t// content is reloaded, so make sure to install the handler after the iframe is loaded.\\n\\t\\t// https://github.com/chartjs/Chart.js/issues/3521\\n\\t\\thelpers.addEvent(iframe, 'load', function() {\\n\\t\\t\\thelpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);\\n\\n\\t\\t\\t// The iframe size might have changed while loading, which can also\\n\\t\\t\\t// happen if the size has been changed while detached from the DOM.\\n\\t\\t\\thandler();\\n\\t\\t});\\n\\n\\t\\treturn iframe;\\n\\t}\\n\\n\\tfunction addResizeListener(node, listener, chart) {\\n\\t\\tvar stub = node._chartjs = {\\n\\t\\t\\tticking: false\\n\\t\\t};\\n\\n\\t\\t// Throttle the callback notification until the next animation frame.\\n\\t\\tvar notify = function() {\\n\\t\\t\\tif (!stub.ticking) {\\n\\t\\t\\t\\tstub.ticking = true;\\n\\t\\t\\t\\thelpers.requestAnimFrame.call(window, function() {\\n\\t\\t\\t\\t\\tif (stub.resizer) {\\n\\t\\t\\t\\t\\t\\tstub.ticking = false;\\n\\t\\t\\t\\t\\t\\treturn listener(createEvent('resize', chart));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t// Let's keep track of this added iframe and thus avoid DOM query when removing it.\\n\\t\\tstub.resizer = createResizer(notify);\\n\\n\\t\\tnode.insertBefore(stub.resizer, node.firstChild);\\n\\t}\\n\\n\\tfunction removeResizeListener(node) {\\n\\t\\tif (!node || !node._chartjs) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar resizer = node._chartjs.resizer;\\n\\t\\tif (resizer) {\\n\\t\\t\\tresizer.parentNode.removeChild(resizer);\\n\\t\\t\\tnode._chartjs.resizer = null;\\n\\t\\t}\\n\\n\\t\\tdelete node._chartjs;\\n\\t}\\n\\n\\treturn {\\n\\t\\tacquireContext: function(item, config) {\\n\\t\\t\\tif (typeof item === 'string') {\\n\\t\\t\\t\\titem = document.getElementById(item);\\n\\t\\t\\t} else if (item.length) {\\n\\t\\t\\t\\t// Support for array based queries (such as jQuery)\\n\\t\\t\\t\\titem = item[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (item && item.canvas) {\\n\\t\\t\\t\\t// Support for any object associated to a canvas (including a context2d)\\n\\t\\t\\t\\titem = item.canvas;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (item instanceof HTMLCanvasElement) {\\n\\t\\t\\t\\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\\n\\t\\t\\t\\t// method, for example: https://github.com/kkapsner/CanvasBlocker\\n\\t\\t\\t\\t// https://github.com/chartjs/Chart.js/issues/2807\\n\\t\\t\\t\\tvar context = item.getContext && item.getContext('2d');\\n\\t\\t\\t\\tif (context instanceof CanvasRenderingContext2D) {\\n\\t\\t\\t\\t\\tinitCanvas(item, config);\\n\\t\\t\\t\\t\\treturn context;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\n\\t\\treleaseContext: function(context) {\\n\\t\\t\\tvar canvas = context.canvas;\\n\\t\\t\\tif (!canvas._chartjs) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar initial = canvas._chartjs.initial;\\n\\t\\t\\t['height', 'width'].forEach(function(prop) {\\n\\t\\t\\t\\tvar value = initial[prop];\\n\\t\\t\\t\\tif (value === undefined || value === null) {\\n\\t\\t\\t\\t\\tcanvas.removeAttribute(prop);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcanvas.setAttribute(prop, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\thelpers.each(initial.style || {}, function(value, key) {\\n\\t\\t\\t\\tcanvas.style[key] = value;\\n\\t\\t\\t});\\n\\n\\t\\t\\t// The canvas render size might have been changed (and thus the state stack discarded),\\n\\t\\t\\t// we can't use save() and restore() to restore the initial state. So make sure that at\\n\\t\\t\\t// least the canvas context is reset to the default state by setting the canvas width.\\n\\t\\t\\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\\n\\t\\t\\tcanvas.width = canvas.width;\\n\\n\\t\\t\\tdelete canvas._chartjs;\\n\\t\\t},\\n\\n\\t\\taddEventListener: function(chart, type, listener) {\\n\\t\\t\\tvar canvas = chart.chart.canvas;\\n\\t\\t\\tif (type === 'resize') {\\n\\t\\t\\t\\t// Note: the resize event is not supported on all browsers.\\n\\t\\t\\t\\taddResizeListener(canvas.parentNode, listener, chart.chart);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar stub = listener._chartjs || (listener._chartjs = {});\\n\\t\\t\\tvar proxies = stub.proxies || (stub.proxies = {});\\n\\t\\t\\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\\n\\t\\t\\t\\tlistener(fromNativeEvent(event, chart.chart));\\n\\t\\t\\t};\\n\\n\\t\\t\\thelpers.addEvent(canvas, type, proxy);\\n\\t\\t},\\n\\n\\t\\tremoveEventListener: function(chart, type, listener) {\\n\\t\\t\\tvar canvas = chart.chart.canvas;\\n\\t\\t\\tif (type === 'resize') {\\n\\t\\t\\t\\t// Note: the resize event is not supported on all browsers.\\n\\t\\t\\t\\tremoveResizeListener(canvas.parentNode, listener);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar stub = listener._chartjs || {};\\n\\t\\t\\tvar proxies = stub.proxies || {};\\n\\t\\t\\tvar proxy = proxies[chart.id + '_' + type];\\n\\t\\t\\tif (!proxy) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.removeEvent(canvas, type, proxy);\\n\\t\\t}\\n\\t};\\n};\\n\\n},{}],42:[function(require,module,exports){\\n'use strict';\\n\\n// By default, select the browser (DOM) platform.\\n// @TODO Make possible to select another platform at build time.\\nvar implementation = require(41);\\n\\nmodule.exports = function(Chart) {\\n\\t/**\\n\\t * @namespace Chart.platform\\n\\t * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\\n\\t * @since 2.4.0\\n\\t */\\n\\tChart.platform = {\\n\\t\\t/**\\n\\t\\t * Called at chart construction time, returns a context2d instance implementing\\n\\t\\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\\n\\t\\t * @param {*} item - The native item from which to acquire context (platform specific)\\n\\t\\t * @param {Object} options - The chart options\\n\\t\\t * @returns {CanvasRenderingContext2D} context2d instance\\n\\t\\t */\\n\\t\\tacquireContext: function() {},\\n\\n\\t\\t/**\\n\\t\\t * Called at chart destruction time, releases any resources associated to the context\\n\\t\\t * previously returned by the acquireContext() method.\\n\\t\\t * @param {CanvasRenderingContext2D} context - The context2d instance\\n\\t\\t * @returns {Boolean} true if the method succeeded, else false\\n\\t\\t */\\n\\t\\treleaseContext: function() {},\\n\\n\\t\\t/**\\n\\t\\t * Registers the specified listener on the given chart.\\n\\t\\t * @param {Chart} chart - Chart from which to listen for event\\n\\t\\t * @param {String} type - The ({@link IEvent}) type to listen for\\n\\t\\t * @param {Function} listener - Receives a notification (an object that implements\\n\\t\\t * the {@link IEvent} interface) when an event of the specified type occurs.\\n\\t\\t */\\n\\t\\taddEventListener: function() {},\\n\\n\\t\\t/**\\n\\t\\t * Removes the specified listener previously registered with addEventListener.\\n\\t\\t * @param {Chart} chart -Chart from which to remove the listener\\n\\t\\t * @param {String} type - The ({@link IEvent}) type to remove\\n\\t\\t * @param {Function} listener - The listener function to remove from the event target.\\n\\t\\t */\\n\\t\\tremoveEventListener: function() {}\\n\\t};\\n\\n\\t/**\\n\\t * @interface IPlatform\\n\\t * Allows abstracting platform dependencies away from the chart\\n\\t * @borrows Chart.platform.acquireContext as acquireContext\\n\\t * @borrows Chart.platform.releaseContext as releaseContext\\n\\t * @borrows Chart.platform.addEventListener as addEventListener\\n\\t * @borrows Chart.platform.removeEventListener as removeEventListener\\n\\t */\\n\\n\\t/**\\n\\t * @interface IEvent\\n\\t * @prop {String} type - The event type name, possible values are:\\n\\t * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\\n\\t * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\\n\\t * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\\n\\t * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\\n\\t * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\\n\\t */\\n\\n\\tChart.helpers.extend(Chart.platform, implementation(Chart));\\n};\\n\\n},{\\\"41\\\":41}],43:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\t// Default config for a category scale\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'bottom'\\n\\t};\\n\\n\\tvar DatasetScale = Chart.Scale.extend({\\n\\t\\t/**\\n\\t\\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\\n\\t\\t* else fall back to data.labels\\n\\t\\t* @private\\n\\t\\t*/\\n\\t\\tgetLabels: function() {\\n\\t\\t\\tvar data = this.chart.data;\\n\\t\\t\\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\\n\\t\\t},\\n\\t\\t// Implement this so that\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar labels = me.getLabels();\\n\\t\\t\\tme.minIndex = 0;\\n\\t\\t\\tme.maxIndex = labels.length - 1;\\n\\t\\t\\tvar findIndex;\\n\\n\\t\\t\\tif (me.options.ticks.min !== undefined) {\\n\\t\\t\\t\\t// user specified min value\\n\\t\\t\\t\\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\\n\\t\\t\\t\\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.options.ticks.max !== undefined) {\\n\\t\\t\\t\\t// user specified max value\\n\\t\\t\\t\\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\\n\\t\\t\\t\\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.min = labels[me.minIndex];\\n\\t\\t\\tme.max = labels[me.maxIndex];\\n\\t\\t},\\n\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar labels = me.getLabels();\\n\\t\\t\\t// If we are viewing some subset of labels, slice the original array\\n\\t\\t\\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\\n\\t\\t},\\n\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar data = me.chart.data;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tif (data.yLabels && !isHorizontal) {\\n\\t\\t\\t\\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\\n\\t\\t\\t}\\n\\t\\t\\treturn me.ticks[index - me.minIndex];\\n\\t\\t},\\n\\n\\t\\t// Used to get data value locations.  Value can either be an index or a numerical value\\n\\t\\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\t// 1 is added because we need the length but we have the indexes\\n\\t\\t\\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\\n\\n\\t\\t\\tif (value !== undefined && isNaN(index)) {\\n\\t\\t\\t\\tvar labels = me.getLabels();\\n\\t\\t\\t\\tvar idx = labels.indexOf(value);\\n\\t\\t\\t\\tindex = idx !== -1 ? idx : index;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tvar valueWidth = me.width / offsetAmt;\\n\\t\\t\\t\\tvar widthOffset = (valueWidth * (index - me.minIndex));\\n\\n\\t\\t\\t\\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\\n\\t\\t\\t\\t\\twidthOffset += (valueWidth / 2);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn me.left + Math.round(widthOffset);\\n\\t\\t\\t}\\n\\t\\t\\tvar valueHeight = me.height / offsetAmt;\\n\\t\\t\\tvar heightOffset = (valueHeight * (index - me.minIndex));\\n\\n\\t\\t\\tif (me.options.gridLines.offsetGridLines && includeOffset) {\\n\\t\\t\\t\\theightOffset += (valueHeight / 2);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn me.top + Math.round(heightOffset);\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index, includeOffset) {\\n\\t\\t\\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar value;\\n\\t\\t\\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\\n\\t\\t\\tvar horz = me.isHorizontal();\\n\\t\\t\\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\\n\\n\\t\\t\\tpixel -= horz ? me.left : me.top;\\n\\n\\t\\t\\tif (me.options.gridLines.offsetGridLines) {\\n\\t\\t\\t\\tpixel -= (valueDimension / 2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (pixel <= 0) {\\n\\t\\t\\t\\tvalue = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue = Math.round(pixel / valueDimension);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value;\\n\\t\\t},\\n\\t\\tgetBasePixel: function() {\\n\\t\\t\\treturn this.bottom;\\n\\t\\t}\\n\\t});\\n\\n\\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\\n\\n};\\n\\n},{}],44:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'left',\\n\\t\\tticks: {\\n\\t\\t\\tcallback: Chart.Ticks.formatters.linear\\n\\t\\t}\\n\\t};\\n\\n\\tvar LinearScale = Chart.LinearScaleBase.extend({\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\n\\t\\t\\tfunction IDMatches(meta) {\\n\\t\\t\\t\\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// First Calculate the range\\n\\t\\t\\tme.min = null;\\n\\t\\t\\tme.max = null;\\n\\n\\t\\t\\tvar hasStacks = opts.stacked;\\n\\t\\t\\tif (hasStacks === undefined) {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tif (hasStacks) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack !== undefined) {\\n\\t\\t\\t\\t\\t\\thasStacks = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (opts.stacked || hasStacks) {\\n\\t\\t\\t\\tvar valuesPerStack = {};\\n\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tvar key = [\\n\\t\\t\\t\\t\\t\\tmeta.type,\\n\\t\\t\\t\\t\\t\\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\\n\\t\\t\\t\\t\\t\\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\\n\\t\\t\\t\\t\\t\\tmeta.stack\\n\\t\\t\\t\\t\\t].join('.');\\n\\n\\t\\t\\t\\t\\tif (valuesPerStack[key] === undefined) {\\n\\t\\t\\t\\t\\t\\tvaluesPerStack[key] = {\\n\\t\\t\\t\\t\\t\\t\\tpositiveValues: [],\\n\\t\\t\\t\\t\\t\\t\\tnegativeValues: []\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Store these per type\\n\\t\\t\\t\\t\\tvar positiveValues = valuesPerStack[key].positiveValues;\\n\\t\\t\\t\\t\\tvar negativeValues = valuesPerStack[key].negativeValues;\\n\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tpositiveValues[index] = positiveValues[index] || 0;\\n\\t\\t\\t\\t\\t\\t\\tnegativeValues[index] = negativeValues[index] || 0;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (opts.relativePoints) {\\n\\t\\t\\t\\t\\t\\t\\t\\tpositiveValues[index] = 100;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value < 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnegativeValues[index] += value;\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tpositiveValues[index] += value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(valuesPerStack, function(valuesForType) {\\n\\t\\t\\t\\t\\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\\n\\t\\t\\t\\t\\tvar minVal = helpers.min(values);\\n\\t\\t\\t\\t\\tvar maxVal = helpers.max(values);\\n\\t\\t\\t\\t\\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\\n\\t\\t\\t\\t\\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.min === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value < me.min) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.max === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value > me.max) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\\n\\t\\t\\tthis.handleTickRangeOptions();\\n\\t\\t},\\n\\t\\tgetTickLimit: function() {\\n\\t\\t\\tvar maxTicks;\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar tickOpts = me.options.ticks;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// The factor of 2 used to scale the font size has been experimentally determined.\\n\\t\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\\n\\t\\t\\t\\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxTicks;\\n\\t\\t},\\n\\t\\t// Called after the ticks are built. We need\\n\\t\\thandleDirectionalChanges: function() {\\n\\t\\t\\tif (!this.isHorizontal()) {\\n\\t\\t\\t\\t// We are in a vertical orientation. The top value is the highest. So reverse the array\\n\\t\\t\\t\\tthis.ticks.reverse();\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\\n\\t\\t},\\n\\t\\t// Utils\\n\\t\\tgetPixelForValue: function(value) {\\n\\t\\t\\t// This must be called after fit has been run so that\\n\\t\\t\\t// this.left, this.top, this.right, and this.bottom have been defined\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar start = me.start;\\n\\n\\t\\t\\tvar rightValue = +me.getRightValue(value);\\n\\t\\t\\tvar pixel;\\n\\t\\t\\tvar range = me.end - start;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tpixel = me.left + (me.width / range * (rightValue - start));\\n\\t\\t\\t\\treturn Math.round(pixel);\\n\\t\\t\\t}\\n\\n\\t\\t\\tpixel = me.bottom - (me.height / range * (rightValue - start));\\n\\t\\t\\treturn Math.round(pixel);\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\t\\t\\tvar innerDimension = isHorizontal ? me.width : me.height;\\n\\t\\t\\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\\n\\t\\t\\treturn me.start + ((me.end - me.start) * offset);\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index) {\\n\\t\\t\\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\\n\\n};\\n\\n},{}],45:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers,\\n\\t\\tnoop = helpers.noop;\\n\\n\\tChart.LinearScaleBase = Chart.Scale.extend({\\n\\t\\thandleTickRangeOptions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\\n\\t\\t\\t// do nothing since that would make the chart weird. If the user really wants a weird chart\\n\\t\\t\\t// axis, they can manually override it\\n\\t\\t\\tif (tickOpts.beginAtZero) {\\n\\t\\t\\t\\tvar minSign = helpers.sign(me.min);\\n\\t\\t\\t\\tvar maxSign = helpers.sign(me.max);\\n\\n\\t\\t\\t\\tif (minSign < 0 && maxSign < 0) {\\n\\t\\t\\t\\t\\t// move the top up to 0\\n\\t\\t\\t\\t\\tme.max = 0;\\n\\t\\t\\t\\t} else if (minSign > 0 && maxSign > 0) {\\n\\t\\t\\t\\t\\t// move the bottom down to 0\\n\\t\\t\\t\\t\\tme.min = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (tickOpts.min !== undefined) {\\n\\t\\t\\t\\tme.min = tickOpts.min;\\n\\t\\t\\t} else if (tickOpts.suggestedMin !== undefined) {\\n\\t\\t\\t\\tme.min = Math.min(me.min, tickOpts.suggestedMin);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (tickOpts.max !== undefined) {\\n\\t\\t\\t\\tme.max = tickOpts.max;\\n\\t\\t\\t} else if (tickOpts.suggestedMax !== undefined) {\\n\\t\\t\\t\\tme.max = Math.max(me.max, tickOpts.suggestedMax);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.min === me.max) {\\n\\t\\t\\t\\tme.max++;\\n\\n\\t\\t\\t\\tif (!tickOpts.beginAtZero) {\\n\\t\\t\\t\\t\\tme.min--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgetTickLimit: noop,\\n\\t\\thandleDirectionalChanges: noop,\\n\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\t// Figure out what the max number of ticks we can support it is based on the size of\\n\\t\\t\\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\\n\\t\\t\\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\\n\\t\\t\\t// the graph. Make sure we always have at least 2 ticks\\n\\t\\t\\tvar maxTicks = me.getTickLimit();\\n\\t\\t\\tmaxTicks = Math.max(2, maxTicks);\\n\\n\\t\\t\\tvar numericGeneratorOptions = {\\n\\t\\t\\t\\tmaxTicks: maxTicks,\\n\\t\\t\\t\\tmin: tickOpts.min,\\n\\t\\t\\t\\tmax: tickOpts.max,\\n\\t\\t\\t\\tstepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\\n\\t\\t\\t};\\n\\t\\t\\tvar ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\\n\\n\\t\\t\\tme.handleDirectionalChanges();\\n\\n\\t\\t\\t// At this point, we need to update our max and min given the tick values since we have expanded the\\n\\t\\t\\t// range of the scale\\n\\t\\t\\tme.max = helpers.max(ticks);\\n\\t\\t\\tme.min = helpers.min(ticks);\\n\\n\\t\\t\\tif (tickOpts.reverse) {\\n\\t\\t\\t\\tticks.reverse();\\n\\n\\t\\t\\t\\tme.start = me.max;\\n\\t\\t\\t\\tme.end = me.min;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.start = me.min;\\n\\t\\t\\t\\tme.end = me.max;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.ticksAsNumbers = me.ticks.slice();\\n\\t\\t\\tme.zeroLineIndex = me.ticks.indexOf(0);\\n\\n\\t\\t\\tChart.Scale.prototype.convertTicksToLabels.call(me);\\n\\t\\t}\\n\\t});\\n};\\n\\n},{}],46:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'left',\\n\\n\\t\\t// label settings\\n\\t\\tticks: {\\n\\t\\t\\tcallback: Chart.Ticks.formatters.logarithmic\\n\\t\\t}\\n\\t};\\n\\n\\tvar LogarithmicScale = Chart.Scale.extend({\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar data = chart.data;\\n\\t\\t\\tvar datasets = data.datasets;\\n\\t\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\t\\t\\tvar isHorizontal = me.isHorizontal();\\n\\t\\t\\tfunction IDMatches(meta) {\\n\\t\\t\\t\\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Calculate Range\\n\\t\\t\\tme.min = null;\\n\\t\\t\\tme.max = null;\\n\\t\\t\\tme.minNotZero = null;\\n\\n\\t\\t\\tvar hasStacks = opts.stacked;\\n\\t\\t\\tif (hasStacks === undefined) {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tif (hasStacks) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\\n\\t\\t\\t\\t\\t\\tmeta.stack !== undefined) {\\n\\t\\t\\t\\t\\t\\thasStacks = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (opts.stacked || hasStacks) {\\n\\t\\t\\t\\tvar valuesPerStack = {};\\n\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tvar key = [\\n\\t\\t\\t\\t\\t\\tmeta.type,\\n\\t\\t\\t\\t\\t\\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\\n\\t\\t\\t\\t\\t\\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\\n\\t\\t\\t\\t\\t\\tmeta.stack\\n\\t\\t\\t\\t\\t].join('.');\\n\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\tif (valuesPerStack[key] === undefined) {\\n\\t\\t\\t\\t\\t\\t\\tvaluesPerStack[key] = [];\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar values = valuesPerStack[key];\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tvalues[index] = values[index] || 0;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (opts.relativePoints) {\\n\\t\\t\\t\\t\\t\\t\\t\\tvalues[index] = 100;\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\\n\\t\\t\\t\\t\\t\\t\\t\\tvalues[index] += value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\thelpers.each(valuesPerStack, function(valuesForType) {\\n\\t\\t\\t\\t\\tvar minVal = helpers.min(valuesForType);\\n\\t\\t\\t\\t\\tvar maxVal = helpers.max(valuesForType);\\n\\t\\t\\t\\t\\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\\n\\t\\t\\t\\t\\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thelpers.each(datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\t\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\\n\\t\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.min === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value < me.min) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.min = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (me.max === null) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t} else if (value > me.max) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.max = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.minNotZero = value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.min = getValueOrDefault(tickOpts.min, me.min);\\n\\t\\t\\tme.max = getValueOrDefault(tickOpts.max, me.max);\\n\\n\\t\\t\\tif (me.min === me.max) {\\n\\t\\t\\t\\tif (me.min !== 0 && me.min !== null) {\\n\\t\\t\\t\\t\\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\\n\\t\\t\\t\\t\\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tme.min = 1;\\n\\t\\t\\t\\t\\tme.max = 10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\tvar generationOptions = {\\n\\t\\t\\t\\tmin: tickOpts.min,\\n\\t\\t\\t\\tmax: tickOpts.max\\n\\t\\t\\t};\\n\\t\\t\\tvar ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\\n\\n\\t\\t\\tif (!me.isHorizontal()) {\\n\\t\\t\\t\\t// We are in a vertical orientation. The top value is the highest. So reverse the array\\n\\t\\t\\t\\tticks.reverse();\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, we need to update our max and min given the tick values since we have expanded the\\n\\t\\t\\t// range of the scale\\n\\t\\t\\tme.max = helpers.max(ticks);\\n\\t\\t\\tme.min = helpers.min(ticks);\\n\\n\\t\\t\\tif (tickOpts.reverse) {\\n\\t\\t\\t\\tticks.reverse();\\n\\n\\t\\t\\t\\tme.start = me.max;\\n\\t\\t\\t\\tme.end = me.min;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.start = me.min;\\n\\t\\t\\t\\tme.end = me.max;\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tthis.tickValues = this.ticks.slice();\\n\\n\\t\\t\\tChart.Scale.prototype.convertTicksToLabels.call(this);\\n\\t\\t},\\n\\t\\t// Get the correct tooltip label\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index) {\\n\\t\\t\\treturn this.getPixelForValue(this.tickValues[index]);\\n\\t\\t},\\n\\t\\tgetPixelForValue: function(value) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar innerDimension;\\n\\t\\t\\tvar pixel;\\n\\n\\t\\t\\tvar start = me.start;\\n\\t\\t\\tvar newVal = +me.getRightValue(value);\\n\\t\\t\\tvar range;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\\n\\t\\t\\t\\tif (newVal === 0) {\\n\\t\\t\\t\\t\\tpixel = me.left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tinnerDimension = me.width;\\n\\t\\t\\t\\t\\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Bottom - top since pixels increase downward on a screen\\n\\t\\t\\t\\tinnerDimension = me.height;\\n\\t\\t\\t\\tif (start === 0 && !tickOpts.reverse) {\\n\\t\\t\\t\\t\\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\\n\\t\\t\\t\\t\\tif (newVal === start) {\\n\\t\\t\\t\\t\\t\\tpixel = me.bottom;\\n\\t\\t\\t\\t\\t} else if (newVal === me.minNotZero) {\\n\\t\\t\\t\\t\\t\\tpixel = me.bottom - innerDimension * 0.02;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tpixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (me.end === 0 && tickOpts.reverse) {\\n\\t\\t\\t\\t\\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\\n\\t\\t\\t\\t\\tif (newVal === me.end) {\\n\\t\\t\\t\\t\\t\\tpixel = me.top;\\n\\t\\t\\t\\t\\t} else if (newVal === me.minNotZero) {\\n\\t\\t\\t\\t\\t\\tpixel = me.top + innerDimension * 0.02;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tpixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trange = helpers.log10(me.end) - helpers.log10(start);\\n\\t\\t\\t\\t\\tinnerDimension = me.height;\\n\\t\\t\\t\\t\\tpixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn pixel;\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\\n\\t\\t\\tvar value, innerDimension;\\n\\n\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\tinnerDimension = me.width;\\n\\t\\t\\t\\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\\n\\t\\t\\t} else {  // todo: if start === 0\\n\\t\\t\\t\\tinnerDimension = me.height;\\n\\t\\t\\t\\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\\n\\t\\t\\t}\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\\n\\n};\\n\\n},{}],47:[function(require,module,exports){\\n'use strict';\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar globalDefaults = Chart.defaults.global;\\n\\n\\tvar defaultConfig = {\\n\\t\\tdisplay: true,\\n\\n\\t\\t// Boolean - Whether to animate scaling the chart from the centre\\n\\t\\tanimate: true,\\n\\t\\tlineArc: false,\\n\\t\\tposition: 'chartArea',\\n\\n\\t\\tangleLines: {\\n\\t\\t\\tdisplay: true,\\n\\t\\t\\tcolor: 'rgba(0, 0, 0, 0.1)',\\n\\t\\t\\tlineWidth: 1\\n\\t\\t},\\n\\n\\t\\t// label settings\\n\\t\\tticks: {\\n\\t\\t\\t// Boolean - Show a backdrop to the scale label\\n\\t\\t\\tshowLabelBackdrop: true,\\n\\n\\t\\t\\t// String - The colour of the label backdrop\\n\\t\\t\\tbackdropColor: 'rgba(255,255,255,0.75)',\\n\\n\\t\\t\\t// Number - The backdrop padding above & below the label in pixels\\n\\t\\t\\tbackdropPaddingY: 2,\\n\\n\\t\\t\\t// Number - The backdrop padding to the side of the label in pixels\\n\\t\\t\\tbackdropPaddingX: 2,\\n\\n\\t\\t\\tcallback: Chart.Ticks.formatters.linear\\n\\t\\t},\\n\\n\\t\\tpointLabels: {\\n\\t\\t\\t// Number - Point label font size in pixels\\n\\t\\t\\tfontSize: 10,\\n\\n\\t\\t\\t// Function - Used to convert point labels\\n\\t\\t\\tcallback: function(label) {\\n\\t\\t\\t\\treturn label;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tfunction getValueCount(scale) {\\n\\t\\treturn !scale.options.lineArc ? scale.chart.data.labels.length : 0;\\n\\t}\\n\\n\\tfunction getPointLabelFontOptions(scale) {\\n\\t\\tvar pointLabelOptions = scale.options.pointLabels;\\n\\t\\tvar fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\\n\\t\\tvar fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\\n\\t\\tvar fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\\n\\t\\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\\n\\n\\t\\treturn {\\n\\t\\t\\tsize: fontSize,\\n\\t\\t\\tstyle: fontStyle,\\n\\t\\t\\tfamily: fontFamily,\\n\\t\\t\\tfont: font\\n\\t\\t};\\n\\t}\\n\\n\\tfunction measureLabelSize(ctx, fontSize, label) {\\n\\t\\tif (helpers.isArray(label)) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tw: helpers.longestText(ctx, ctx.font, label),\\n\\t\\t\\t\\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tw: ctx.measureText(label).width,\\n\\t\\t\\th: fontSize\\n\\t\\t};\\n\\t}\\n\\n\\tfunction determineLimits(angle, pos, size, min, max) {\\n\\t\\tif (angle === min || angle === max) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstart: pos - (size / 2),\\n\\t\\t\\t\\tend: pos + (size / 2)\\n\\t\\t\\t};\\n\\t\\t} else if (angle < min || angle > max) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tstart: pos - size - 5,\\n\\t\\t\\t\\tend: pos\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tstart: pos,\\n\\t\\t\\tend: pos + size + 5\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to fit a radial linear scale with point labels\\n\\t */\\n\\tfunction fitWithPointLabels(scale) {\\n\\t\\t/*\\n\\t\\t * Right, this is really confusing and there is a lot of maths going on here\\n\\t\\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\\n\\t\\t *\\n\\t\\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\\n\\t\\t *\\n\\t\\t * Solution:\\n\\t\\t *\\n\\t\\t * We assume the radius of the polygon is half the size of the canvas at first\\n\\t\\t * at each index we check if the text overlaps.\\n\\t\\t *\\n\\t\\t * Where it does, we store that angle and that index.\\n\\t\\t *\\n\\t\\t * After finding the largest index and angle we calculate how much we need to remove\\n\\t\\t * from the shape radius to move the point inwards by that x.\\n\\t\\t *\\n\\t\\t * We average the left and right distances to get the maximum shape radius that can fit in the box\\n\\t\\t * along with labels.\\n\\t\\t *\\n\\t\\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\\n\\t\\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\\n\\t\\t *\\n\\t\\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\\n\\t\\t * and position it in the most space efficient manner\\n\\t\\t *\\n\\t\\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\\n\\t\\t */\\n\\n\\t\\tvar plFont = getPointLabelFontOptions(scale);\\n\\n\\t\\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\\n\\t\\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\\n\\t\\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\\n\\t\\tvar furthestLimits = {\\n\\t\\t\\tl: scale.width,\\n\\t\\t\\tr: 0,\\n\\t\\t\\tt: scale.height,\\n\\t\\t\\tb: 0\\n\\t\\t};\\n\\t\\tvar furthestAngles = {};\\n\\t\\tvar i;\\n\\t\\tvar textSize;\\n\\t\\tvar pointPosition;\\n\\n\\t\\tscale.ctx.font = plFont.font;\\n\\t\\tscale._pointLabelSizes = [];\\n\\n\\t\\tvar valueCount = getValueCount(scale);\\n\\t\\tfor (i = 0; i < valueCount; i++) {\\n\\t\\t\\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\\n\\t\\t\\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\\n\\t\\t\\tscale._pointLabelSizes[i] = textSize;\\n\\n\\t\\t\\t// Add quarter circle to make degree 0 mean top of circle\\n\\t\\t\\tvar angleRadians = scale.getIndexAngle(i);\\n\\t\\t\\tvar angle = helpers.toDegrees(angleRadians) % 360;\\n\\t\\t\\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\\n\\t\\t\\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\\n\\n\\t\\t\\tif (hLimits.start < furthestLimits.l) {\\n\\t\\t\\t\\tfurthestLimits.l = hLimits.start;\\n\\t\\t\\t\\tfurthestAngles.l = angleRadians;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (hLimits.end > furthestLimits.r) {\\n\\t\\t\\t\\tfurthestLimits.r = hLimits.end;\\n\\t\\t\\t\\tfurthestAngles.r = angleRadians;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (vLimits.start < furthestLimits.t) {\\n\\t\\t\\t\\tfurthestLimits.t = vLimits.start;\\n\\t\\t\\t\\tfurthestAngles.t = angleRadians;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (vLimits.end > furthestLimits.b) {\\n\\t\\t\\t\\tfurthestLimits.b = vLimits.end;\\n\\t\\t\\t\\tfurthestAngles.b = angleRadians;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\\n\\t}\\n\\n\\t/**\\n\\t * Helper function to fit a radial linear scale with no point labels\\n\\t */\\n\\tfunction fit(scale) {\\n\\t\\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\\n\\t\\tscale.drawingArea = Math.round(largestPossibleRadius);\\n\\t\\tscale.setCenterPoint(0, 0, 0, 0);\\n\\t}\\n\\n\\tfunction getTextAlignForAngle(angle) {\\n\\t\\tif (angle === 0 || angle === 180) {\\n\\t\\t\\treturn 'center';\\n\\t\\t} else if (angle < 180) {\\n\\t\\t\\treturn 'left';\\n\\t\\t}\\n\\n\\t\\treturn 'right';\\n\\t}\\n\\n\\tfunction fillText(ctx, text, position, fontSize) {\\n\\t\\tif (helpers.isArray(text)) {\\n\\t\\t\\tvar y = position.y;\\n\\t\\t\\tvar spacing = 1.5 * fontSize;\\n\\n\\t\\t\\tfor (var i = 0; i < text.length; ++i) {\\n\\t\\t\\t\\tctx.fillText(text[i], position.x, y);\\n\\t\\t\\t\\ty+= spacing;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tctx.fillText(text, position.x, position.y);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\\n\\t\\tif (angle === 90 || angle === 270) {\\n\\t\\t\\tposition.y -= (textSize.h / 2);\\n\\t\\t} else if (angle > 270 || angle < 90) {\\n\\t\\t\\tposition.y -= textSize.h;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction drawPointLabels(scale) {\\n\\t\\tvar ctx = scale.ctx;\\n\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\t\\tvar opts = scale.options;\\n\\t\\tvar angleLineOpts = opts.angleLines;\\n\\t\\tvar pointLabelOpts = opts.pointLabels;\\n\\n\\t\\tctx.lineWidth = angleLineOpts.lineWidth;\\n\\t\\tctx.strokeStyle = angleLineOpts.color;\\n\\n\\t\\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\\n\\n\\t\\t// Point Label Font\\n\\t\\tvar plFont = getPointLabelFontOptions(scale);\\n\\n\\t\\tctx.textBaseline = 'top';\\n\\n\\t\\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\\n\\t\\t\\tif (angleLineOpts.display) {\\n\\t\\t\\t\\tvar outerPosition = scale.getPointPosition(i, outerDistance);\\n\\t\\t\\t\\tctx.beginPath();\\n\\t\\t\\t\\tctx.moveTo(scale.xCenter, scale.yCenter);\\n\\t\\t\\t\\tctx.lineTo(outerPosition.x, outerPosition.y);\\n\\t\\t\\t\\tctx.stroke();\\n\\t\\t\\t\\tctx.closePath();\\n\\t\\t\\t}\\n\\t\\t\\t// Extra 3px out for some label spacing\\n\\t\\t\\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\\n\\n\\t\\t\\t// Keep this in loop since we may support array properties here\\n\\t\\t\\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\tctx.font = plFont.font;\\n\\t\\t\\tctx.fillStyle = pointLabelFontColor;\\n\\n\\t\\t\\tvar angleRadians = scale.getIndexAngle(i);\\n\\t\\t\\tvar angle = helpers.toDegrees(angleRadians);\\n\\t\\t\\tctx.textAlign = getTextAlignForAngle(angle);\\n\\t\\t\\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\\n\\t\\t\\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\\n\\t\\tvar ctx = scale.ctx;\\n\\t\\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\\n\\t\\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\\n\\n\\t\\tif (scale.options.lineArc) {\\n\\t\\t\\t// Draw circular arcs between the points\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.stroke();\\n\\t\\t} else {\\n\\t\\t\\t// Draw straight lines connecting each index\\n\\t\\t\\tvar valueCount = getValueCount(scale);\\n\\n\\t\\t\\tif (valueCount === 0) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.beginPath();\\n\\t\\t\\tvar pointPosition = scale.getPointPosition(0, radius);\\n\\t\\t\\tctx.moveTo(pointPosition.x, pointPosition.y);\\n\\n\\t\\t\\tfor (var i = 1; i < valueCount; i++) {\\n\\t\\t\\t\\tpointPosition = scale.getPointPosition(i, radius);\\n\\t\\t\\t\\tctx.lineTo(pointPosition.x, pointPosition.y);\\n\\t\\t\\t}\\n\\n\\t\\t\\tctx.closePath();\\n\\t\\t\\tctx.stroke();\\n\\t\\t}\\n\\t}\\n\\n\\tfunction numberOrZero(param) {\\n\\t\\treturn helpers.isNumber(param) ? param : 0;\\n\\t}\\n\\n\\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\\n\\t\\tsetDimensions: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\t// Set the unconstrained dimension before label rotation\\n\\t\\t\\tme.width = me.maxWidth;\\n\\t\\t\\tme.height = me.maxHeight;\\n\\t\\t\\tme.xCenter = Math.round(me.width / 2);\\n\\t\\t\\tme.yCenter = Math.round(me.height / 2);\\n\\n\\t\\t\\tvar minSize = helpers.min([me.height, me.width]);\\n\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\\n\\t\\t\\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\\n\\t\\t},\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar chart = me.chart;\\n\\t\\t\\tvar min = Number.POSITIVE_INFINITY;\\n\\t\\t\\tvar max = Number.NEGATIVE_INFINITY;\\n\\n\\t\\t\\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tif (chart.isDatasetVisible(datasetIndex)) {\\n\\t\\t\\t\\t\\tvar meta = chart.getDatasetMeta(datasetIndex);\\n\\n\\t\\t\\t\\t\\thelpers.each(dataset.data, function(rawValue, index) {\\n\\t\\t\\t\\t\\t\\tvar value = +me.getRightValue(rawValue);\\n\\t\\t\\t\\t\\t\\tif (isNaN(value) || meta.data[index].hidden) {\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tmin = Math.min(value, min);\\n\\t\\t\\t\\t\\t\\tmax = Math.max(value, max);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\\n\\t\\t\\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\\n\\n\\t\\t\\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\\n\\t\\t\\tme.handleTickRangeOptions();\\n\\t\\t},\\n\\t\\tgetTickLimit: function() {\\n\\t\\t\\tvar tickOpts = this.options.ticks;\\n\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\\n\\t\\t\\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\\n\\n\\t\\t\\t// Point labels\\n\\t\\t\\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\\n\\t\\t},\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\\n\\t\\t},\\n\\t\\tfit: function() {\\n\\t\\t\\tif (this.options.lineArc) {\\n\\t\\t\\t\\tfit(this);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfitWithPointLabels(this);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\t/**\\n\\t\\t * Set radius reductions and determine new radius and center point\\n\\t\\t * @private\\n\\t\\t */\\n\\t\\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\\n\\t\\t\\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\\n\\t\\t\\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\\n\\t\\t\\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\\n\\n\\t\\t\\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\\n\\t\\t\\tradiusReductionRight = numberOrZero(radiusReductionRight);\\n\\t\\t\\tradiusReductionTop = numberOrZero(radiusReductionTop);\\n\\t\\t\\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\\n\\n\\t\\t\\tme.drawingArea = Math.min(\\n\\t\\t\\t\\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\\n\\t\\t\\t\\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\\n\\t\\t\\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\\n\\t\\t},\\n\\t\\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar maxRight = me.width - rightMovement - me.drawingArea,\\n\\t\\t\\t\\tmaxLeft = leftMovement + me.drawingArea,\\n\\t\\t\\t\\tmaxTop = topMovement + me.drawingArea,\\n\\t\\t\\t\\tmaxBottom = me.height - bottomMovement - me.drawingArea;\\n\\n\\t\\t\\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\\n\\t\\t\\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\\n\\t\\t},\\n\\n\\t\\tgetIndexAngle: function(index) {\\n\\t\\t\\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\\n\\t\\t\\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\\n\\t\\t\\t\\tthis.chart.options.startAngle :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t\\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\\n\\n\\t\\t\\t// Start from the top instead of right, so remove a quarter of the circle\\n\\t\\t\\treturn index * angleMultiplier + startAngleRadians;\\n\\t\\t},\\n\\t\\tgetDistanceFromCenterForValue: function(value) {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tif (value === null) {\\n\\t\\t\\t\\treturn 0; // null always in center\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take into account half font size + the yPadding of the top value\\n\\t\\t\\tvar scalingFactor = me.drawingArea / (me.max - me.min);\\n\\t\\t\\tif (me.options.reverse) {\\n\\t\\t\\t\\treturn (me.max - value) * scalingFactor;\\n\\t\\t\\t}\\n\\t\\t\\treturn (value - me.min) * scalingFactor;\\n\\t\\t},\\n\\t\\tgetPointPosition: function(index, distanceFromCenter) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\\n\\t\\t\\t\\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tgetPointPositionForValue: function(index, value) {\\n\\t\\t\\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\\n\\t\\t},\\n\\n\\t\\tgetBasePosition: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar min = me.min;\\n\\t\\t\\tvar max = me.max;\\n\\n\\t\\t\\treturn me.getPointPositionForValue(0,\\n\\t\\t\\t\\tme.beginAtZero? 0:\\n\\t\\t\\t\\tmin < 0 && max < 0? max :\\n\\t\\t\\t\\tmin > 0 && max > 0? min :\\n\\t\\t\\t\\t0);\\n\\t\\t},\\n\\n\\t\\tdraw: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar opts = me.options;\\n\\t\\t\\tvar gridLineOpts = opts.gridLines;\\n\\t\\t\\tvar tickOpts = opts.ticks;\\n\\t\\t\\tvar getValueOrDefault = helpers.getValueOrDefault;\\n\\n\\t\\t\\tif (opts.display) {\\n\\t\\t\\t\\tvar ctx = me.ctx;\\n\\n\\t\\t\\t\\t// Tick Font\\n\\t\\t\\t\\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\\n\\t\\t\\t\\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\\n\\t\\t\\t\\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\\n\\t\\t\\t\\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\\n\\n\\t\\t\\t\\thelpers.each(me.ticks, function(label, index) {\\n\\t\\t\\t\\t\\t// Don't draw a centre value (if it is minimum)\\n\\t\\t\\t\\t\\tif (index > 0 || opts.reverse) {\\n\\t\\t\\t\\t\\t\\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\\n\\t\\t\\t\\t\\t\\tvar yHeight = me.yCenter - yCenterOffset;\\n\\n\\t\\t\\t\\t\\t\\t// Draw circular lines around the scale\\n\\t\\t\\t\\t\\t\\tif (gridLineOpts.display && index !== 0) {\\n\\t\\t\\t\\t\\t\\t\\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (tickOpts.display) {\\n\\t\\t\\t\\t\\t\\t\\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\\n\\t\\t\\t\\t\\t\\t\\tctx.font = tickLabelFont;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (tickOpts.showLabelBackdrop) {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar labelWidth = ctx.measureText(label).width;\\n\\t\\t\\t\\t\\t\\t\\t\\tctx.fillStyle = tickOpts.backdropColor;\\n\\t\\t\\t\\t\\t\\t\\t\\tctx.fillRect(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlabelWidth + tickOpts.backdropPaddingX * 2,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttickFontSize + tickOpts.backdropPaddingY * 2\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tctx.textAlign = 'center';\\n\\t\\t\\t\\t\\t\\t\\tctx.textBaseline = 'middle';\\n\\t\\t\\t\\t\\t\\t\\tctx.fillStyle = tickFontColor;\\n\\t\\t\\t\\t\\t\\t\\tctx.fillText(label, me.xCenter, yHeight);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (!opts.lineArc) {\\n\\t\\t\\t\\t\\tdrawPointLabels(me);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\\n\\n};\\n\\n},{}],48:[function(require,module,exports){\\n/* global window: false */\\n'use strict';\\n\\nvar moment = require(6);\\nmoment = typeof(moment) === 'function' ? moment : window.moment;\\n\\nmodule.exports = function(Chart) {\\n\\n\\tvar helpers = Chart.helpers;\\n\\tvar time = {\\n\\t\\tunits: [{\\n\\t\\t\\tname: 'millisecond',\\n\\t\\t\\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\\n\\t\\t}, {\\n\\t\\t\\tname: 'second',\\n\\t\\t\\tsteps: [1, 2, 5, 10, 30]\\n\\t\\t}, {\\n\\t\\t\\tname: 'minute',\\n\\t\\t\\tsteps: [1, 2, 5, 10, 30]\\n\\t\\t}, {\\n\\t\\t\\tname: 'hour',\\n\\t\\t\\tsteps: [1, 2, 3, 6, 12]\\n\\t\\t}, {\\n\\t\\t\\tname: 'day',\\n\\t\\t\\tsteps: [1, 2, 5]\\n\\t\\t}, {\\n\\t\\t\\tname: 'week',\\n\\t\\t\\tmaxStep: 4\\n\\t\\t}, {\\n\\t\\t\\tname: 'month',\\n\\t\\t\\tmaxStep: 3\\n\\t\\t}, {\\n\\t\\t\\tname: 'quarter',\\n\\t\\t\\tmaxStep: 4\\n\\t\\t}, {\\n\\t\\t\\tname: 'year',\\n\\t\\t\\tmaxStep: false\\n\\t\\t}]\\n\\t};\\n\\n\\tvar defaultConfig = {\\n\\t\\tposition: 'bottom',\\n\\n\\t\\ttime: {\\n\\t\\t\\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\\n\\t\\t\\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\\n\\t\\t\\tunit: false, // false == automatic or override with week, month, year, etc.\\n\\t\\t\\tround: false, // none, or override with week, month, year, etc.\\n\\t\\t\\tdisplayFormat: false, // DEPRECATED\\n\\t\\t\\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\\n\\t\\t\\tminUnit: 'millisecond',\\n\\n\\t\\t\\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\\n\\t\\t\\tdisplayFormats: {\\n\\t\\t\\t\\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\\n\\t\\t\\t\\tsecond: 'h:mm:ss a', // 11:20:01 AM\\n\\t\\t\\t\\tminute: 'h:mm:ss a', // 11:20:01 AM\\n\\t\\t\\t\\thour: 'MMM D, hA', // Sept 4, 5PM\\n\\t\\t\\t\\tday: 'll', // Sep 4 2015\\n\\t\\t\\t\\tweek: 'll', // Week 46, or maybe \\\"[W]WW - YYYY\\\" ?\\n\\t\\t\\t\\tmonth: 'MMM YYYY', // Sept 2015\\n\\t\\t\\t\\tquarter: '[Q]Q - YYYY', // Q3\\n\\t\\t\\t\\tyear: 'YYYY' // 2015\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tticks: {\\n\\t\\t\\tautoSkip: false\\n\\t\\t}\\n\\t};\\n\\n\\tvar TimeScale = Chart.Scale.extend({\\n\\t\\tinitialize: function() {\\n\\t\\t\\tif (!moment) {\\n\\t\\t\\t\\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\\n\\t\\t\\t}\\n\\n\\t\\t\\tChart.Scale.prototype.initialize.call(this);\\n\\t\\t},\\n\\t\\tgetLabelMoment: function(datasetIndex, index) {\\n\\t\\t\\tif (datasetIndex === null || index === null) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof this.labelMoments[datasetIndex] !== 'undefined') {\\n\\t\\t\\t\\treturn this.labelMoments[datasetIndex][index];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tgetLabelDiff: function(datasetIndex, index) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (datasetIndex === null || index === null) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.labelDiffs === undefined) {\\n\\t\\t\\t\\tme.buildLabelDiffs();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\\n\\t\\t\\t\\treturn me.labelDiffs[datasetIndex][index];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tgetMomentStartOf: function(tick) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\\n\\t\\t\\t\\treturn tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\\n\\t\\t\\t}\\n\\t\\t\\treturn tick.clone().startOf(me.tickUnit);\\n\\t\\t},\\n\\t\\tdetermineDataLimits: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.labelMoments = [];\\n\\n\\t\\t\\t// Only parse these once. If the dataset does not have data as x,y pairs, we will use\\n\\t\\t\\t// these\\n\\t\\t\\tvar scaleLabelMoments = [];\\n\\t\\t\\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\\n\\t\\t\\t\\thelpers.each(me.chart.data.labels, function(label) {\\n\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(label);\\n\\n\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tscaleLabelMoments.push(labelMoment);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}, me);\\n\\n\\t\\t\\t\\tme.firstTick = moment.min.call(me, scaleLabelMoments);\\n\\t\\t\\t\\tme.lastTick = moment.max.call(me, scaleLabelMoments);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tme.firstTick = null;\\n\\t\\t\\t\\tme.lastTick = null;\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\\n\\t\\t\\t\\tvar momentsForDataset = [];\\n\\t\\t\\t\\tvar datasetVisible = me.chart.isDatasetVisible(datasetIndex);\\n\\n\\t\\t\\t\\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\\n\\t\\t\\t\\t\\thelpers.each(dataset.data, function(value) {\\n\\t\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(me.getRightValue(value));\\n\\n\\t\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tmomentsForDataset.push(labelMoment);\\n\\n\\t\\t\\t\\t\\t\\t\\tif (datasetVisible) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// May have gone outside the scale ranges, make sure we keep the first and last ticks updated\\n\\t\\t\\t\\t\\t\\t\\t\\tme.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\\n\\t\\t\\t\\t\\t\\t\\t\\tme.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, me);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// We have no labels. Use the ones from the scale\\n\\t\\t\\t\\t\\tmomentsForDataset = scaleLabelMoments;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.labelMoments.push(momentsForDataset);\\n\\t\\t\\t}, me);\\n\\n\\t\\t\\t// Set these after we've done all the data\\n\\t\\t\\tif (me.options.time.min) {\\n\\t\\t\\t\\tme.firstTick = me.parseTime(me.options.time.min);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (me.options.time.max) {\\n\\t\\t\\t\\tme.lastTick = me.parseTime(me.options.time.max);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// We will modify these, so clone for later\\n\\t\\t\\tme.firstTick = (me.firstTick || moment()).clone();\\n\\t\\t\\tme.lastTick = (me.lastTick || moment()).clone();\\n\\t\\t},\\n\\t\\tbuildLabelDiffs: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.labelDiffs = [];\\n\\t\\t\\tvar scaleLabelDiffs = [];\\n\\t\\t\\t// Parse common labels once\\n\\t\\t\\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\\n\\t\\t\\t\\thelpers.each(me.chart.data.labels, function(label) {\\n\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(label);\\n\\n\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tscaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}, me);\\n\\t\\t\\t}\\n\\n\\t\\t\\thelpers.each(me.chart.data.datasets, function(dataset) {\\n\\t\\t\\t\\tvar diffsForDataset = [];\\n\\n\\t\\t\\t\\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\\n\\t\\t\\t\\t\\thelpers.each(dataset.data, function(value) {\\n\\t\\t\\t\\t\\t\\tvar labelMoment = me.parseTime(me.getRightValue(value));\\n\\n\\t\\t\\t\\t\\t\\tif (labelMoment.isValid()) {\\n\\t\\t\\t\\t\\t\\t\\tif (me.options.time.round) {\\n\\t\\t\\t\\t\\t\\t\\t\\tlabelMoment.startOf(me.options.time.round);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tdiffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, me);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// We have no labels. Use common ones\\n\\t\\t\\t\\t\\tdiffsForDataset = scaleLabelDiffs;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.labelDiffs.push(diffsForDataset);\\n\\t\\t\\t}, me);\\n\\t\\t},\\n\\t\\tbuildTicks: function() {\\n\\t\\t\\tvar me = this;\\n\\n\\t\\t\\tme.ctx.save();\\n\\t\\t\\tvar tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\\n\\t\\t\\tvar tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\\n\\t\\t\\tvar tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\\n\\t\\t\\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\\n\\t\\t\\tme.ctx.font = tickLabelFont;\\n\\n\\t\\t\\tme.ticks = [];\\n\\t\\t\\tme.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\\n\\t\\t\\tme.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\\n\\n\\t\\t\\t// Set unit override if applicable\\n\\t\\t\\tif (me.options.time.unit) {\\n\\t\\t\\t\\tme.tickUnit = me.options.time.unit || 'day';\\n\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\\n\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Determine the smallest needed unit of the time\\n\\t\\t\\t\\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\\n\\n\\t\\t\\t\\t// Crude approximation of what the label length might be\\n\\t\\t\\t\\tvar tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\\n\\t\\t\\t\\tvar tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\\n\\t\\t\\t\\tvar cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\\n\\t\\t\\t\\tvar sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\\n\\t\\t\\t\\ttickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\\n\\t\\t\\t\\tvar labelCapacity = innerWidth / (tickLabelWidth);\\n\\n\\t\\t\\t\\t// Start as small as possible\\n\\t\\t\\t\\tme.tickUnit = me.options.time.minUnit;\\n\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\\n\\n\\t\\t\\t\\tvar unitDefinitionIndex = 0;\\n\\t\\t\\t\\tvar unitDefinition = time.units[unitDefinitionIndex];\\n\\n\\t\\t\\t\\t// While we aren't ideal and we don't have units left\\n\\t\\t\\t\\twhile (unitDefinitionIndex < time.units.length) {\\n\\t\\t\\t\\t\\t// Can we scale this unit. If `false` we can scale infinitely\\n\\t\\t\\t\\t\\tme.unitScale = 1;\\n\\n\\t\\t\\t\\t\\tif (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\\n\\t\\t\\t\\t\\t\\t// Use one of the predefined steps\\n\\t\\t\\t\\t\\t\\tfor (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\\n\\t\\t\\t\\t\\t\\t\\tif (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {\\n\\t\\t\\t\\t\\t\\t// We have a max step. Scale this unit\\n\\t\\t\\t\\t\\t\\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// Move to the next unit up\\n\\t\\t\\t\\t\\t\\t++unitDefinitionIndex;\\n\\t\\t\\t\\t\\t\\tunitDefinition = time.units[unitDefinitionIndex];\\n\\n\\t\\t\\t\\t\\t\\tme.tickUnit = unitDefinition.name;\\n\\t\\t\\t\\t\\t\\tvar leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\\n\\t\\t\\t\\t\\t\\tvar trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\\n\\t\\t\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\\n\\t\\t\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormats[unitDefinition.name];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar roundedStart;\\n\\n\\t\\t\\t// Only round the first tick if we have no hard minimum\\n\\t\\t\\tif (!me.options.time.min) {\\n\\t\\t\\t\\tme.firstTick = me.getMomentStartOf(me.firstTick);\\n\\t\\t\\t\\troundedStart = me.firstTick;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\troundedStart = me.getMomentStartOf(me.firstTick);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only round the last tick if we have no hard maximum\\n\\t\\t\\tif (!me.options.time.max) {\\n\\t\\t\\t\\tvar roundedEnd = me.getMomentStartOf(me.lastTick);\\n\\t\\t\\t\\tvar delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\\n\\t\\t\\t\\tif (delta < 0) {\\n\\t\\t\\t\\t\\t// Do not use end of because we need me to be in the next time unit\\n\\t\\t\\t\\t\\tme.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\\n\\t\\t\\t\\t} else if (delta >= 0) {\\n\\t\\t\\t\\t\\tme.lastTick = roundedEnd;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Tick displayFormat override\\n\\t\\t\\tif (me.options.time.displayFormat) {\\n\\t\\t\\t\\tme.displayFormat = me.options.time.displayFormat;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// first tick. will have been rounded correctly if options.time.min is not specified\\n\\t\\t\\tme.ticks.push(me.firstTick.clone());\\n\\n\\t\\t\\t// For every unit in between the first and last moment, create a moment and add it to the ticks tick\\n\\t\\t\\tfor (var i = me.unitScale; i <= me.scaleSizeInUnits; i += me.unitScale) {\\n\\t\\t\\t\\tvar newTick = roundedStart.clone().add(i, me.tickUnit);\\n\\n\\t\\t\\t\\t// Are we greater than the max time\\n\\t\\t\\t\\tif (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tme.ticks.push(newTick);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Always show the right tick\\n\\t\\t\\tvar diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\\n\\t\\t\\tif (diff !== 0 || me.scaleSizeInUnits === 0) {\\n\\t\\t\\t\\t// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\\n\\t\\t\\t\\t// but the last tick was not rounded.\\n\\t\\t\\t\\tif (me.options.time.max) {\\n\\t\\t\\t\\t\\tme.ticks.push(me.lastTick.clone());\\n\\t\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tme.ticks.push(me.lastTick.clone());\\n\\t\\t\\t\\t\\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tme.ctx.restore();\\n\\n\\t\\t\\t// Invalidate label diffs cache\\n\\t\\t\\tme.labelDiffs = undefined;\\n\\t\\t},\\n\\t\\t// Get tooltip label\\n\\t\\tgetLabelForIndex: function(index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\\n\\t\\t\\tvar value = me.chart.data.datasets[datasetIndex].data[index];\\n\\n\\t\\t\\tif (value !== null && typeof value === 'object') {\\n\\t\\t\\t\\tlabel = me.getRightValue(value);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Format nicely\\n\\t\\t\\tif (me.options.time.tooltipFormat) {\\n\\t\\t\\t\\tlabel = me.parseTime(label).format(me.options.time.tooltipFormat);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn label;\\n\\t\\t},\\n\\t\\t// Function to format an individual tick mark\\n\\t\\ttickFormatFunction: function(tick, index, ticks) {\\n\\t\\t\\tvar formattedTick = tick.format(this.displayFormat);\\n\\t\\t\\tvar tickOpts = this.options.ticks;\\n\\t\\t\\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\\n\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\treturn callback(formattedTick, index, ticks);\\n\\t\\t\\t}\\n\\t\\t\\treturn formattedTick;\\n\\t\\t},\\n\\t\\tconvertTicksToLabels: function() {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tme.tickMoments = me.ticks;\\n\\t\\t\\tme.ticks = me.ticks.map(me.tickFormatFunction, me);\\n\\t\\t},\\n\\t\\tgetPixelForValue: function(value, index, datasetIndex) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar offset = null;\\n\\t\\t\\tif (index !== undefined && datasetIndex !== undefined) {\\n\\t\\t\\t\\toffset = me.getLabelDiff(datasetIndex, index);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (offset === null) {\\n\\t\\t\\t\\tif (!value || !value.isValid) {\\n\\t\\t\\t\\t\\t// not already a moment object\\n\\t\\t\\t\\t\\tvalue = me.parseTime(me.getRightValue(value));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (value && value.isValid && value.isValid()) {\\n\\t\\t\\t\\t\\toffset = value.diff(me.firstTick, me.tickUnit, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (offset !== null) {\\n\\t\\t\\t\\tvar decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\\n\\n\\t\\t\\t\\tif (me.isHorizontal()) {\\n\\t\\t\\t\\t\\tvar valueOffset = (me.width * decimal);\\n\\t\\t\\t\\t\\treturn me.left + Math.round(valueOffset);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar heightOffset = (me.height * decimal);\\n\\t\\t\\t\\treturn me.top + Math.round(heightOffset);\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgetPixelForTick: function(index) {\\n\\t\\t\\treturn this.getPixelForValue(this.tickMoments[index], null, null);\\n\\t\\t},\\n\\t\\tgetValueForPixel: function(pixel) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tvar innerDimension = me.isHorizontal() ? me.width : me.height;\\n\\t\\t\\tvar offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\\n\\t\\t\\toffset *= me.scaleSizeInUnits;\\n\\t\\t\\treturn me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\\n\\t\\t},\\n\\t\\tparseTime: function(label) {\\n\\t\\t\\tvar me = this;\\n\\t\\t\\tif (typeof me.options.time.parser === 'string') {\\n\\t\\t\\t\\treturn moment(label, me.options.time.parser);\\n\\t\\t\\t}\\n\\t\\t\\tif (typeof me.options.time.parser === 'function') {\\n\\t\\t\\t\\treturn me.options.time.parser(label);\\n\\t\\t\\t}\\n\\t\\t\\t// Date objects\\n\\t\\t\\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\\n\\t\\t\\t\\treturn moment(label);\\n\\t\\t\\t}\\n\\t\\t\\t// Moment support\\n\\t\\t\\tif (label.isValid && label.isValid()) {\\n\\t\\t\\t\\treturn label;\\n\\t\\t\\t}\\n\\t\\t\\t// Custom parsing (return an instance of moment)\\n\\t\\t\\tif (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\\n\\t\\t\\t\\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\\n\\t\\t\\t\\treturn me.options.time.format(label);\\n\\t\\t\\t}\\n\\t\\t\\t// Moment format parsing\\n\\t\\t\\treturn moment(label, me.options.time.format);\\n\\t\\t}\\n\\t});\\n\\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\\n\\n};\\n\\n},{\\\"6\\\":6}]},{},[7])(7)\\n});\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/source-map-loader!./src/app/charts/height/js/Chart.bundle.js\n// module id = 1090\n// module chunks = 2","module.exports = \"window.chartColors = {\\n\\tred: 'rgb(255, 99, 132)',\\n\\torange: 'rgb(255, 159, 64)',\\n\\tyellow: 'rgb(255, 205, 86)',\\n\\tgreen: 'rgb(75, 192, 192)',\\n\\tblue: 'rgb(54, 162, 235)',\\n\\tpurple: 'rgb(153, 102, 255)',\\n\\tgrey: 'rgb(231,233,237)'\\n};\\n\\nwindow.randomScalingFactor = function() {\\n\\treturn (Math.random() > 0.5 ? 1.0 : 1.0) * Math.round(Math.random() * 100);\\n}\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./~/source-map-loader!./src/app/charts/height/js/utils.js\n// module id = 1091\n// module chunks = 2","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader/addScript.js\n// module id = 136\n// module chunks = 2","require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\script-loader\\\\addScript.js\")(require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\raw-loader\\\\index.js!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\fullcalendar\\\\dist\\\\fullcalendar.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./~/fullcalendar/dist/fullcalendar.js\n// module id = 651\n// module chunks = 2","require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\script-loader\\\\addScript.js\")(require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\raw-loader\\\\index.js!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\jquery\\\\dist\\\\jquery.min.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./~/jquery/dist/jquery.min.js\n// module id = 652\n// module chunks = 2","require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\script-loader\\\\addScript.js\")(require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\raw-loader\\\\index.js!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\moment\\\\min\\\\moment.min.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./~/moment/min/moment.min.js\n// module id = 653\n// module chunks = 2","require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\script-loader\\\\addScript.js\")(require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\raw-loader\\\\index.js!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\source-map-loader\\\\index.js!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\src\\\\app\\\\charts\\\\height\\\\js\\\\Chart.bundle.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./src/app/charts/height/js/Chart.bundle.js\n// module id = 654\n// module chunks = 2","require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\script-loader\\\\addScript.js\")(require(\"!!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\raw-loader\\\\index.js!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\node_modules\\\\source-map-loader\\\\index.js!D:\\\\2nd Year Project\\\\healo\\\\Healo\\\\src\\\\app\\\\charts\\\\height\\\\js\\\\utils.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/script-loader!./src/app/charts/height/js/utils.js\n// module id = 655\n// module chunks = 2"],"sourceRoot":""}